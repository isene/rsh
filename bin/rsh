#!/usr/bin/env ruby
# encoding: utf-8
#
# SCRIPT INFO 
# Name:       rsh - Ruby SHell
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/rsh
# License:    Public domain
@version    = "3.2.0" # Plugin system: Extensible architecture with lifecycle hooks, completions, commands, and plugin management

# MODULES, CLASSES AND EXTENSIONS
class String # Add coloring to strings (with escaping for Readline)
  def c(code);  color(self, "\001\e[38;5;#{code}m\002"); end  # Color code
  def b;        color(self, "\001\e[1m\002"); end             # Bold
  def i;        color(self, "\001\e[3m\002"); end             # Italic
  def u;        color(self, "\001\e[4m\002"); end             # Underline
  def l;        color(self, "\001\e[5m\002"); end             # Blink
  def r;        color(self, "\001\e[7m\002"); end             # Reverse
  def color(text, color_code)  "#{color_code}#{text}\001\e[0m\002" end
end
module Cursor # Terminal cursor movement ANSI codes (thanks to https://github.com/piotrmurach/tty-cursor)
  module_function
  ESC = "\e".freeze
  CSI = "\e[".freeze
  def save # Save current position
    print(Gem.win_platform? ? CSI + 's' : ESC + '7')
  end
  def restore # Restore cursor position
    print(Gem.win_platform? ? CSI + 'u' : ESC + '8')
  end
  def pos # Query cursor current position
    res = ''
    begin
      $stdin.raw do |stdin|
        $stdout << CSI + '6n' # Tha actual ANSI get-position
        $stdout.flush
        while (c = stdin.getc) != 'R'
          res << c if c
      end
      end
    rescue Errno::ENOTTY
      # Not a TTY, return default values
      return 25, 80
    end
    m = res.match /(?<row>\d+);(?<col>\d+)/
    return m ? [m[:row].to_i, m[:col].to_i] : [25, 80]
  end
  def rowget
    row, col = self.pos
    return row
  end
  def colget
    row, col = self.pos
    return col
  end
  def col(n = nil) # Cursor moves to nth position horizontally in the current line
    print(CSI + "#{n || 1}G")
  end
  def row(n = nil) # Cursor moves to the nth position vertically in the current column
    print(CSI + "#{n || 1}d")
  end
  def next_line # Move cursor down to beginning of next line
    print(CSI + 'E' + CSI + "1G")
  end
  def clear_line # Erase the entire current line and return to beginning of the line
    print(CSI + '2K' +  CSI + "1G")
  end
  def clear_line_after # Erase from the current position (inclusive) to the end of the line
    print(CSI + '0K')
  end
  def scroll_down # Scroll display down one line
    print(ESC + 'D')
  end
  def clear_screen_down
    print(CSI + 'J')
  end
end

# INITIALIZATION
begin # Requires
  require 'etc'
  require 'io/console'
  require 'io/wait'
end
begin # Initialization
  # Theming
  @c_prompt    = 10                       # Color for basic prompt
  @c_cmd       = 2                        # Color for valid command
  @c_nick      = 6                        # Color for matching nick
  @c_gnick     = 14                       # Color for matching gnick
  @c_path      = 3                        # Color for valid path
  @c_switch    = 6                        # Color for switches/options
  @c_bookmark  = 13                       # Color for bookmarks
  @c_colon     = 4                        # Color for colon commands
  @c_tabselect = 5                        # Color for selected tabcompleted item
  @c_taboption = 244                      # Color for unselected tabcompleted item
  @c_stamp     = 244                      # Color for time stamp/command
  # Prompt
  @prompt      = "rsh > ".c(@c_prompt).b  # Very basic prompt if not defined in .rshrc
  # Hash & array initializations
  @nick        = {}                       # Initiate alias/nick hash
  @gnick       = {}                       # Initiate generic/global alias/nick hash
  @history     = []                       # Initiate history array
  @exe = []
  @exe_cache_time = 0                     # Cache timestamp for executables
  @exe_cache_paths = ""                   # Cached PATH value
  @cmd_frequency = {}                     # Track command usage frequency
  # Paths
  @user = Etc.getpwuid(Process.euid).name # For use in @prompt
  @path        = ENV["PATH"].split(":")   # Get paths
  # History
  @histsize    = 200                      # Max history if not set in .rshrc
  @hloaded     = false                    # Variable to determine if history is loaded
  # Use run-mailcap instead of xgd-open? Set "= true" in .rshrc if you want run-mailcap
  @runmailcap  = false
  # Variable initializations
  @dirs        = ["."]*10
  @jobs        = {}                       # Background jobs tracking
  @job_id      = 0                        # Job counter
  @ai_suggestion = nil                    # Store AI command suggestion
  @last_exit   = 0                        # Last command exit status
  # Command completions for subcommands
  @cmd_completions = {
    "git" => %w[add bisect branch checkout clone commit diff fetch grep init log merge mv pull push rebase reset restore rm show stash status switch tag],
    "apt" => %w[install remove update upgrade search show list autoremove purge],
    "apt-get" => %w[install remove update upgrade dist-upgrade autoremove purge clean autoclean],
    "docker" => %w[build run ps images pull push start stop restart rm rmi exec logs inspect network volume],
    "systemctl" => %w[start stop restart reload status enable disable is-active is-enabled list-units],
    "cargo" => %w[build run test check clean doc new init add search publish install update],
    "npm" => %w[install uninstall update run build test start init publish],
    "gem" => %w[install uninstall update list search build push],
    "bundle" => %w[install update exec check config]
  }
  # New v3.0 features initialization
  @switch_cache = {}                      # Cache for command switches from --help
  @switch_cache_time = {}                 # Timestamp for cache expiry
  @bookmarks = {}                         # Enhanced bookmarks with tags
  @defuns = {}                            # Store defun definitions for persistence
  @cmd_stats = {}                         # Command execution statistics
  @session_dir = Dir.home + '/.rsh/sessions' # Sessions directory
  @session_file = @session_dir + '/default.json' # Default session file
  @session_autosave = 0                   # Auto-save interval (0 = disabled)
  @session_last_save = Time.now.to_i      # Last auto-save timestamp
  @history_dedup = 'smart'                # History dedup mode: 'off', 'full', 'smart'
  @auto_correct = false                   # Auto-correct typos (default: off)
  @slow_command_threshold = 0             # Threshold for slow command alerts (0 = disabled)
  @plugin_dir = Dir.home + '/.rsh/plugins' # Plugins directory
  @plugins = []                           # Loaded plugin instances
  @plugin_disabled = []                   # List of disabled plugin names
  @plugin_commands = {}                   # Commands added by plugins
  # Built-in rsh commands are called with : prefix, so no need for separate tracking
  Dir.mkdir(Dir.home + '/.rsh') unless Dir.exist?(Dir.home + '/.rsh')
  Dir.mkdir(@session_dir) unless Dir.exist?(@session_dir)
  Dir.mkdir(@plugin_dir) unless Dir.exist?(@plugin_dir)
  def pre_cmd; end                        # User-defined function to be run BEFORE command execution
  def post_cmd; end                       # User-defined function to be run AFTER  command execution
end

# HELP TEXT
@info = <<~INFO

  Hello #{@user}, welcome to rsh v3.2 - the Ruby SHell.

  rsh does not attempt to compete with the grand old shells like bash and zsh.
  It serves the specific needs and wants of its author. If you like it, then feel free
  to ask for more or different features here: https://github.com/isene/rsh.

  Core Features:
  * Aliases (called nicks in rsh) - both for commands and general nicks
  * Syntax highlighting for nicks, bookmarks, commands, switches and valid dirs/files
  * Tab completions for nicks, system commands, command switches and dirs/files
  * Smart context-aware tab completion for git, apt, docker, systemctl, cargo, npm, gem, bundle
  * History with editing, search and repeat (use `!` or UP arrow)
  * Auto-suggestions from history (press RIGHT arrow to accept)
  * Ruby functions callable as shell commands (persistent across sessions)
  * AI integration: Use @ for text responses and @@ for command suggestions

  NEW in v3.0:
  * Command analytics - :stats shows usage patterns and performance metrics
  * Enhanced bookmarks with tags - :bm "name path #tag1,tag2" then just type name to jump
  * Session management - :save_session and :load_session preserve your entire shell state
  * Smart typo detection - "Did you mean...?" suggestions for misspelled commands
  * Switch caching - Faster TAB completion for command options
  * Option value completion - TAB complete values like --format=json
  * Syntax validation - Pre-execution warnings for dangerous or malformed commands
  * Unified command syntax - :nick, :gnick, :bm all work the same way (list/create/delete)

  NEW in v3.2:
  * Plugin system - Extensible architecture for custom commands, completions, and hooks
  * Lifecycle hooks - on_startup, on_command_before, on_command_after, on_prompt
  * Plugin management - :plugins list/reload/enable/disable/info
  * Example plugins - git_prompt, command_logger, kubectl_completion included
  * Auto-correct typos - :config "auto_correct" "on" automatically fixes gti â†’ closest match
  * Command timing alerts - :config "slow_command_threshold" "5" warns on slow commands
  * Inline calculator - :calc 2 + 2, :calc "Math.sqrt(16)", full Ruby Math library
  * Enhanced history - !!, !-2, !5:7 for repeat last, nth-to-last, and chaining
  * Stats visualization - :stats --graph for colorful ASCII bar charts
  * See PLUGIN_GUIDE.md for complete plugin development documentation

  v3.1 Features:
  * Multiple named sessions - :save_session "project" and :load_session "project"
  * Stats export - :stats --csv or :stats --json for data analysis
  * Session auto-save - Set @session_autosave = 300 in .rshrc for 5-min auto-save
  * Bookmark import/export - :bm --export file.json and :bm --import file.json
  * Bookmark statistics - :bm --stats shows usage patterns and tag distribution
  * Color themes - :theme solarized|dracula|gruvbox|nord|monokai
  * Config management - :config shows/sets history_dedup, session_autosave, etc.
  * Environment management - :env for listing/setting/exporting environment variables

  Config file (.rshrc) updates on exit (Ctrl-d) or not (Ctrl-e).
  All colors are themeable in .rshrc (see github link for possibilities).

  Use `:help` for complete command reference.

INFO

@help = <<~HELP

HELP

# GENERIC FUNCTIONS
def firstrun
  puts @info
  puts "Since there is no rsh configuration file (.rshrc), I will help you set it up to suit your needs.\n\n"
  puts "The prompt you see now is the very basic rsh prompt:"
  print "#{@prompt} (press ENTER)"
  $stdin.gets
  puts "\nI will now change the prompt into something more useful."
  puts "Feel free to amend the prompt in your .rshrc.\n\n"
  rc = <<~RSHRC
  # PROMPT
  # The numbers in parenthesis are 256 color codes (the '.c()' is a String extention
  # to color text in the terminal. Add '.b' for bold and '.i' for italics.
  @prompt = "\#{@user}@\#{@node}".c(46) + ":".c(255) + " \#{Dir.pwd}/".c(196) + " ".c(7)

  # THEME
  @c_prompt    = 196  # Color for basic prompt
  @c_cmd       = 48   # Color for valid command
  @c_nick      = 51   # Color for matching nick
  @c_gnick     = 87   # Color for matching gnick
  @c_path      = 208  # Color for valid path
  @c_switch    = 148  # Color for switches/options
  @c_bookmark  = 13   # Color for bookmarks
  @c_colon     = 4    # Color for colon commands
  @c_tabselect = 207  # Color for selected tabcompleted item
  @c_taboption = 244  # Color for unselected tabcompleted item
  @c_stamp     = 244  # Color for time stamp/command

  # TAB COMPLETION SETTINGS
  @completion_limit = 10              # Max completion items to show
  @completion_case_sensitive = false  # Case-insensitive completion
  @completion_show_descriptions = false # Show help text inline
  @completion_fuzzy = true            # Enable fuzzy matching

  @nick = {"ls"=>"ls --color -F"}
RSHRC
  File.write(Dir.home+'/.rshrc', rc)
end
def getchr # Process key presses
  c = $stdin.getch
  case c
  when "\e"    # ANSI escape sequences (with only ESC, it should stop right here)
    return "ESC" if $stdin.ready? == nil
    case $stdin.getc
    when '['   # CSI
      case $stdin.getc  # Will get (or ASK) for more (remaining part of special character)
      when 'A' then chr = "UP"
      when 'B' then chr = "DOWN"
      when 'C' then chr = "RIGHT"
      when 'D' then chr = "LEFT"
      when 'Z' then chr = "S-TAB"
      when '2' then chr = "INS"    ; chr = "C-INS"    if $stdin.getc == "^"
      when '3' then chr = "DEL"    ; chr = "C-DEL"    if $stdin.getc == "^"
      when '5' then chr = "PgUP"   ; chr = "C-PgUP"   if $stdin.getc == "^"
      when '6' then chr = "PgDOWN" ; chr = "C-PgDOWN" if $stdin.getc == "^"
      when '7' then chr = "HOME"   ; chr = "C-HOME"   if $stdin.getc == "^"
      when '8' then chr = "END"    ; chr = "C-END"    if $stdin.getc == "^"
      else chr = ""
      end
    when 'O'   # Set Ctrl+ArrowKey equal to ArrowKey; May be used for other purposes in the future
      case $stdin.getc
      when 'a' then chr = "C-UP"
      when 'b' then chr = "C-DOWN"
      when 'c' then chr = "C-RIGHT"
      when 'd' then chr = "C-LEFT"
      else chr = ""
      end
    end
  when "", "" then chr = "BACK"
  when "" then chr = "C-C"
  when "" then chr = "C-D"
  when "" then chr = "C-E"
  when "" then chr = "C-G"
  when "" then chr = "C-K"
  when "" then chr = "C-L"
  when "" then chr = "C-N"
  when "" then chr = "C-O"
  when "" then chr = "C-P"
  when "" then chr = "C-T"
  when "" then chr = "C-Y"
  when "" then chr = "WBACK"
  when "\u001A" then chr = "C-Z"
  when "" then chr = "LDEL"
  when "\r" then chr = "ENTER"
  when "\t" then chr = "TAB"
  when /[[:print:]]/  then chr = c
  else chr = ""
  end
  return chr
end
def getstr # A custom Readline-like function
  @stk  = 0
  @pos  = 0
  chr   = ""
  @history.unshift("")
  # Check if we have an AI suggestion to pre-fill
  if @ai_suggestion
    @history[0] = @ai_suggestion
    @pos = @ai_suggestion.length
    @ai_suggestion = nil
  end
  @row0, p = @c.pos
  while chr != "ENTER" # Keep going with readline until user presses ENTER
    @ci   = nil
    lift  = false
    right = false
    # The actual printing og the command line
    @c.row(@row0)
    @c.clear_line
    print @prompt
    @c.clear_screen_down
    row, @pos0 = @c.pos
    #@history[0] = "" if @history[0].nil?
    print cmd_check(@history[0])
    @ci  = @history[1..].find_index {|e| e =~ /^#{Regexp.escape(@history[0].to_s)}./}
    unless @ci == nil
      @ci += 1
      @ciprompt = @history[@ci][@history[0].to_s.length..].to_s
    end
    if @history[0].to_s.length > 1 and @ci
      print @ciprompt.c(@c_stamp)
      right = true
    end
    c_col = @pos0 + @pos
    c_row = @row0 + c_col/(@maxcol)
    c_col == 0 ? @c.row(c_row + 1) : @c.row(c_row)
    if c_col.modulo(@maxcol) == 0
      @c.col(c_col)
      @c.row(@c.rowget - 1)
    else
      @c.col(c_col.modulo(@maxcol))
    end
    chr = getchr
    puts "DEBUG: Got char: '#{chr}' (length: #{chr.length})" if ENV['RSH_DEBUG']
    case chr
    when 'C-G', 'C-C'
      @history[0] = "" 
      @pos = 0
    when 'C-E'   # Ctrl-C exits gracefully but without updating .rshrc
      print "\n"
      exit
    when 'C-D'   # Ctrl-D exits after updating .rshrc
      rshrc
      exit
    when 'C-L'   # Clear screen and set position to top of the screen
      @c.row(1)
      @row0 = 1
      @c.clear_screen_down
    when 'UP'    # Go up in history
      if @stk == 0 and @history[0].length > 0
        @tabsearch = @history[0]
        tab("hist")
      else
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        unless @stk >= @history.length - 1
          @stk += 1 
          @history[0] = @history[@stk].dup
          @history[0] = "" unless @history[0]
          @pos = @history[0].length
        end
        lift = false
      end
      @c.row(@row0)
      @c.clear_screen_down
    when 'DOWN'  # Go down in history
      if lift
        @history.unshift("")
        @history[0] = @history[@stk].dup
        @stk += 1 
      end
      if @stk == 0
        @history[0] = ""
        @pos = 0
      elsif @stk == 1
        @stk -= 1 
        @history[0] = ""
        @pos = 0
      else
        @stk -= 1 
        @history[0] = @history[@stk].dup
        @pos = @history[0].length
      end
      lift = false
      @c.row(@row0)
      @c.clear_screen_down
    when 'RIGHT' # Move right on the readline
      if right 
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        @history[0] = @history[@ci].dup
        @pos = @history[0].length
      end
      @pos += 1 unless @pos >= @history[0].length
    when 'LEFT'  # Move left on the readline
      @pos -= 1 unless @pos <= 0
    when 'HOME'  # Go to beginning of the readline
      @pos = 0
    when 'END'   # Go to the end of the readline
      @pos = @history[0].length
    when 'DEL'   # Delete one character
      @history[0][@pos] = ""
      lift = true
    when 'BACK'  # Delete one character to the left
      unless @pos <= 0
        @pos -= 1
        @history[0][@pos] = ""
      end
      lift = true
      @c.clear_line_after
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      unless @pos == @pos0
        until @history[0][@pos - 1] == " " or @pos == 0
          @pos -= 1
          @history[0][@pos] = ""
        end
        if @history[0][@pos - 1] == " "
          @pos -= 1
          @history[0][@pos] = ""
        end
      end
      lift = true
      @c.clear_line_after
    when 'C-Y'   # Copy command line to primary selection
      system("echo -n '#{@history[0]}' | xclip")
      puts "\n#{Time.now.strftime("%H:%M:%S")}: Copied to primary selection (paste with middle buttoni)".c(@c_stamp)
    when 'C-Z'   # Suspend current process (background job)
      if @current_pid
        puts "\n[#{@job_id}] Suspended #{@current_pid}"
        Process.kill("STOP", @current_pid)
        @jobs[@job_id] = {pid: @current_pid, cmd: @cmd, status: :stopped}
      else
        puts "\nNo active job to suspend"
      end
    when 'C-K'   # Kill/delete that entry in the history
      @history.delete_at(@stk)
      @stk -= 1
      if @stk == 0
        @history[0] = "" 
        @pos = 0
      else
        @history[0] = @history[@stk].dup
        @history[0] = "" unless @history[0]
        @pos = @history[0].length
      end
    when 'LDEL'  # Delete readline (Ctrl-U)
      @history[0] = ""
      @pos = 0
      lift = true
    when 'TAB'   # Tab completion of dirs and files
      puts "\n=== TAB KEY DETECTED ===" if ENV['RSH_DEBUG']
      puts "Current line: '#{@history[0]}'" if ENV['RSH_DEBUG']
      puts "Cursor pos: #{@pos}" if ENV['RSH_DEBUG']
      puts "======================" if ENV['RSH_DEBUG']
      @ci = nil
      #@tabsearch =~ /^-/ ? tabbing("switch") : tabbing("all")
      tab("all")
      lift = true
    when 'S-TAB'
      @ci = nil
      tabbing("hist")
      lift = true
    when /^.$/
      @history[0].insert(@pos,chr)
      @pos += 1
      lift = true
    end
    while $stdin.ready?
      chr = $stdin.getc
      @history[0].insert(@pos,chr)
      @pos += 1
    end
  end
  @c.clear_screen_down
end
def tab(type)
  i = 0
  chr = ""
  @tabarray = []

  @pretab   = @history[0][0...@pos].to_s        # Extract the current line up to cursor
  @postab   = @history[0][@pos..].to_s          # Extract the current line from cursor to end
  @c_row, @c_col = @c.pos                       # Get cursor position
  @row0     = @c_row                            # Save original row
  # Special handling for environment variables first
  if @pretab =~ /\$\w*$/
    @tabstr = @pretab.match(/\$\w*$/)[0]
    @pretab = @pretab.sub(/\$\w*$/, '')
  else
    @tabstr   = @pretab.split(/[|;&, ]/).last.to_s  # Get the sustring that is being tab completed
    @tabstr   = "" if @pretab[-1] =~ /[ |;&]/       # Tab from nothing if tabbing starts with space, pipe, etc.
    @tabstr   = @pretab if type == "hist"         # Searching for matches with whole string in history
    @pretab   = @pretab.delete_suffix(@tabstr)
  end
  type = "switch" if @tabstr && @tabstr[0] == "-" && !@tabstr.include?("=")
  type = "option_value" if @tabstr && @tabstr =~ /^--?[\w-]+=/
  type = "env_vars" if @tabstr && @tabstr[0] == "$"
  type = "colon_commands" if @tabstr && @tabstr[0] == ":"

  # Debug output when RSH_DEBUG is set
  if ENV['RSH_DEBUG']
    puts "\n=== TAB DEBUG ==="
    puts "Input type: #{type}"
    puts "@pretab: '#{@pretab}'"
    puts "@tabstr: '#{@tabstr}'"
    puts "Length: #{@tabstr.length}"
    puts "First char: '#{@tabstr[0] if @tabstr}'"
    puts "=================="
  end

  # Smart context-aware completion
  unless type == "switch" || type == "hist"
    if @pretab && !@pretab.empty?
      cmd_parts = @pretab.strip.split(/[|;&]/).last.strip.split
      last_cmd = cmd_parts.first if cmd_parts.any?
    else
      cmd_parts = []
      last_cmd = nil
    end

    case last_cmd
    when "cd", "pushd", "rmdir"
      type = "dirs_only"
    when "vim", "nano", "cat", "less", "more", "head", "tail", "file"
      type = "files_only"
    when "man", "info", "which", "whatis"
      type = "commands_only"
    when "export", "unset"
      type = "env_vars"
    else
      # Check if command has defined completions and we're on the first argument
      if @cmd_completions.key?(last_cmd) && cmd_parts.length == 1
        type = "cmd_subcommands"
        @current_cmd = last_cmd
      end
    end
  end

  while chr != "ENTER"
    case type
    when "hist"         # Handle history completions ('UP' key)
      @tabarray = @history.select {|el| el =~ /#{@tabstr}/} # Select history items matching @tabstr
      @tabarray.shift   # Take away @history[0]
      return if @tabarray.empty?
    when "switch"
      cmdswitch = @pretab.split(/[|, ]/).last.to_s.strip
      @tabarray = get_command_switches(cmdswitch)
    when "option_value"  # Completion for option values like --format=<value>
      if @tabstr =~ /^--?[\w-]+=(.*)/
        value_prefix = $1
        option = @tabstr.sub(/=.*/, '')
        # Define common option value completions
        value_completions = {
          /format/ => %w[json yaml xml csv plain],
          /output/ => %w[json yaml xml text html],
          /level|log-level/ => %w[debug info warn error fatal],
          /color/ => %w[auto always never],
          /type/ => %w[file dir link all]
        }
        matches = []
        value_completions.each do |pattern, values|
          if option =~ pattern
            matches = values.select { |v| v.start_with?(value_prefix) }
            break unless matches.empty?
          end
        end
        @tabarray = matches.map { |v| "#{option}=#{v}" }
      end
    when "dirs_only"    # Only show directories
      fdir = @tabstr + "*"
      dirs = Dir.glob(fdir).select { |d| Dir.exist?(d) }.map { |d| d + "/" }
      @tabarray = dirs
    when "files_only"   # Only show files, not directories
      fdir = @tabstr + "*"
      files = Dir.glob(fdir).reject { |f| Dir.exist?(f) }
      @tabarray = files
    when "commands_only" # Only show executable commands
      ex = @exe.dup
      ex.prepend(*@nick.keys, *@gnick.keys)
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = ex.select { |s| s =~ Regexp.new(@tabstr, regex_flags) }
    when "cmd_subcommands" # Command-specific subcommands (git, apt, docker, etc.)
      subcommands = @cmd_completions[@current_cmd] || []
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = subcommands.select { |cmd| cmd =~ Regexp.new(@tabstr, regex_flags) }
    when "env_vars"     # Environment variables
      env_vars = ENV.keys.map { |k| "$#{k}" }
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = env_vars.select { |var| var =~ Regexp.new(@tabstr, regex_flags) }
    when "colon_commands"  # Ruby/rsh commands starting with :
      colon_cmds = %w[
        :nick :gnick :bm :bookmark :stats :defun :defun?
        :history :rmhistory :jobs :fg :bg
        :save_session :load_session :list_sessions :delete_session :rmsession
        :config :env :theme :plugins :calc
        :info :version :help
      ]
      search_str = @tabstr[1..-1] || ""  # Remove leading :
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      matches = colon_cmds.select { |cmd| cmd[1..-1] =~ Regexp.new("^#{search_str}", regex_flags) }
      @tabarray = matches
    when "all"          # Handle all other tab completions
      ex  = []
      ex += @exe
      ex.sort!
      ex.prepend(*@nick.keys)        # Add nicks
      ex.prepend(*@gnick.keys)       # Add gnicks
      ex.prepend(*@bookmarks.keys) if @bookmarks  # Add bookmarks

      # Enhanced matching with case sensitivity and fuzzy support
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE

      # Try multiple matching strategies
      compl = []

      # First try exact prefix matching
      compl = ex.select { |s| s =~ Regexp.new("^#{@tabstr}", regex_flags) }

      # If no results and fuzzy enabled, try fuzzy matching
      if compl.empty? && @completion_fuzzy && @tabstr.length > 1
        # Fuzzy matching: match from start with characters in order
        fuzzy_pattern = "^#{@tabstr.chars.join('.*')}"
        compl = ex.select { |s| s =~ Regexp.new(fuzzy_pattern, regex_flags) }
      end

      # If still no results, try substring matching
      if compl.empty?
        compl = ex.select { |s| s =~ Regexp.new(@tabstr, regex_flags) }
      end

      # Sort by frequency (most used first), then alphabetically
      compl.sort! do |a, b|
        freq_a = @cmd_frequency[a] || 0
        freq_b = @cmd_frequency[b] || 0
        if freq_a == freq_b
          a <=> b
        else
          freq_b <=> freq_a
        end
      end

      # File completion with hidden file handling
      fdir = @tabstr + "*"
      files = Dir.glob(fdir)

      # Only show hidden files if tabstr starts with .
      unless @tabstr.start_with?('.')
        files.reject! { |f| File.basename(f).start_with?('.') }
      end

      files.map! do |e|
        if e =~ /(?<!\\) /
          e = e.sub(/(.*\/|^)(.*)/, '\1\'\2\'') unless e =~ /'/
        end
        Dir.exist?(e) ? e + "/" : e   # Add matching dirs
      end

      # Separate directories and files for better ordering
      dirs = files.select { |f| f.end_with?('/') }
      files_only = files.reject { |f| f.end_with?('/') }

      # Order: directories first, then files, then commands
      @tabarray = dirs + files_only + compl

      # Debug completion results
      if ENV['RSH_DEBUG']
        puts "=== COMPLETION RESULTS ==="
        puts "Type: #{type}"
        puts "Total matches: #{@tabarray.length}"
        puts "First 5: #{@tabarray.first(5).inspect}"
        puts "=========================="
      end
    end
    return if @tabarray.empty?
    @tabarray.delete("")                                      # Don't remember why
    @c.clear_screen_down                                      # Here we go
    max_items = @completion_limit || 5
    @tabarray.length.to_i - i < max_items ? l = @tabarray.length.to_i - i : l = max_items
    l.times do |x|                                            # Iterate through
      if x == 0                                               # First item goes onto the commandline
        @c.clear_line                                         # Clear the line
        tabchoice = @tabarray[i]                              # Select the item from the @tabarray
        tabchoice = tabchoice.sub(/\s*(-.*?)[,\s].*/, '\1') if type == "switch"
        @newhist0 = @pretab + tabchoice + @postab             # Remember now the new value to be given to @history[0]
        line1     = cmd_check(@pretab).to_s                   # Syntax highlight before @tabstr
        line2     = cmd_check(@postab).to_s                   # Syntax highlight after  @tabstr
        # Color and underline the current tabchoice on the commandline:
        tabline   = tabchoice.sub(/(.*)#{@tabstr}(.*)/, '\1'.c(@c_tabselect) + @tabstr.u.c(@c_tabselect) + '\2'.c(@c_tabselect))
        print @prompt + line1 + tabline + line2               # Print the commandline
        @pos   = @pretab.length.to_i + tabchoice.length.to_i  # Set the position on that commandline
        @c_col = @pos0 + @pos                                 # The cursor position must include the prompt as well
        @c.col(@c_col)                                        # Set the cursor position
        nextline                                              # Then start showing the completion items
        tabline  = @tabarray[i]                               # Get the next matching tabline
        # Can't nest ANSI codes, they must each complete/conclude or they will mess eachother up
        if tabline.include?(@tabstr)
          tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_tabselect) # Color the part before the @tabstr
          tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_tabselect) # Color the part after the @tabstr
          print " " + tabline1 + @tabstr.c(@c_tabselect).u + tabline2       # Color & underline @tabstr
        else
          # For fuzzy matches, just show the whole word highlighted
          print " " + tabline.c(@c_tabselect)
        end
      else
        begin
          tabline = @tabarray[i+x]    # Next tabline, and next, etc (usually 4 times here)
          if tabline.include?(@tabstr)
            tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_taboption) # Color before @tabstr
            tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_taboption) # Color after @tabstr
            print " " + tabline1 + @tabstr.c(@c_taboption).u + tabline2       # Print the whole line
          else
            # For fuzzy matches, just show the whole word
            print " " + tabline.c(@c_taboption)
          end
        rescue => e
          # Log completion errors if debugging enabled
          File.write("/tmp/rsh_completion.log", "#{Time.now}: Completion error - #{e}\n", mode: 'a') if ENV['RSH_DEBUG']
        end
      end
      nextline      # To not run off screen
    end
    @c.row(@c_row)  # Set cursor row to commandline
    @c.col(@c_col)  # Set cursor col on commandline 
    chr = getchr    # Now get user input
    case chr        # Treat the keypress
    when 'C-G', 'C-C', 'ESC'
      tabend; return
    when 'DOWN'
      i += 1 unless i > @tabarray.length.to_i - 2
    when 'UP'
      i -= 1 unless i == 0
    when 'TAB', 'RIGHT'  # Effectively the same as ENTER 
      chr = "ENTER"
    when 'BACK', 'LEFT'  # Delete one character to the left
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.chop!
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.sub!(/#{@tabstr.split(/[|, ]/).last}.*/, '')
    when ' '
      @tabstr += " "
      chr = "ENTER"
    when /^[[:print:]]$/
      @tabstr += chr
      i = 0
    end
  end
  @c.clear_screen_down
  @row0 = @c_row
  @c.row(@c_row)
  @c.col(@c_col)
  @history[0] = @newhist0
end
def nextline # Handle going to the next line in the terminal
  row, col = @c.pos
  if row == @maxrow
    @c.scroll_down
    @c_row -= 1
  end
  @c.next_line
end
def tabend
  @c.clear_screen_down
  @pos = @history[0].length
  @c_col = @pos0 + @pos
  @c.col(@c_col)
end
def get_command_switches(command) # Helper function to extract switches from --help
  # Check cache first (cache expires after 1 hour)
  cache_key = command.to_s.strip
  return [] if cache_key.empty?

  current_time = Time.now.to_i
  if @switch_cache[cache_key] && @switch_cache_time[cache_key] && (current_time - @switch_cache_time[cache_key]) < 3600
    return @switch_cache[cache_key]
  end

  # Parse --help output
  hlp = `#{command} --help 2>/dev/null`
  # Try -h if --help didn't work
  hlp = `#{command} -h 2>/dev/null` if hlp.empty?
  return [] if hlp.empty?

  switches = []

  # Method 1: Lines starting with switches (traditional format)
  switches = hlp.split("\n").grep(/^\s*-{1,2}[^-]/)
  switches.map! { |h| h.sub(/^\s*/, '').sub(/^--/, '    --') }
  switches.reject! { |h| /-</ =~ h }

  # Method 2: Extract switches from usage line (git-style format)
  if switches.empty?
    usage_lines = hlp.split("\n").select { |l| l =~ /usage:|Usage:/ }
    usage_lines.each do |line|
      # Extract all switches from the usage line
      line.scan(/(-[a-zA-Z]|--[a-z-]+)/).each do |match|
        switch = match[0]
        switches << (switch.start_with?('--') ? "    #{switch}" : switch)
      end
    end
    switches.uniq!
  end

  # Cache the result (even if empty, to avoid repeated failures)
  @switch_cache[cache_key] = switches
  @switch_cache_time[cache_key] = current_time

  switches
end
def levenshtein_distance(s, t) # Calculate edit distance for smart suggestions
  m = s.length
  n = t.length
  return m if n == 0
  return n if m == 0
  d = Array.new(m+1) {Array.new(n+1)}
  (0..m).each {|i| d[i][0] = i}
  (0..n).each {|j| d[0][j] = j}
  (1..n).each do |j|
    (1..m).each do |i|
      d[i][j] = if s[i-1] == t[j-1]
        d[i-1][j-1]
      else
        [d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]+1].min
      end
    end
  end
  d[m][n]
end
def suggest_command(cmd) # Smart command suggestions for typos
  return nil if cmd.nil? || cmd.empty?
  return nil if @exe.include?(cmd) || @nick.include?(cmd)

  # Find commands with small edit distance
  candidates = (@exe + @nick.keys).select do |c|
    next false if c.length < 2
    dist = levenshtein_distance(cmd, c)
    max_dist = [cmd.length / 3, 2].max
    dist <= max_dist && dist > 0
  end

  return nil if candidates.empty?

  # Sort by distance
  candidates.sort_by! { |c| levenshtein_distance(cmd, c) }
  candidates.first(3)
end
def hist_clean # Clean up @history
  @history.compact!
  @history.delete("")

  # Apply deduplication based on mode
  case @history_dedup
  when 'off'
    # No deduplication
  when 'full', 'smart'
    # Remove duplicates, keeping first (most recent) occurrence
    @history.uniq!
  else
    # Default to smart
    @history.uniq!
  end
end
def config(*args) # Configure rsh settings
  setting = args[0]
  value = args[1]

  if setting.nil?
    # Show current configuration
    puts "\n  Current Configuration:".c(@c_prompt).b
    puts "    history_dedup:      #{@history_dedup}"
    puts "    session_autosave:   #{@session_autosave}s #{@session_autosave > 0 ? '(enabled)' : '(disabled)'}"
    puts "    auto_correct:       #{@auto_correct ? 'on' : 'off'}"
    puts "    slow_command_threshold: #{@slow_command_threshold}s #{@slow_command_threshold > 0 ? '(enabled)' : '(disabled)'}"
    puts "    completion_limit:   #{@completion_limit}"
    puts "    completion_fuzzy:   #{@completion_fuzzy}"
    puts "    completion_case_sensitive: #{@completion_case_sensitive}"
    puts
    return
  end

  case setting
  when 'history_dedup'
    if %w[off full smart].include?(value)
      @history_dedup = value
      puts "History deduplication set to '#{value}'"
      rshrc
    else
      puts "Invalid value. Use: off, full, or smart"
    end
  when 'session_autosave'
    @session_autosave = value.to_i
    puts "Session auto-save set to #{value}s #{value.to_i > 0 ? '(enabled)' : '(disabled)'}"
    rshrc
  when 'auto_correct'
    @auto_correct = %w[on true yes 1].include?(value.to_s.downcase)
    puts "Auto-correct #{@auto_correct ? 'enabled' : 'disabled'}"
    rshrc
  when 'slow_command_threshold'
    @slow_command_threshold = value.to_i
    puts "Slow command threshold set to #{value}s #{value.to_i > 0 ? '(enabled)' : '(disabled)'}"
    rshrc
  when 'completion_limit'
    @completion_limit = value.to_i
    puts "Completion limit set to #{value}"
    rshrc
  else
    puts "Unknown setting '#{setting}'"
    puts "Available: history_dedup, session_autosave, auto_correct, slow_command_threshold, completion_limit"
  end
end
def env(*args) # Environment variable management
  arg_str = args.join(' ')

  if args.empty?
    # List all environment variables
    puts "\n  Environment Variables:".c(@c_prompt).b
    ENV.sort.first(20).each do |key, value|
      value_display = value.length > 50 ? value[0..47] + '...' : value
      puts "    #{key.c(@c_gnick).ljust(25)} = #{value_display}"
    end
    puts "    ... (#{ENV.length} total, showing first 20)"
    puts "\n  Use :env \"VARNAME\" to see specific variable"
    puts
  elsif arg_str =~ /^set\s+(\w+)\s+(.+)$/
    # Set environment variable
    var_name, var_value = $1, $2
    ENV[var_name] = var_value
    puts "#{var_name} = #{var_value}"
  elsif arg_str =~ /^unset\s+(\w+)$/
    # Unset environment variable
    var_name = $1
    ENV.delete(var_name)
    puts "#{var_name} unset"
  elsif arg_str =~ /^export\s+(.+)$/
    # Export to shell script
    filename = $1
    File.write(filename, ENV.map { |k,v| "export #{k}=\"#{v}\"" }.join("\n"))
    puts "Environment exported to #{filename}"
  else
    # Show specific variable
    var_name = arg_str.strip
    if ENV[var_name]
      puts "#{var_name} = #{ENV[var_name]}"
    else
      puts "Environment variable '#{var_name}' not set"
    end
  end
end
def cmd_check(str) # Check if each element on the readline matches commands, nicks, paths; color them
  return if str.nil?

  # Special handling for @ and @@ commands
  if str =~ /^(@@?)\s+(.*)$/
    prefix = $1
    rest = $2
    return prefix.c(@c_colon) + " " + rest  # Color @ or @@ in colon color
  end

  # Special handling for : commands
  if str =~ /^(:[\w?_]+)/
    colon_cmd = $1
    rest = str.sub(/^:[\w?_]+/, '')
    return colon_cmd.c(@c_colon) + rest  # Color colon commands
  end

  str.gsub(/(?:\S'[^']*'|[^ '])+/) do |el|
    clean_el = el.gsub("'", "")
    # Priority: commands > nicks > bookmarks > paths
    if @exe.include?(el)
      el.c(@c_cmd)
    elsif el == "cd"
      el.c(@c_cmd)
    elsif clean_el =~ /^\.\/(.+)/ && File.exist?(clean_el) && File.executable?(clean_el)
      # Color local executables starting with ./
      el.c(@c_cmd)
    elsif @nick.include?(el)
      el.c(@c_nick)
    elsif el == "r" or el == "f"
      el.c(@c_nick)
    elsif @gnick.include?(el)
      el.c(@c_gnick)
    elsif self.respond_to?(el) && singleton_class.instance_methods(false).include?(el.to_sym)
      el.c(@c_nick).b  # Ruby functions in bold nick color
    elsif @bookmarks && @bookmarks.include?(el)
      # Color bookmarks (after commands and nicks)
      el.c(@c_bookmark)
    elsif File.exist?(clean_el)
      el.c(@c_path)
    elsif el[0] == "-"
      el.c(@c_switch)
    else
      el
    end
  end
end
def rshrc # Write updates to .rshrc
  hist_clean
  if File.exist?(Dir.home+'/.rshrc')
    conf = File.read(Dir.home+'/.rshrc')
  else
    conf = ""
  end
  conf.sub!(/^@nick.*(\n|$)/, "")
  conf += "@nick = #{@nick}\n"
  conf.sub!(/^@gnick.*(\n|$)/, "")
  conf += "@gnick = #{@gnick}\n"
  conf.sub!(/^@cmd_frequency.*(\n|$)/, "")
  conf += "@cmd_frequency = #{@cmd_frequency}\n"
  conf.sub!(/^@cmd_stats.*(\n|$)/, "")
  conf += "@cmd_stats = #{@cmd_stats}\n" unless @cmd_stats.empty?
  conf.sub!(/^@bookmarks.*(\n|$)/, "")
  conf += "@bookmarks = #{@bookmarks}\n" unless @bookmarks.empty?
  conf.sub!(/^@defuns.*(\n|$)/, "")
  conf += "@defuns = #{@defuns}\n" unless @defuns.empty?
  conf.sub!(/^@history_dedup.*(\n|$)/, "")
  conf += "@history_dedup = '#{@history_dedup}'\n" if @history_dedup && @history_dedup != 'smart'
  conf.sub!(/^@session_autosave.*(\n|$)/, "")
  conf += "@session_autosave = #{@session_autosave}\n" if @session_autosave && @session_autosave > 0
  conf.sub!(/^@auto_correct.*(\n|$)/, "")
  conf += "@auto_correct = #{@auto_correct}\n" if @auto_correct
  conf.sub!(/^@slow_command_threshold.*(\n|$)/, "")
  conf += "@slow_command_threshold = #{@slow_command_threshold}\n" if @slow_command_threshold && @slow_command_threshold > 0
  conf.sub!(/^@plugin_disabled.*(\n|$)/, "")
  conf += "@plugin_disabled = #{@plugin_disabled}\n" unless @plugin_disabled.empty?
  # Only write @cmd_completions if user has customized it
  unless conf =~ /^@cmd_completions\s*=/
    # Don't write default completions to avoid cluttering .rshrc
  end
  conf.sub!(/^@history.*(\n|$)/, "")
  # Ensure history is properly formatted as valid Ruby array
  begin
    history_str = @history.last(@histsize).inspect
    conf += "@history = #{history_str}\n"
  rescue => e
    conf += "@history = []\n"
    puts "Warning: Error saving history: #{e.message}"
  end
  File.write(Dir.home+'/.rshrc', conf)
  puts "\n.rshrc updated"
end

# RSH FUNCTIONS
def help
  # Get terminal width
  term_width = @maxcol || 80
  col_width = 48  # Fixed width for left column
  
  # Helper function to strip ANSI codes for length calculation
  def strip_ansi(str)
    str.gsub(/\001?\e\[[0-9;]*m\002?/, '')
  end
  
  left_col = []
  right_col = []
  
  # Left column content
  left_col << "KEYBOARD SHORTCUTS:".c(@c_prompt).b
  left_col << "RIGHT/Ctrl-F    Accept suggestion"
  left_col << "UP/DOWN         Navigate history"
  left_col << "TAB             Tab complete"
  left_col << "Shift-TAB       Search history"
  left_col << "Ctrl-Y          Copy to clipboard"
  left_col << "Ctrl-D          Exit + save .rshrc"
  left_col << "Ctrl-E          Exit without save"
  left_col << "Ctrl-L          Clear screen"
  left_col << "Ctrl-Z          Suspend job"
  left_col << "Ctrl-C/G        Clear line"
  left_col << "Ctrl-K          Delete history item"
  left_col << "Ctrl-U          Clear line"
  left_col << "Ctrl-W          Delete previous word"
  left_col << ""
  left_col << "SPECIAL COMMANDS:".c(@c_prompt).b
  left_col << ":nick 'll = ls -l'  Command alias"
  left_col << ":gnick 'h = /home'  General alias"
  left_col << ":nick               List nicks"
  left_col << ":gnick              List gnicks"
  left_col << ":nick '-name'       Delete nick"
  left_col << ":gnick '-name'      Delete gnick"
  left_col << ":history            Show history"
  left_col << ":rmhistory          Clear history"
  left_col << ":info               About rsh"
  left_col << ":version            Version info"
  left_col << ":help               This help"
  
  # Right column content
  right_col << "RUBY FUNCTIONS:".c(@c_prompt).b
  right_col << ":defun 'f(x) = x*2' Define function"
  right_col << ":defun?             List functions"
  right_col << ":defun '-f'         Remove function"
  right_col << "Call as: f 5        (returns 10)"
  right_col << ""
  right_col << "JOB CONTROL:".c(@c_prompt).b
  right_col << "command &           Background job"
  right_col << ":jobs               List jobs"
  right_col << ":fg [id]            Foreground job"
  right_col << ":bg [id]            Resume in bg"
  right_col << ""
  right_col << "v3.2 NEW FEATURES:".c(@c_prompt).b
  right_col << ":plugins [cmd]      Plugin system"
  right_col << ":stats --graph      Visual bar charts"
  right_col << ":calc 2 + 2         Ruby calculator"
  right_col << "!!, !-2, !5:7       History repeat/chain"
  right_col << ":config auto_correct Auto-fix (w/confirm)"
  right_col << ":config slow_cmd... Slow alerts"
  right_col << ""
  right_col << "PLUGIN SYSTEM:".c(@c_prompt).b
  right_col << ":plugins            List all"
  right_col << ":plugins reload     Reload"
  right_col << ":plugins disable nm Disable"
  right_col << ":plugins info nm    Details"
  right_col << ""
  right_col << "v3.0/3.1 FEATURES:".c(@c_prompt).b
  right_col << ":stats --clear      Clear stats"
  right_col << ":stats --csv|--json Export stats"
  right_col << ":bm \"name\"          Bookmarks"
  right_col << ":save_session [nm]  Sessions"
  right_col << ":theme [name]       Themes"
  right_col << ":config [set val]   Config"
  right_col << ":env [VAR]          Env vars"
  right_col << ""
  right_col << "INTEGRATIONS:".c(@c_prompt).b
  right_col << "r                   Launch rtfm"
  right_col << "f                   Launch fzf"
  right_col << "= <expr>            xrpn calculator"
  right_col << ":<ruby code>        Execute Ruby"
  right_col << ""
  right_col << "AI FEATURES:".c(@c_prompt).b
  right_col << "@ <question>        AI text response"
  right_col << "@@ <request>        AI command â†’ prompt"
  right_col << ""
  right_col << "SMART COMPLETIONS:".c(@c_prompt).b
  right_col << "git <TAB>           Git subcommands"
  right_col << "apt/docker <TAB>    Command options"
  right_col << "--format=<TAB>      Option values"
  right_col << "Typo suggestions    Auto-correct"
  right_col << ""
  right_col << "EXPANSIONS:".c(@c_prompt).b
  right_col << "~                   Home directory"
  right_col << "$VAR, ${VAR}        Environment var"
  right_col << "$?                  Exit status"
  right_col << "$(cmd), `cmd`       Command subst"
  right_col << "{a,b,c}             Brace expansion"
  right_col << "cmd1 && cmd2        Conditional"
  right_col << "cmd1 || cmd2        Alternative"
  
  # Pad columns to same length
  max_lines = [left_col.length, right_col.length].max
  left_col.fill("", left_col.length...max_lines)
  right_col.fill("", right_col.length...max_lines)
  
  # Print in two columns
  puts
  max_lines.times do |i|
    left_text = left_col[i].to_s
    right_text = right_col[i].to_s
    # Calculate padding based on visible characters (without ANSI codes)
    visible_length = strip_ansi(left_text).length
    padding = col_width - visible_length
    padding = 0 if padding < 0
    puts "  #{left_text}#{' ' * padding} #{right_text}"
  end
  puts
end
def info
  puts @info
end
def version
  puts "rsh version = #{@version} (latest RubyGems version is #{Gem.latest_version_for("ruby-shell").version} - https://github.com/isene/rsh)"
end
def history # Show most recent history (up to 50 entries)
  puts "History:"
  @history.each_with_index {|h,i| puts i.to_s + "; " + h if i < 50}
end
def rmhistory # Delete history
  @history = []
  puts "History deleted."
end
def nick(nick_str = nil)  # Define a new nick like this: `:nick "ls = ls --color"`
  if nick_str.nil? || nick_str.empty?
    # List all nicks
    puts "\n  Command nicks:".c(@c_nick).b
    if @nick.empty?
      puts "  (none defined)"
    else
      @nick.sort.each {|key, value| puts "  #{key.c(@c_nick)} = #{value}"}
    end
    puts
  elsif nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @nick.delete(source)
    rshrc
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @nick[source] = target
    rshrc
  end
end
def gnick(nick_str = nil) # Define a generic/global nick to match not only commands (format like nick)
  if nick_str.nil? || nick_str.empty?
    # List all gnicks
    puts "\n  General nicks:".c(@c_gnick).b
    if @gnick.empty?
      puts "  (none defined)"
    else
      @gnick.sort.each {|key, value| puts "  #{key.c(@c_gnick)} = #{value}"}
    end
    puts
  elsif nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @gnick.delete(source)
    rshrc
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @gnick[source] = target
    rshrc
  end
end
def dirs
  puts "Past direactories:"
  @dirs.each_with_index do |e,i|
    puts "#{i}: #{e}"
  end
end
def jobs
  puts "Active jobs:"
  @jobs.each do |id, job|
    begin
      Process.kill(0, job[:pid])  # Check if process exists
      puts "[#{id}] #{job[:pid]} #{job[:status]} #{job[:cmd]}"
    rescue Errno::ESRCH
      @jobs.delete(id)  # Clean up dead jobs
    end
  end
end
def fg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  puts "Bringing job #{job_id} to foreground: #{job[:cmd]}"
  begin
    if job[:status] == :stopped
      Process.kill("CONT", job[:pid])
    end
    @current_pid = job[:pid]
    Process.wait(job[:pid])
    @jobs.delete(job_id)
    @current_pid = nil
  rescue Errno::ECHILD, Errno::ESRCH
    @jobs.delete(job_id)
    @current_pid = nil
  end
end
def bg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  return puts "Job #{job_id} already running" if job[:status] == :running
  puts "Resuming job #{job_id} in background: #{job[:cmd]}"
  begin
    Process.kill("CONT", job[:pid])
    @jobs[job_id][:status] = :running
  rescue Errno::ESRCH
    @jobs.delete(job_id)
    puts "Job #{job_id} no longer exists"
  end
end
def defun(func_def)  # Define a Ruby function like: `:defun "myls(*args) = Dir.glob('*').each {|f| puts f}"`
  if func_def.match(/^\s*-/)
    # Remove function
    func_name = func_def.sub(/^\s*-/, '')
    if self.respond_to?(func_name)
      singleton_class.remove_method(func_name.to_sym)
      @defuns.delete(func_name)
      puts "Function '#{func_name}' removed"
    else
      puts "Function '#{func_name}' not found"
    end
  else
    # Define function
    # Extract function name, params, and body from "name(params) = body" format
    if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
      func_name = $1
      func_params = $2
      func_body = $3

      begin
        eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
        puts "  DEBUG: Evaluating: #{eval_code}" if ENV['RSH_DEBUG']
        singleton_class.class_eval(eval_code)
        @defuns[func_name] = func_def  # Store for persistence
        puts "Function '#{func_name}' defined"
        puts "  DEBUG: Method created? #{respond_to?(func_name)}" if ENV['RSH_DEBUG']
      rescue SyntaxError => e
        puts "Syntax error in function definition: #{e}"
      rescue => e
        puts "Error in function definition: #{e}"
      end
    else
      puts "Invalid function format. Use: name(params) = body"
    end
  end
  rshrc
end
def defun?  # Show all user-defined functions
  puts "User-defined Ruby functions:"
  # Get only methods defined by defun, excluding built-ins and rsh internals
  all_methods = singleton_class.instance_methods(false)
  puts "  All singleton methods: #{all_methods}"
  excluded = [:defun, :defun?, :execute_conditional, :expand_braces]
  methods = all_methods - excluded
  if methods.empty?
    puts "  (none defined after filtering)"
  else
    methods.each do |method|
      puts "  #{method}"
    end
  end
end
def stats(*args) # Show command execution statistics and analytics
  format = args[0]
  filename = args[1]

  if format == "--export"
    # Export to file
    fname = filename || "rsh_stats.json"
    export_stats(fname)
    return
  elsif format == "--json"
    fname = filename || "rsh_stats.json"
    export_stats_json(fname)
    return
  elsif format == "--csv"
    fname = filename || "rsh_stats.csv"
    export_stats_csv(fname)
    return
  elsif format == "--graph"
    stats_graph
    return
  elsif format == "--clear"
    # Clear all statistics
    @cmd_frequency = {}
    @cmd_stats = {}
    puts "All statistics cleared"
    rshrc
    return
  end

  # Display stats (existing code)
  puts "\n  Command Execution Statistics".c(@c_prompt).b
  puts "  " + "="*50

  # Most used commands
  if @cmd_frequency && !@cmd_frequency.empty?
    puts "\n  Top 10 Most Used Commands:".c(@c_nick)
    sorted = @cmd_frequency.sort_by { |_, count| -count }.first(10)
    sorted.each_with_index do |(cmd, count), i|
      bar = "â– " * ([count / 5, 20].min)
      puts "  #{(i+1).to_s.rjust(2)}. #{cmd.ljust(20)} #{count.to_s.rjust(5)}x #{bar.c(@c_path)}"
    end
  end

  # Command statistics from @cmd_stats
  if @cmd_stats && !@cmd_stats.empty?
    total_time = @cmd_stats.values.map { |s| s[:total_time] || 0 }.sum
    total_cmds = @cmd_stats.values.map { |s| s[:count] || 0 }.sum

    puts "\n  Performance Statistics:".c(@c_nick)
    puts "  Total commands executed: #{total_cmds}"
    puts "  Total execution time: #{'%.2f' % total_time}s"
    puts "  Average time per command: #{'%.2f' % (total_time / total_cmds)}s" if total_cmds > 0

    puts "\n  Slowest Commands:".c(@c_nick)
    slowest = @cmd_stats.sort_by { |_, s| -(s[:avg_time] || 0) }.first(5)
    slowest.each_with_index do |(cmd, stats), i|
      puts "  #{(i+1).to_s.rjust(2)}. #{cmd.ljust(20)} avg: #{'%.3f' % (stats[:avg_time] || 0)}s"
    end
  end

  # History statistics
  puts "\n  History Statistics:".c(@c_nick)
  puts "  Total history entries: #{@history.length}"
  puts "  Unique commands: #{@history.uniq.length}"

  # Success/failure tracking
  puts "\n  Last command exit status: #{@last_exit == 0 ? 'Success'.c(@c_path) : "Failed (#{@last_exit})".c(196)}"
  puts
end
def stats_graph # Visual graph mode for stats
  puts "\n  Command Usage Graph".c(@c_prompt).b
  puts "  " + "="*50

  return puts "No data to display" if @cmd_frequency.nil? || @cmd_frequency.empty?

  sorted = @cmd_frequency.sort_by { |_, count| -count }.first(15)
  max_count = sorted.first[1]
  max_width = 40

  puts
  sorted.each_with_index do |(cmd, count), i|
    # Calculate bar width (scaled to max_width)
    bar_width = (count.to_f / max_count * max_width).round
    bar = "â–ˆ" * bar_width

    # Color bars by intensity
    color = case bar_width
    when 0..10 then 244    # Gray
    when 11..20 then 3     # Yellow
    when 21..30 then 214   # Orange
    else 196               # Red
    end

    puts "  #{cmd.ljust(15)} #{count.to_s.rjust(4)}x #{bar.c(color)}"
  end

  # Performance graph if data exists
  if @cmd_stats && !@cmd_stats.empty?
    puts "\n  Command Performance Graph (avg time)".c(@c_prompt).b
    puts "  " + "="*50
    puts

    slowest = @cmd_stats.sort_by { |_, s| -(s[:avg_time] || 0) }.first(10)
    max_time = slowest.first[1][:avg_time]

    slowest.each do |cmd, stats|
      bar_width = (stats[:avg_time] / max_time * max_width).round
      bar = "â–ˆ" * bar_width

      color = case bar_width
      when 0..10 then 2      # Green (fast)
      when 11..20 then 214   # Orange
      else 196               # Red (slow)
      end

      time_str = "#{'%.3f' % stats[:avg_time]}s"
      puts "  #{cmd.ljust(15)} #{time_str.rjust(8)} #{bar.c(color)}"
    end
  end

  puts
end
def export_stats(filename) # Export stats to file (JSON or CSV based on extension)
  if filename.end_with?('.csv')
    export_stats_csv(filename)
  else
    filename += '.json' unless filename.end_with?('.json')
    export_stats_json(filename)
  end
end
def export_stats_json(filename = 'rsh_stats.json') # Export stats to JSON
  stats_data = {
    generated: Time.now.to_i,
    cmd_frequency: @cmd_frequency,
    cmd_stats: @cmd_stats,
    history: {
      total: @history.length,
      unique: @history.uniq.length
    },
    last_exit: @last_exit
  }
  begin
    require 'json'
    File.write(filename, JSON.pretty_generate(stats_data))
    puts "Stats exported to #{filename}"
  rescue => e
    puts "Error exporting stats: #{e.message}"
  end
end
def export_stats_csv(filename = 'rsh_stats.csv') # Export stats to CSV
  begin
    lines = []
    lines << "command,frequency,count,total_time,avg_time"

    # Merge frequency and performance data
    all_cmds = (@cmd_frequency.keys + @cmd_stats.keys).uniq
    all_cmds.sort.each do |cmd|
      freq = @cmd_frequency[cmd] || 0
      count = @cmd_stats.dig(cmd, :count) || 0
      total = @cmd_stats.dig(cmd, :total_time) || 0.0
      avg = @cmd_stats.dig(cmd, :avg_time) || 0.0
      lines << "#{cmd},#{freq},#{count},#{'%.3f' % total},#{'%.3f' % avg}"
    end

    File.write(filename, lines.join("\n"))
    puts "Stats exported to #{filename}"
  rescue => e
    puts "Error exporting stats: #{e.message}"
  end
end
def bm(*args) # Enhanced bookmark management with tags
  # Handle variadic arguments
  arg_str = args.join(' ')

  if args.empty?
    # List all bookmarks
    if @bookmarks.empty?
      puts "No bookmarks defined. Use :bm \"name\" to bookmark current directory"
      return
    end
    puts "\n  Bookmarks:".c(@c_prompt).b
    @bookmarks.each do |name, data|
      path = data.is_a?(Hash) ? data[:path] : data
      tags = data.is_a?(Hash) && data[:tags] ? " [#{data[:tags].join(', ')}]" : ""
      puts "  #{name.c(@c_nick)} â†’ #{path}#{tags.c(@c_stamp)}"
    end
    puts
  elsif args[0] == '--export'
    # Export bookmarks to file
    filename = args[1] || 'bookmarks.json'
    export_bookmarks(filename)
  elsif args[0] == '--import'
    # Import bookmarks from file
    filename = args[1]
    import_bookmarks(filename) if filename
  elsif args[0] == '--stats'
    # Show bookmark statistics
    bookmark_stats
  elsif arg_str =~ /^(\w+)\s+(.+)$/
    # Set bookmark with optional tags
    name, rest = $1, $2
    if rest.include?('#')
      path_part, tag_part = rest.split('#', 2)
      path = path_part.strip
      path = Dir.pwd if path.empty?
      tags = tag_part.split(',').map(&:strip)
      @bookmarks[name] = {path: path, tags: tags}
    else
      @bookmarks[name] = {path: rest.strip, tags: []}
    end
    puts "Bookmark '#{name}' set to #{@bookmarks[name][:path]}"
    rshrc
  elsif arg_str =~ /^-(\w+)$/
    # Delete bookmark
    name = $1
    if @bookmarks.delete(name)
      puts "Bookmark '#{name}' deleted"
      rshrc
    else
      puts "Bookmark '#{name}' not found"
    end
  elsif arg_str =~ /^\?(\w*)$/
    # Search bookmarks by tag
    tag = $1
    if tag.empty?
      puts "Available tags:"
      all_tags = @bookmarks.values.flat_map { |d| d.is_a?(Hash) ? d[:tags] : [] }.uniq.sort
      puts "  " + all_tags.join(", ")
    else
      matches = @bookmarks.select do |_, data|
        data.is_a?(Hash) && data[:tags] && data[:tags].include?(tag)
      end
      if matches.empty?
        puts "No bookmarks with tag '#{tag}'"
      else
        puts "Bookmarks with tag '#{tag}':"
        matches.each { |name, data| puts "  #{name} â†’ #{data[:path]}" }
      end
    end
  else
    # Bookmark current directory
    name = arg_str.strip
    @bookmarks[name] = {path: Dir.pwd, tags: []}
    puts "Bookmark '#{name}' set to #{Dir.pwd}"
    rshrc
  end
end
def bookmark(*args) # Alias for bm
  bm(*args)
end
def export_bookmarks(filename = 'bookmarks.json') # Export bookmarks to JSON
  begin
    require 'json'
    File.write(filename, JSON.pretty_generate(@bookmarks))
    puts "Bookmarks exported to #{filename}"
  rescue => e
    puts "Error exporting bookmarks: #{e.message}"
  end
end
def import_bookmarks(filename) # Import bookmarks from JSON
  unless File.exist?(filename)
    puts "File '#{filename}' not found"
    return
  end
  begin
    require 'json'
    imported = JSON.parse(File.read(filename))
    imported.each do |name, data|
      # Convert to proper format
      if data.is_a?(Hash)
        @bookmarks[name] = {
          path: data['path'] || data[:path],
          tags: data['tags'] || data[:tags] || []
        }.transform_keys(&:to_sym)
      else
        @bookmarks[name] = {path: data.to_s, tags: []}
      end
    end
    puts "Imported #{imported.length} bookmarks from #{filename}"
    rshrc
  rescue => e
    puts "Error importing bookmarks: #{e.message}"
  end
end
def bookmark_stats # Show bookmark usage statistics
  if @bookmarks.empty?
    puts "No bookmarks defined"
    return
  end

  puts "\n  Bookmark Statistics".c(@c_prompt).b
  puts "  " + "="*50
  puts "\n  Total bookmarks: #{@bookmarks.length}"

  # Count by tags
  all_tags = @bookmarks.values.flat_map { |d| d.is_a?(Hash) ? (d[:tags] || []) : [] }
  unless all_tags.empty?
    puts "\n  Tags Distribution:".c(@c_nick)
    tag_counts = all_tags.group_by(&:itself).transform_values(&:count)
    tag_counts.sort_by { |_, count| -count }.each do |tag, count|
      puts "    #{tag.ljust(15)} #{count}x"
    end
  end

  # Bookmarks by directory depth
  puts "\n  Path Analysis:".c(@c_nick)
  paths = @bookmarks.values.map { |d| d.is_a?(Hash) ? d[:path] : d }
  avg_depth = paths.map { |p| p.split('/').length }.sum / paths.length
  puts "    Average path depth: #{avg_depth}"
  puts
end
def save_session(*args) # Save current session state
  session_name = args[0] || 'default'
  session_path = @session_dir + "/#{session_name}.json"

  session = {
    name: session_name,
    pwd: Dir.pwd,
    history: @history.first(50),
    bookmarks: @bookmarks,
    defuns: @defuns,
    timestamp: Time.now.to_i
  }
  begin
    require 'json'
    File.write(session_path, JSON.pretty_generate(session))
    puts "Session '#{session_name}' saved to #{session_path}"
  rescue => e
    puts "Error saving session: #{e.message}"
  end
end
def load_session(*args) # Restore previous session
  session_name = args[0] || 'default'
  session_path = @session_dir + "/#{session_name}.json"

  unless File.exist?(session_path)
    puts "Session '#{session_name}' not found"
    list_sessions
    return
  end
  begin
    require 'json'
    session = JSON.parse(File.read(session_path), symbolize_names: true)

    # Restore state
    Dir.chdir(session[:pwd]) if session[:pwd] && Dir.exist?(session[:pwd])

    # Merge history (prepend saved history)
    if session[:history]
      @history = (session[:history] + @history).uniq.first(@histsize)
    end

    # Restore bookmarks
    if session[:bookmarks]
      session[:bookmarks].each do |name, data|
        bookmark_data = data.is_a?(Hash) ? data.transform_keys(&:to_sym) : data
        @bookmarks[name.to_s] = bookmark_data
      end
    end

    # Restore defuns
    if session[:defuns]
      session[:defuns].each do |name, func_def|
        next unless func_def.is_a?(String)
        @defuns[name.to_s] = func_def
        # Re-evaluate the function
        if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
          func_name, func_params, func_body = $1, $2, $3
          eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
          singleton_class.class_eval(eval_code) rescue nil
        end
      end
    end

    saved_time = Time.at(session[:timestamp] || 0).strftime("%Y-%m-%d %H:%M:%S")
    puts "Session '#{session_name}' restored from #{saved_time}"
    rshrc
  rescue => e
    puts "Error loading session: #{e.message}"
  end
end
def list_sessions # List all saved sessions
  unless Dir.exist?(@session_dir)
    puts "No sessions directory found"
    return
  end

  sessions = Dir.glob(@session_dir + '/*.json').map { |f| File.basename(f, '.json') }

  if sessions.empty?
    puts "No saved sessions found. Use :save_session \"name\" to create one"
    return
  end

  puts "\n  Saved Sessions:".c(@c_prompt).b
  sessions.sort.each do |name|
    session_path = @session_dir + "/#{name}.json"
    begin
      require 'json'
      session = JSON.parse(File.read(session_path), symbolize_names: true)
      timestamp = Time.at(session[:timestamp] || 0).strftime("%Y-%m-%d %H:%M")
      pwd = session[:pwd] || '?'
      puts "  #{name.c(@c_bookmark).ljust(20)} #{timestamp.c(@c_stamp)} #{pwd.c(@c_path)}"
    rescue => e
      puts "  #{name.c(@c_bookmark).ljust(20)} [corrupted]".c(196)
    end
  end
  puts
end
def delete_session(*args) # Delete a saved session
  name = args[0]

  if name == '*'
    # Delete all sessions except default
    sessions = Dir.glob(@session_dir + '/*.json').map { |f| File.basename(f, '.json') }
    sessions.reject! { |s| s == 'default' || s == 'autosave' }

    if sessions.empty?
      puts "No sessions to delete (keeping default and autosave)"
      return
    end

    sessions.each do |session_name|
      session_path = @session_dir + "/#{session_name}.json"
      File.delete(session_path)
    end
    puts "Deleted #{sessions.length} sessions: #{sessions.join(', ')}"
    return
  end

  return puts "Cannot delete default session" if name == 'default'
  return puts "Cannot delete autosave session (use * to delete all)" if name == 'autosave'

  session_path = @session_dir + "/#{name}.json"
  unless File.exist?(session_path)
    puts "Session '#{name}' not found"
    return
  end

  File.delete(session_path)
  puts "Session '#{name}' deleted"
end
def rmsession(*args) # Alias for delete_session
  delete_session(*args)
end
def theme(*args) # Apply color scheme presets
  name = args[0]

  if name.nil?
    puts "\n  Available themes:".c(@c_prompt).b
    puts "    default, solarized, dracula, gruvbox, nord, monokai"
    puts "\n  Current theme colors:"
    puts "    prompt:#{' '*5}#{@c_prompt}   cmd:#{' '*8}#{@c_cmd}   nick:#{' '*7}#{@c_nick}"
    puts "    gnick:#{' '*6}#{@c_gnick}   path:#{' '*7}#{@c_path}   switch:#{' '*5}#{@c_switch}"
    puts "    bookmark:#{' '*3}#{@c_bookmark}   colon:#{' '*6}#{@c_colon}   tabselect:#{' '*2}#{@c_tabselect}"
    puts "    taboption:#{' '*2}#{@c_taboption}   stamp:#{' '*6}#{@c_stamp}"
    puts
    return
  end

  case name.downcase
  when 'default'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 10, 2, 6, 14
    @c_path, @c_switch, @c_bookmark, @c_colon = 3, 6, 13, 4
    @c_tabselect, @c_taboption, @c_stamp = 5, 244, 244
  when 'solarized'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 33, 64, 37, 117
    @c_path, @c_switch, @c_bookmark, @c_colon = 136, 125, 61, 33
    @c_tabselect, @c_taboption, @c_stamp = 166, 240, 240
  when 'dracula'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 141, 84, 117, 212
    @c_path, @c_switch, @c_bookmark, @c_colon = 228, 215, 141, 141
    @c_tabselect, @c_taboption, @c_stamp = 212, 238, 238
  when 'gruvbox'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 214, 142, 109, 175
    @c_path, @c_switch, @c_bookmark, @c_colon = 208, 142, 167, 214
    @c_tabselect, @c_taboption, @c_stamp = 208, 243, 243
  when 'nord'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 110, 109, 116, 152
    @c_path, @c_switch, @c_bookmark, @c_colon = 180, 109, 139, 110
    @c_tabselect, @c_taboption, @c_stamp = 143, 240, 240
  when 'monokai'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 197, 112, 81, 141
    @c_path, @c_switch, @c_bookmark, @c_colon = 228, 208, 141, 197
    @c_tabselect, @c_taboption, @c_stamp = 197, 238, 238
  else
    puts "Unknown theme '#{name}'. Available: default, solarized, dracula, gruvbox, nord, monokai"
    return
  end

  puts "Theme '#{name}' applied"
  puts "Add this to .rshrc to make it permanent: :theme \"#{name}\""
end
def load_plugins # Load all plugins from plugin directory
  return unless Dir.exist?(@plugin_dir)

  plugin_files = Dir.glob(@plugin_dir + '/*.rb').sort

  plugin_files.each do |plugin_file|
    plugin_name = File.basename(plugin_file, '.rb')

    # Skip if disabled
    next if @plugin_disabled.include?(plugin_name)

    begin
      # Load the plugin file
      load(plugin_file)

      # Find the plugin class (conventionally PluginNamePlugin)
      class_name = plugin_name.split('_').map(&:capitalize).join + 'Plugin'

      # Try to instantiate the plugin
      if Object.const_defined?(class_name)
        plugin_class = Object.const_get(class_name)
        rsh_context = {
          version: @version,
          history: @history,
          bookmarks: @bookmarks,
          nick: @nick,
          gnick: @gnick,
          pwd: Dir.pwd,
          config: method(:config),
          rsh: self
        }
        plugin_instance = plugin_class.new(rsh_context)
        @plugins << { name: plugin_name, instance: plugin_instance, class: class_name }

        # Load plugin completions
        if plugin_instance.respond_to?(:add_completions)
          completions = plugin_instance.add_completions
          @cmd_completions.merge!(completions) if completions.is_a?(Hash)
        end

        # Load plugin commands
        if plugin_instance.respond_to?(:add_commands)
          commands = plugin_instance.add_commands
          @plugin_commands.merge!(commands) if commands.is_a?(Hash)
        end

        puts "  Loaded plugin: #{plugin_name} (#{class_name})" if ENV['RSH_DEBUG']
      end
    rescue => e
      puts "Warning: Failed to load plugin '#{plugin_name}': #{e.message}" if ENV['RSH_DEBUG']
      puts "  #{e.backtrace.first}" if ENV['RSH_DEBUG']
    end
  end

  # Call on_startup for all plugins
  @plugins.each do |plugin|
    begin
      plugin[:instance].on_startup if plugin[:instance].respond_to?(:on_startup)
    rescue => e
      puts "Warning: Plugin '#{plugin[:name]}' on_startup failed: #{e.message}" if ENV['RSH_DEBUG']
    end
  end
end
def call_plugin_hook(hook_name, *args) # Call a lifecycle hook for all plugins
  results = []
  @plugins.each do |plugin|
    begin
      if plugin[:instance].respond_to?(hook_name)
        result = plugin[:instance].send(hook_name, *args)
        results << result unless result.nil?
      end
    rescue => e
      puts "Warning: Plugin '#{plugin[:name]}' hook '#{hook_name}' failed: #{e.message}" if ENV['RSH_DEBUG']
    end
  end
  results
end
def plugins(*args) # Plugin management command
  if args.empty?
    # List all plugins
    if @plugins.empty?
      puts "\nNo plugins loaded"
      puts "Place .rb files in #{@plugin_dir}"
      return
    end

    puts "\n  Loaded Plugins:".c(@c_prompt).b
    @plugins.each do |plugin|
      status = @plugin_disabled.include?(plugin[:name]) ? '[disabled]'.c(196) : '[enabled]'.c(@c_path)
      puts "    #{plugin[:name].ljust(20)} #{status} (#{plugin[:class]})"
    end

    unless @plugin_disabled.empty?
      puts "\n  Disabled Plugins:".c(@c_stamp)
      @plugin_disabled.each { |name| puts "    #{name}" }
    end
    puts
  elsif args[0] == 'reload'
    # Reload all plugins
    @plugins = []
    @plugin_commands = {}
    load_plugins
    puts "Plugins reloaded (#{@plugins.length} loaded)"
  elsif args[0] == 'enable' && args[1]
    # Enable a plugin
    plugin_name = args[1]
    @plugin_disabled.delete(plugin_name)
    puts "Plugin '#{plugin_name}' enabled. Use :plugins reload to load it"
    rshrc
  elsif args[0] == 'disable' && args[1]
    # Disable a plugin
    plugin_name = args[1]
    unless @plugin_disabled.include?(plugin_name)
      @plugin_disabled << plugin_name
    end
    @plugins.reject! { |p| p[:name] == plugin_name }
    puts "Plugin '#{plugin_name}' disabled"
    rshrc
  elsif args[0] == 'info' && args[1]
    # Show plugin info
    plugin_name = args[1]
    plugin = @plugins.find { |p| p[:name] == plugin_name }
    if plugin
      puts "\n  Plugin: #{plugin_name}".c(@c_prompt).b
      puts "    Class: #{plugin[:class]}"
      puts "    File: #{@plugin_dir}/#{plugin_name}.rb"

      puts "\n  Hooks:".c(@c_nick)
      %i[on_startup on_command_before on_command_after on_prompt].each do |hook|
        has_hook = plugin[:instance].respond_to?(hook) ? 'âœ“' : 'âœ—'
        puts "    #{has_hook} #{hook}"
      end

      puts "\n  Extensions:".c(@c_nick)
      puts "    âœ“ add_completions" if plugin[:instance].respond_to?(:add_completions)
      puts "    âœ“ add_commands" if plugin[:instance].respond_to?(:add_commands)
      puts
    else
      puts "Plugin '#{plugin_name}' not found"
    end
  else
    puts "Usage:"
    puts "  :plugins              List all plugins"
    puts "  :plugins reload       Reload all plugins"
    puts "  :plugins enable NAME  Enable a plugin"
    puts "  :plugins disable NAME Disable a plugin"
    puts "  :plugins info NAME    Show plugin details"
  end
end
def validate_command(cmd) # Syntax validation before execution
  return nil if cmd.nil? || cmd.empty?
  warnings = []

  # Check for common mistakes
  warnings << "Unmatched quotes" if cmd.count("'").odd? || cmd.count('"').odd?
  warnings << "Unmatched parentheses" if cmd.count("(") != cmd.count(")")
  warnings << "Unmatched brackets" if cmd.count("[") != cmd.count("]")
  warnings << "Unmatched braces" if cmd.count("{") != cmd.count("}")

  # Check for potentially dangerous patterns
  warnings << "WARNING: Recursive rm detected" if cmd =~ /rm\s+.*-r.*\//
  warnings << "WARNING: Force flag without path" if cmd =~ /rm\s+-[rf]+\s*$/
  warnings << "WARNING: Sudo with redirection" if cmd =~ /sudo.*>/

  # Check for common typos in popular commands (skip for : commands)
  if cmd =~ /^(\w+)/ && cmd !~ /^:/
    first_cmd = $1
    # Check if command exists (don't warn for valid commands)
    is_valid_cmd = @exe.include?(first_cmd) ||
                   @nick.include?(first_cmd) ||
                   first_cmd == "cd" ||
                   (@plugin_commands && @plugin_commands[first_cmd]) ||
                   (@defuns && @defuns.keys.include?(first_cmd))

    unless is_valid_cmd
      suggestions = suggest_command(first_cmd)
      if suggestions && !suggestions.empty?
        # Auto-correct if enabled and first suggestion has distance â‰¤ 2
        if @auto_correct && levenshtein_distance(first_cmd, suggestions[0]) <= 2
          warnings << "AUTO-CORRECTING: '#{first_cmd}' â†’ '#{suggestions[0]}'"
        else
          warnings << "Command '#{first_cmd}' not found. Did you mean: #{suggestions.join(', ')}?"
        end
      end
    end
  end

  warnings.empty? ? nil : warnings
end
def calc(*args) # Inline calculator using Ruby's Math library
  if args.empty?
    puts "Usage: calc <expression>"
    puts "Examples:"
    puts "  calc 2 + 2"
    puts "  calc \"Math.sqrt(16)\""
    puts "  calc \"Math::PI * 2\""
    return
  end

  expression = args.join(' ')

  begin
    # Safe evaluation with Math library
    result = eval(expression, binding, __FILE__, __LINE__)
    puts result
  rescue SyntaxError => e
    puts "Syntax error in expression: #{e.message}"
  rescue => e
    puts "Error evaluating expression: #{e.message}"
  end
end
def apply_auto_correct(cmd) # Apply auto-correction to command
  return cmd unless @auto_correct
  return cmd if cmd =~ /^:/  # Don't auto-correct colon commands
  return cmd unless cmd =~ /^(\w+)/

  first_cmd = $1

  # Don't auto-correct if command exists
  return cmd if @exe.include?(first_cmd)
  return cmd if @nick.include?(first_cmd)
  return cmd if first_cmd == "cd"
  return cmd if @plugin_commands && @plugin_commands[first_cmd]
  return cmd if @defuns && @defuns.keys.include?(first_cmd)  # Check user defuns

  suggestions = suggest_command(first_cmd)
  if suggestions && !suggestions.empty? && levenshtein_distance(first_cmd, suggestions[0]) <= 2
    # Auto-correct using first (closest) suggestion
    cmd.sub(/^#{first_cmd}/, suggestions[0])
  else
    cmd
  end
end
def execute_conditional(cmd_line)
  # Split on && and || while preserving the operators
  parts = cmd_line.split(/(\s*&&\s*|\s*\|\|\s*)/)

  result = nil  # Start with nil to handle first command
  i = 0

  while i < parts.length
    part = parts[i].strip
    i += 1
    next if part.empty?

    if part == '&&'
      # If previous command failed, skip the rest until we find || or end
      unless result
        while i < parts.length && parts[i].strip != '||'
          i += 1
        end
      end
    elsif part == '||'
      # If previous command succeeded, skip the rest until we find && or end
      if result
        while i < parts.length && parts[i].strip != '&&'
          i += 1
        end
      end
    else
      # Execute the command
      success = system(part)
      result = success
      @last_exit = $?.exitstatus
      puts " Command failed: #{part} (exit #{@last_exit})" unless success
    end
  end

  result
end
def expand_braces(str)
  # Simple brace expansion: {a,b,c} -> a b c
  str.gsub(/\{([^}]+)\}/) do |match|
    items = $1.split(',').map(&:strip)
    items.join(' ')
  end
end

# AI INTEGRATION FUNCTIONS
def get_ollama_model
  begin
    # Try to get list of available models
    output = `ollama list 2>/dev/null`
    return nil if output.empty? || $?.exitstatus != 0
    
    # Parse the output to find a suitable model
    lines = output.split("\n")
    return nil if lines.length < 2
    
    # Skip header line and get first available model
    model_line = lines[1]
    return nil if model_line.nil?
    
    # Extract model name (first column)
    model_name = model_line.split(/\s+/)[0]
    return model_name
  rescue => e
    return nil
  end
end

def ai_query(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        return ai_setup_help unless ollama_model
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: prompt,
          stream: false,
          options: {
            num_predict: 200
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['response']
        else
          return ai_setup_help
        end
      rescue => e
        return ai_setup_help
      end
    else
      return ai_setup_help
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: prompt}],
          max_tokens: 200,
          temperature: 0.7
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['choices'][0]['message']['content']
        else
          return "Error: #{response.code} - #{response.body}"
        end
      rescue => e
        return "Error connecting to OpenAI: #{e.message}"
      end
    else
      return "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
    end
  end
end

def ai_command_suggest(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  # Modify prompt to request command output
  cmd_prompt = "You are a Linux/Unix command line expert. Given this request: '#{prompt}', output ONLY the exact shell command that would accomplish this task. Output just the command itself with no explanation, no backticks, no markdown. For example, if asked 'list files' you would output: ls"
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        unless ollama_model
          puts ai_setup_help
          return nil
        end
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: cmd_prompt,
          stream: false,
          options: {
            num_predict: 50,
            temperature: 0.3
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['response'].strip.split("\n")[0]
          return cmd
        else
          puts ai_setup_help
          return nil
        end
      rescue => e
        puts ai_setup_help
        return nil
      end
    else
      puts ai_setup_help
      return nil
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: cmd_prompt}],
          max_tokens: 50,
          temperature: 0.3
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['choices'][0]['message']['content'].strip.split("\n")[0]
          return cmd
        else
          puts "Error: #{response.code} - #{response.body}"
          return nil
        end
      rescue => e
        puts "Error connecting to OpenAI: #{e.message}"
        return nil
      end
    else
      puts "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
      return nil
    end
  end
end

def ai_setup_help
  help_text = <<~HELP
    
    AI is not configured. To use AI features, you have two options:
    
    1. Install Ollama (recommended for local AI):
       curl -fsSL https://ollama.com/install.sh | sh
       ollama pull llama3.2  # or any model you prefer
    
    2. Configure external AI model in ~/.rshrc:
       @aimodel = "gpt-4"
       @aikey = "your-api-key-here"
    
    Once configured:
    - Use @ for AI text responses: @ What is the GDP of Norway?
    - Use @@ for AI command suggestions: @@ list files sorted by size
  HELP
  return help_text.c(@c_path)
end

# INITIAL SETUP
def load_rshrc_safe
  return unless File.exist?(Dir.home+'/.rshrc')

  begin
    # Try to load the .rshrc file
    load(Dir.home+'/.rshrc')

    # Validate critical variables
    @history = [] unless @history.is_a?(Array)
    @nick = {} unless @nick.is_a?(Hash)
    @gnick = {} unless @gnick.is_a?(Hash)
    @cmd_frequency = {} unless @cmd_frequency.is_a?(Hash)
    @cmd_stats = {} unless @cmd_stats.is_a?(Hash)
    @bookmarks = {} unless @bookmarks.is_a?(Hash)
    @defuns = {} unless @defuns.is_a?(Hash)
    @history_dedup = 'smart' unless @history_dedup.is_a?(String)
    @session_autosave = 0 unless @session_autosave.is_a?(Integer)
    @auto_correct = false unless [@auto_correct].any? { |v| v == true || v == false }
    @slow_command_threshold = 0 unless @slow_command_threshold.is_a?(Integer)
    @plugin_disabled = [] unless @plugin_disabled.is_a?(Array)
    @plugins = [] unless @plugins.is_a?(Array)
    @plugin_commands = {} unless @plugin_commands.is_a?(Hash)

    # Restore defuns from .rshrc
    if @defuns && !@defuns.empty?
      @defuns.each do |name, func_def|
        next unless func_def.is_a?(String)
        if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
          func_name, func_params, func_body = $1, $2, $3
          begin
            eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
            singleton_class.class_eval(eval_code)
          rescue => e
            puts "Warning: Could not load defun '#{name}': #{e.message}" if ENV['RSH_DEBUG']
          end
        end
      end
    end

  rescue SyntaxError => e
    puts "\n\033[31mERROR: Syntax error in .rshrc:\033[0m"
    puts e.message
    puts "\n\033[33mAttempting to auto-heal .rshrc...\033[0m\n"

    if auto_heal_rshrc
      puts "\033[32m.rshrc has been healed! Retrying...\033[0m\n"
      begin
        load(Dir.home+'/.rshrc')
      rescue => e2
        puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
        load_defaults
      end
    else
      puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
      load_defaults
    end

  rescue => e
    puts "\n\033[31mERROR loading .rshrc: #{e.message}\033[0m"
    puts "\033[33mLoading with defaults...\033[0m\n"
    load_defaults
  end
end

def auto_heal_rshrc
  begin
    rshrc_path = Dir.home + '/.rshrc'
    return false unless File.exist?(rshrc_path)

    # Backup the corrupted file
    backup_path = rshrc_path + '.backup.' + Time.now.strftime('%Y%m%d_%H%M%S')
    File.write(backup_path, File.read(rshrc_path))
    puts "Backed up corrupted .rshrc to #{backup_path}"

    content = File.read(rshrc_path)
    original_content = content.dup
    healed = false

    # Fix common history array issues
    if content =~ /^@history\s*=\s*\[.*\]\s*\n\s*,/m
      # Fix case where array ends with ] followed by comma on next line
      content.gsub!(/^(@history\s*=\s*\[.*\])\s*\n\s*,(.*)$/m) do |match|
        # Remove the extra closing bracket and merge the lines
        history_line = $1
        continuation = $2
        # Remove trailing ] from first part
        history_line = history_line.sub(/\]\s*$/, '')
        # Combine and close properly
        "#{history_line}, #{continuation}]"
      end
      healed = true
    end

    # Fix unclosed arrays
    ['@history', '@nick', '@gnick', '@cmd_frequency'].each do |var|
      if content =~ /^#{var}\s*=\s*[\[{](?!.*[}\]]\s*$)/m
        content.sub!(/^(#{var}\s*=\s*)(\[.*?)$/m) { "#{$1}#{$2}]" }
        content.sub!(/^(#{var}\s*=\s*)({.*?)$/m) { "#{$1}#{$2}}" }
        healed = true
      end
    end

    # Validate Ruby syntax of the healed content
    begin
      # Try to parse the content
      eval("BEGIN {return true}\n" + content)
    rescue SyntaxError => e
      # If still has syntax errors, extract only valid parts
      new_content = ""

      # Extract valid variable assignments
      content.each_line do |line|
        if line =~ /^(@\w+|\w+)\s*=\s*.+$/
          begin
            eval(line)
            new_content += line
          rescue
            # Skip invalid lines
          end
        elsif line =~ /^(def|class|module|end|if|else|elsif|when|case|begin|rescue)/
          new_content += line
        elsif line.strip.start_with?('#') || line.strip.empty?
          new_content += line
        end
      end

      content = new_content
      healed = true
    end

    if healed && content != original_content
      File.write(rshrc_path, content)
      return true
    end

    false
  rescue => e
    puts "Error during auto-heal: #{e.message}"
    false
  end
end

def load_defaults
  @history ||= []
  @nick ||= {"ls" => "ls --color -F"}
  @gnick ||= {}
  @completion_limit ||= 10
  @completion_case_sensitive ||= false
  @completion_show_descriptions ||= false
  @completion_fuzzy ||= true
  @cmd_frequency ||= {}
  @cmd_stats ||= {}
  @bookmarks ||= {}
  @defuns ||= {}
  @switch_cache ||= {}
  @switch_cache_time ||= {}
  @history_dedup ||= 'smart'
  @session_autosave ||= 0
  @auto_correct ||= false
  @slow_command_threshold ||= 0
  @plugin_disabled ||= []
  @plugins ||= []
  @plugin_commands ||= {}
  puts "Loaded with default configuration."
end

def cache_executables
  current_path = ENV["PATH"]
  current_time = Time.now.to_i

  # Only rebuild cache if PATH changed or cache is older than 60 seconds
  return if @exe_cache_paths == current_path && (current_time - @exe_cache_time) < 60

  @exe = []
  @path = current_path.split(":")
  @path.map! {|p| p + "/*"}

  @path.each do |p|
    Dir.glob(p).each do |c|
      @exe.append(File.basename(c)) if File.executable?(c) and not Dir.exist?(c)
    end
  end

  @exe.uniq!
  @exe_cache_time = current_time
  @exe_cache_paths = current_path
end

begin # Load .rshrc and populate @history
  trap "SIGINT" do end
  trap "SIGHUP" do
    rshrc
    exit
  end
  trap "SIGTERM" do
    rshrc
    exit
  end
  firstrun unless File.exist?(Dir.home+'/.rshrc') # Initial loading - to get history
  load_rshrc_safe
  # Load login shell files if rsh is running as login shell
  if ENV['LOGIN_SHELL'] or $0 == "-rsh" or ARGV.include?('-l') or ARGV.include?('--login')
    ['/etc/profile', Dir.home+'/.profile', Dir.home+'/.bash_profile', Dir.home+'/.bashrc'].each do |f|
      if File.exist?(f)
        puts "Loading #{f}..." if ENV['RSH_DEBUG']
        begin
          # Source shell files by extracting export statements
          File.readlines(f).each do |line|
            if line =~ /^\s*export\s+(\w+)=(.*)/
              ENV[$1] = $2.gsub(/['"]/, '')
            end
          end
        rescue => e
          puts "Warning: Could not source #{f}: #{e}" if ENV['RSH_DEBUG']
        end
      end
    end
  end 
  ENV["SHELL"] = __FILE__
  ENV["TERM"]  = "rxvt-unicode-256color"
  ENV["PATH"]  ? ENV["PATH"] += ":" : ENV["PATH"] = ""
  ENV["PATH"] += "/home/#{@user}/bin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  if @lscolors and File.exist?(@lscolors)
    ls = File.read(@lscolors) 
    ls.sub!(/export.*/, '')
    ls.sub!(/^LS_COLORS=/, 'ENV["LS_COLORS"]=')
    eval(ls)
  end
  @c = Cursor               # Initiate @c as Cursor
  @c.save                   # Get max row & col
  @c.row(8000)
  @c.col(8000)
  @maxrow, @maxcol = @c.pos
  @c.restore                # Max row & col gotten, cursor restored
  hist_clean                # Remove duplicates, etc
  @path.map! {|p| p + "/*"} # Set proper format for path search
  @plugins_loaded = false   # Defer plugin loading until first command
end

# MAIN PART
loop do 
  begin
    @user = Etc.getpwuid(Process.euid).name # For use in @prompt
    @node = Etc.uname[:nodename]            # For use in @prompt
    h = @history; f = @cmd_frequency; s = @cmd_stats; b = @bookmarks; d = @defuns; load_rshrc_safe; @history = h; @cmd_frequency = f; @cmd_stats = s; @bookmarks = b; @defuns = d # reload prompt but preserve runtime data
    @prompt.gsub!(/#{Dir.home}/, '~') # Simplify path in prompt
    system("printf \"\033]0;rsh: #{Dir.pwd}\007\"")   # Set Window title to path
    @history[0] = "" unless @history[0]
    cache_executables  # Use cached executable lookup
    # Load plugins on first command (lazy loading)
    unless @plugins_loaded
      load_plugins
      @plugins_loaded = true
    end
    # Append plugin prompt additions (after plugins loaded)
    plugin_prompts = call_plugin_hook(:on_prompt)
    @prompt += plugin_prompts.join if plugin_prompts.any?
    # Auto-save session if enabled and interval elapsed
    if @session_autosave && @session_autosave > 0
      current_time = Time.now.to_i
      if (current_time - @session_last_save) >= @session_autosave
        save_session('autosave')
        @session_last_save = current_time
      end
    end
    getstr # Main work is here
    @cmd = @history[0]
    @dirs.unshift(Dir.pwd)
    @dirs.pop
    hist_clean # Clean up the history
    @cmd = "ls" if @cmd == "" # Default to ls when no command is given
    # Enhanced history commands
    if @cmd == '!!'
      # Repeat last command
      @cmd = @history[1] if @history.length > 1
    elsif @cmd =~ /^!-(\d+)$/
      # Repeat nth to last (e.g., !-2 = 2nd to last)
      index = $1.to_i
      @cmd = @history[index] if @history.length > index
    elsif @cmd =~ /^!(\d+):(\d+)$/
      # Chain commands (e.g., !5:7 = commands 5, 6, 7)
      start_idx = $1.to_i + 1
      end_idx = $2.to_i + 1
      if start_idx < @history.length && end_idx < @history.length && start_idx <= end_idx
        commands = @history[start_idx..end_idx].compact.reverse
        # Filter out colon commands (they don't work in shell chains)
        commands.reject! { |c| c =~ /^:/ }
        if commands.empty?
          puts "Cannot chain colon commands (use shell commands only)"
          @cmd = "ls"  # Default to ls
        else
          @cmd = commands.join(' && ')
          puts " Chaining: #{@cmd}".c(@c_stamp)
        end
      end
    elsif @cmd.match(/^!\d+$/)
      # Original: !5 = command 5
      hi = @history[@cmd.sub(/^!(\d+)$/, '\1').to_i+1]
      @cmd = hi if hi
    end
    # Move cursor to end of line and print the full command before clearing
    @c.row(@row0)
    @c.clear_line
    print @prompt + cmd_check(@cmd)
    print "\n"; @c.clear_screen_down
    if @cmd == "r" # Integration with rtfm (https://github.com/isene/RTFM)
      t  = Time.now
      t0 = t.nsec.to_s
      tf = "/tmp/.rshpwd" + t0
      File.write(tf, Dir.pwd)
      system("rtfm #{tf}")
      Dir.chdir(File.read(tf))
      File.delete(tf)
      system("git status .") if Dir.exist?(".git")
      next
    end
    if @cmd =~ /^\=/ # Integration with xrpn (https://github.com/isene/xrpn)
      @cmd.gsub!("  ", ",")
      @cmd = "echo \"#{@cmd[1...]},prx,off\" | xrpn" 
    end
    # AI integration with @ and @@
    if @cmd =~ /^@@\s+(.+)/ # AI command suggestion
      prompt = $1
      response = ai_command_suggest(prompt)
      if response
        # Store the suggestion for the next prompt
        @ai_suggestion = response
        # Also add to history for record keeping
        @history.unshift(response)
      end
      next
    elsif @cmd =~ /^@\s+(.+)/ # AI text response
      prompt = $1
      response = ai_query(prompt)
      puts response if response
      next
    end
    if @cmd.match(/^\s*:/) # Ruby commands are prefixed with ":"
      begin
        eval(@cmd[1..-1])
      #rescue StandardError => err
      rescue Exception => err
        puts "\n#{err}"
      end
    elsif @cmd == '#' # List previous directories
      dirs
    else # Execute command
      # Check if it's a plugin command FIRST
      cmd_parts = @cmd.split(/\s+/)
      cmd_name = cmd_parts[0]
      if @plugin_commands && @plugin_commands[cmd_name]
        begin
          args = cmd_parts[1..]
          result = @plugin_commands[cmd_name].call(*args)
          puts result unless result.nil?
        rescue => e
          puts "Error in plugin command '#{cmd_name}': #{e}"
        end
      # Then check if it's a user-defined Ruby function (before any expansions)
      elsif self.respond_to?(cmd_name) && singleton_class.instance_methods(false).include?(cmd_name.to_sym)
        begin
          args = cmd_parts[1..]
          puts "DEBUG: Calling #{cmd_name} with args: #{args}" if ENV['RSH_DEBUG']
          result = self.send(cmd_name, *args)
          puts "DEBUG: Result: #{result.inspect}" if ENV['RSH_DEBUG']
          puts result unless result.nil?
        rescue => e
          puts "Error calling function '#{cmd_name}': #{e}"
        end
      else
        # Handle conditional execution (&& and ||)
        if @cmd.include?('&&') || @cmd.include?('||')
          execute_conditional(@cmd)
          next
        end
        # Expand brace expansion {a,b,c}
        @cmd = expand_braces(@cmd)
        # Expand command substitution $(command) and backticks
        @cmd = @cmd.gsub(/\$\(([^)]+)\)/) { `#{$1}`.chomp }
        @cmd = @cmd.gsub(/`([^`]+)`/) { `#{$1}`.chomp }
        # Expand environment variables and exit status
        @cmd = @cmd.gsub(/\$\?/) { @last_exit.to_s }
        @cmd = @cmd.gsub(/\$(\w+)|\$\{(\w+)\}/) { ENV[$1 || $2] || '' }
        # Expand tilde
        @cmd = @cmd.gsub(/~/, Dir.home)
        ca = @nick.transform_keys {|k| /((^\K\s*\K)|(\|\K\s*\K))\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ca.keys), @nick)
        ga = @gnick.transform_keys {|k| /\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ga.keys), @gnick)
        @cmd = "~" if @cmd == "cd"
        @cmd.sub!(/^cd (\S*).*/, '\1')
        @cmd = Dir.home if @cmd == "~"
        @cmd = @dirs[1] if @cmd == "-"
        @cmd = @dirs[@cmd.to_i] if @cmd =~ /^\d$/
        # Check if it's a directory to change to first
        dir = @cmd.strip.sub(/~/, Dir.home)
        if Dir.exist?(dir)
          Dir.chdir(dir)
          system("git status .") if Dir.exist?(".git")
        # Then check if it's a bookmark (commands and nicks already handled above)
        elsif @bookmarks && @bookmarks[@cmd]
          bookmark_data = @bookmarks[@cmd]
          bm_dir = bookmark_data.is_a?(Hash) ? bookmark_data[:path] : bookmark_data
          bm_dir = bm_dir.sub(/^~/, Dir.home)  # Expand tilde
          if Dir.exist?(bm_dir)
            Dir.chdir(bm_dir)
            puts "Jumped to bookmark '#{@cmd}' â†’ #{bm_dir}".c(@c_path)
            system("git status .") if Dir.exist?(".git")
          else
            puts "Bookmark '#{@cmd}' points to non-existent directory: #{bm_dir}".c(196)
          end
        else
          puts "#{Time.now.strftime("%H:%M:%S")}: #{@cmd}".c(@c_stamp)
          if @cmd == "f" # fzf integration (https://github.com/junegunn/fzf)
            res = `fzf`.chomp
            Dir.chdir(File.dirname(res))
          elsif File.exist?(@cmd) and not File.executable?(@cmd) and not @cmd.include?(" ")
            # Only auto-open files if it's a single filename (no spaces = no command with args)
            if File.read(@cmd).force_encoding("UTF-8").valid_encoding?
              system("#{ENV['EDITOR']} #{@cmd}") # Try open with user's editor
            else
              if @runmailcap
                Thread.new { system("run-mailcap #{@cmd} 2>/dev/null") }
              else
                Thread.new { system("xdg-open #{@cmd} 2>/dev/null") }
              end
            end
          else
            begin
              pre_cmd

              # Apply auto-correct if enabled (before validation)
              @cmd = apply_auto_correct(@cmd)

              # Validate command after auto-correction
              warnings = validate_command(@cmd)
              if warnings && !warnings.empty?
                # Show non-auto-correct warnings
                warnings.reject { |w| w.start_with?("AUTO-CORRECTING:") }.each { |w| puts "#{w}".c(196) }
                # Show auto-correct and ask for confirmation
                auto_correct_warnings = warnings.select { |w| w.start_with?("AUTO-CORRECTING:") }
                if auto_correct_warnings.any?
                  auto_correct_warnings.each { |w| puts "#{w}".c(214) }
                  print "Accept auto-correction? (Y/n): "
                  response = $stdin.gets.chomp
                  if response.downcase == 'n'
                    puts "Auto-correction cancelled"
                    next
                  end
                end
                # For critical warnings, ask for confirmation
                if warnings.any? { |w| w.start_with?("WARNING:") }
                  print "Continue anyway? (y/N): "
                  response = $stdin.gets.chomp
                  unless response.downcase == 'y'
                    puts "Command cancelled"
                    next
                  end
                end
              end

              # Call plugin on_command_before hooks
              plugin_results = call_plugin_hook(:on_command_before, @cmd)
              # If any plugin returns false, skip command
              if plugin_results.include?(false)
                puts "Command blocked by plugin"
                next
              end
              # If any plugin returns a modified command, use it
              modified_cmd = plugin_results.find { |r| r.is_a?(String) }
              @cmd = modified_cmd if modified_cmd

              # Track command frequency for intelligent completion
              cmd_base = @cmd.split.first if @cmd && !@cmd.empty?
              if cmd_base
                @cmd_frequency[cmd_base] = (@cmd_frequency[cmd_base] || 0) + 1
              end

              # Start timing
              start_time = Time.now

              # Handle background jobs
              if @cmd.end_with?(' &')
                @cmd = @cmd[0..-3]  # Remove the &
                @job_id += 1
                # Handle pipes and redirections in background
                if @cmd.include?('|') || @cmd.include?('>') || @cmd.include?('<')
                  pid = spawn(@cmd, pgroup: true)
                else
                  pid = spawn(@cmd)
                end
                @jobs[@job_id] = {pid: pid, cmd: @cmd, status: :running}
                puts "[#{@job_id}] #{pid} #{@cmd}"
              else
                # Better handling of pipes and redirections
                @current_pid = spawn(@cmd)
                Process.wait(@current_pid)
                @last_exit = $?.exitstatus
                @current_pid = nil
                puts " Command failed: #{@cmd} (exit #{@last_exit})" unless @last_exit == 0
              end

              # Track execution time
              elapsed = Time.now - start_time
              if cmd_base && elapsed > 0.01  # Only track if > 10ms
                @cmd_stats[cmd_base] ||= {count: 0, total_time: 0.0, avg_time: 0.0}
                @cmd_stats[cmd_base][:count] += 1
                @cmd_stats[cmd_base][:total_time] += elapsed
                @cmd_stats[cmd_base][:avg_time] = @cmd_stats[cmd_base][:total_time] / @cmd_stats[cmd_base][:count]
              end

              # Slow command alert
              if @slow_command_threshold > 0 && elapsed > @slow_command_threshold
                puts "âš  Command took #{'%.1f' % elapsed}s (threshold: #{@slow_command_threshold}s)".c(214)
              end

              # Call plugin on_command_after hooks
              call_plugin_hook(:on_command_after, @cmd, @last_exit)

              post_cmd
            rescue StandardError => err
              puts "\nError: #{err}"
            end
          end
        end
      end
    end
  rescue StandardError => err # Throw error nicely
    puts "\n#{err}"
  end
end

# vim: set sw=2 sts=2 et fdm=syntax fdn=2 fcs=fold\:\ :
