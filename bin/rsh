#!/usr/bin/env ruby
# encoding: utf-8
#
# SCRIPT INFO 
# Name:       rsh - Ruby SHell
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/rsh
# License:    Public domain
@version    = "2.7.0" # Major release: Ruby functions, job control, command substitution, login shell support

# MODULES, CLASSES AND EXTENSIONS
class String # Add coloring to strings (with escaping for Readline)
  def c(code);  color(self, "\001\e[38;5;#{code}m\002"); end  # Color code
  def b;        color(self, "\001\e[1m\002"); end             # Bold
  def i;        color(self, "\001\e[3m\002"); end             # Italic
  def u;        color(self, "\001\e[4m\002"); end             # Underline
  def l;        color(self, "\001\e[5m\002"); end             # Blink
  def r;        color(self, "\001\e[7m\002"); end             # Reverse
  def color(text, color_code)  "#{color_code}#{text}\001\e[0m\002" end
end
module Cursor # Terminal cursor movement ANSI codes (thanks to https://github.com/piotrmurach/tty-cursor)
  module_function
  ESC = "\e".freeze
  CSI = "\e[".freeze
  def save # Save current position
    print(Gem.win_platform? ? CSI + 's' : ESC + '7')
  end
  def restore # Restore cursor position
    print(Gem.win_platform? ? CSI + 'u' : ESC + '8')
  end
  def pos # Query cursor current position
    res = ''
    $stdin.raw do |stdin|
      $stdout << CSI + '6n' # Tha actual ANSI get-position
      $stdout.flush
      while (c = stdin.getc) != 'R'
        res << c if c
      end
    end
    m = res.match /(?<row>\d+);(?<col>\d+)/
    return m[:row].to_i, m[:col].to_i
  end
  def rowget
    row, col = self.pos
    return row
  end
  def colget
    row, col = self.pos
    return col
  end
  def col(n = nil) # Cursor moves to nth position horizontally in the current line
    print(CSI + "#{n || 1}G")
  end
  def row(n = nil) # Cursor moves to the nth position vertically in the current column
    print(CSI + "#{n || 1}d")
  end
  def next_line # Move cursor down to beginning of next line
    print(CSI + 'E' + CSI + "1G")
  end
  def clear_line # Erase the entire current line and return to beginning of the line
    print(CSI + '2K' +  CSI + "1G")
  end
  def clear_line_after # Erase from the current position (inclusive) to the end of the line
    print(CSI + '0K')
  end
  def scroll_down # Scroll display down one line
    print(ESC + 'D')
  end
  def clear_screen_down
    print(CSI + 'J')
  end
end

# INITIALIZATION
begin # Requires
  require 'etc'
  require 'io/console'
  require 'io/wait'
end
begin # Initialization
  # Theming
  @c_prompt    = 10                       # Color for basic prompt
  @c_cmd       = 2                        # Color for valid command
  @c_nick      = 6                        # Color for matching nick
  @c_gnick     = 14                       # Color for matching gnick
  @c_path      = 3                        # Color for valid path
  @c_switch    = 6                        # Color for switches/options
  @c_tabselect = 5                        # Color for selected tabcompleted item
  @c_taboption = 244                      # Color for unselected tabcompleted item
  @c_stamp     = 244                      # Color for time stamp/command
  # Prompt
  @prompt      = "rsh > ".c(@c_prompt).b  # Very basic prompt if not defined in .rshrc
  # Hash & array initializations
  @nick        = {}                       # Initiate alias/nick hash
  @gnick       = {}                       # Initiate generic/global alias/nick hash
  @history     = []                       # Initiate history array
  @exe = []
  # Paths
  @user = Etc.getpwuid(Process.euid).name # For use in @prompt
  @path        = ENV["PATH"].split(":")   # Get paths
  # History
  @histsize    = 200                      # Max history if not set in .rshrc
  @hloaded     = false                    # Variable to determine if history is loaded
  # Use run-mailcap instead of xgd-open? Set "= true" in .rshrc if you want run-mailcap
  @runmailcap  = false
  # Variable initializations
  @dirs        = ["."]*10
  @jobs        = {}                       # Background jobs tracking
  @job_id      = 0                        # Job counter
  @last_exit   = 0                        # Last command exit status
  def pre_cmd; end                        # User-defined function to be run BEFORE command execution
  def post_cmd; end                       # User-defined function to be run AFTER  command execution
end

# HELP TEXT
@help = <<~HELP

  Hello #{@user}, welcome to rsh - the Ruby SHell. 
  
  rsh does not attempt to compete with the grand old shells like bash and zsh. 
  It serves the specific needs and wants of its author. If you like it, then feel free 
  to ask for more or different features here: https://github.com/isene/rsh. Features:

  * Aliases (called nicks in rsh) - both for commands and general nicks
  * Syntax highlighting, matching nicks, system commands and valid dirs/files
  * Tab completions for nicks, system commands, command switches and dirs/files
  * Tab completion presents matches in a list to pick from
  * When you start to write a command, rsh will suggest the first match in the history and
    present that in "toned down" letters - press the arrow right key to accept the suggestion
  * Writing a partial command and pressing `UP` will search history for matches.
    Go down/up in the list and press `TAB` or `ENTER` to accept, `Ctrl-g` or `Ctrl-c` to discard
  * History with editing, search and repeat a history command (with `!`)
  * Config file (.rshrc) updates on exit (with Ctrl-d) or not (with Ctrl-e)
  * Set of simple rsh specific commands like nick, nick?, history and rmhistory
  * rsh specific commands and full set of Ruby commands available via :<command>
  * All colors are themeable in .rshrc (see github link for possibilities)
  * Copy current command line to primary selection (paste w/middle button) with `Ctrl-y`

  Special functions/integrations:
  * Use `r` to launch rtfm (https://github.com/isene/RTFM) - if you have it installed
  * Use `f` to launch fzf (https://github.com/junegunn/fzf) - if you have it installed
  * Use `=` followed by xrpn commands separated by commas or double-spaces (https://github.com/isene/xrpn)
  * Use `:` followed by a Ruby expression to access the whole world of Ruby

  Special commands:
  * `:nick 'll = ls -l'` to make a command alias (ll) point to a command (ls -l)
  * `:gnick 'h = /home/me'` to make a general alias (h) point to something (/home/me)
  * `:nick?` will list all command nicks and general nicks (you can edit your nicks in .rshrc)
  * `:history` will list the command history, while `:rmhistory` will delete the history
  * `:jobs` will list background jobs, `:fg [job_id]` brings jobs to foreground, `:bg [job_id]` resumes stopped jobs
  * `:defun 'func(args) = code'` defines Ruby functions callable as shell commands
  * `:defun?` lists all user-defined functions, `:defun '-func'` removes functions
  * `:version` Shows the rsh version number and the last published gem file version
  * `:help` will display this help text
  
  Background jobs:
  * Use `command &` to run commands in background
  * Use `:jobs` to list active background jobs  
  * Use `:fg` or `:fg job_id` to bring jobs to foreground
  * Use `Ctrl-Z` to suspend running jobs, `:bg job_id` to resume them
  
  Ruby Functions:
  * Define with `:defun 'myls(*args) = Dir.glob("*").each {|f| puts f}'`
  * Call like any shell command: `myls` or `myls arg1 arg2`
  * Functions have full access to Ruby stdlib and rsh internals
  * Remove with `:defun '-myls'` and list with `:defun?`
  
HELP

# GENERIC FUNCTIONS
def firstrun
  puts @help
  puts "Since there is no rsh configuration file (.rshrc), I will help you set it up to suit your needs.\n\n"
  puts "The prompt you see now is the very basic rsh prompt:"
  print "#{@prompt} (press ENTER)"
  $stdin.gets
  puts "\nI will now change the prompt into something more useful."
  puts "Feel free to amend the prompt in your .rshrc.\n\n"
  rc = <<~RSHRC
  # PROMPT
  # The numbers in parenthesis are 256 color codes (the '.c()' is a String extention
  # to color text in the terminal. Add '.b' for bold and '.i' for italics.
  @prompt = "\#{@user}@\#{@node}".c(46) + ":".c(255) + " \#{Dir.pwd}/".c(196) + " ".c(7)

  # THEME
  @c_prompt    = 196  # Color for basic prompt
  @c_cmd       = 48   # Color for valid command
  @c_nick      = 51   # Color for matching nick
  @c_gnick     = 87   # Color for matching gnick
  @c_path      = 208  # Color for valid path
  @c_switch    = 148  # Color for switches/options
  @c_tabselect = 207  # Color for selected tabcompleted item
  @c_taboption = 244  # Color for unselected tabcompleted item
  @c_stamp     = 244  # Color for time stamp/command

  @nick = {"ls"=>"ls --color -F"}
RSHRC
  File.write(Dir.home+'/.rshrc', rc)
end
def getchr # Process key presses
  c = $stdin.getch
  case c
  when "\e"    # ANSI escape sequences (with only ESC, it should stop right here)
    return "ESC" if $stdin.ready? == nil
    case $stdin.getc
    when '['   # CSI
      case $stdin.getc  # Will get (or ASK) for more (remaining part of special character)
      when 'A' then chr = "UP"
      when 'B' then chr = "DOWN"
      when 'C' then chr = "RIGHT"
      when 'D' then chr = "LEFT"
      when 'Z' then chr = "S-TAB"
      when '2' then chr = "INS"    ; chr = "C-INS"    if $stdin.getc == "^"
      when '3' then chr = "DEL"    ; chr = "C-DEL"    if $stdin.getc == "^"
      when '5' then chr = "PgUP"   ; chr = "C-PgUP"   if $stdin.getc == "^"
      when '6' then chr = "PgDOWN" ; chr = "C-PgDOWN" if $stdin.getc == "^"
      when '7' then chr = "HOME"   ; chr = "C-HOME"   if $stdin.getc == "^"
      when '8' then chr = "END"    ; chr = "C-END"    if $stdin.getc == "^"
      else chr = ""
      end
    when 'O'   # Set Ctrl+ArrowKey equal to ArrowKey; May be used for other purposes in the future
      case $stdin.getc
      when 'a' then chr = "C-UP"
      when 'b' then chr = "C-DOWN"
      when 'c' then chr = "C-RIGHT"
      when 'd' then chr = "C-LEFT"
      else chr = ""
      end
    end
  when "", "" then chr = "BACK"
  when "" then chr = "C-C"
  when "" then chr = "C-D"
  when "" then chr = "C-E"
  when "" then chr = "C-G"
  when "" then chr = "C-K"
  when "" then chr = "C-L"
  when "" then chr = "C-N"
  when "" then chr = "C-O"
  when "" then chr = "C-P"
  when "" then chr = "C-T"
  when "" then chr = "C-Y"
  when "" then chr = "WBACK"
  when "\u001A" then chr = "C-Z"
  when "" then chr = "LDEL"
  when "\r" then chr = "ENTER"
  when "\t" then chr = "TAB"
  when /[[:print:]]/  then chr = c
  else chr = ""
  end
  return chr
end
def getstr # A custom Readline-like function
  @stk  = 0
  @pos  = 0
  chr   = ""
  @history.unshift("")
  @row0, p = @c.pos
  while chr != "ENTER" # Keep going with readline until user presses ENTER
    @ci   = nil
    lift  = false
    right = false
    # The actual printing og the command line
    @c.row(@row0)
    @c.clear_line
    print @prompt
    @c.clear_screen_down
    row, @pos0 = @c.pos
    #@history[0] = "" if @history[0].nil?
    print cmd_check(@history[0])
    @ci  = @history[1..].find_index {|e| e =~ /^#{Regexp.escape(@history[0].to_s)}./}
    unless @ci == nil
      @ci += 1
      @ciprompt = @history[@ci][@history[0].to_s.length..].to_s
    end
    if @history[0].to_s.length > 1 and @ci
      print @ciprompt.c(@c_stamp)
      right = true
    end
    c_col = @pos0 + @pos
    c_row = @row0 + c_col/(@maxcol)
    c_col == 0 ? @c.row(c_row + 1) : @c.row(c_row)
    if c_col.modulo(@maxcol) == 0
      @c.col(c_col)
      @c.row(@c.rowget - 1)
    else
      @c.col(c_col.modulo(@maxcol))
    end
    chr = getchr
    case chr
    when 'C-G', 'C-C'
      @history[0] = "" 
      @pos = 0
    when 'C-E'   # Ctrl-C exits gracefully but without updating .rshrc
      print "\n"
      exit
    when 'C-D'   # Ctrl-D exits after updating .rshrc
      rshrc
      exit
    when 'C-L'   # Clear screen and set position to top of the screen
      @c.row(1)
      @row0 = 1
      @c.clear_screen_down
    when 'UP'    # Go up in history
      if @stk == 0 and @history[0].length > 0
        @tabsearch = @history[0]
        tab("hist")
      else
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        unless @stk >= @history.length - 1
          @stk += 1 
          @history[0] = @history[@stk].dup
          @history[0] = "" unless @history[0]
          @pos = @history[0].length
        end
        lift = false
      end
      @c.row(@row0)
      @c.clear_screen_down
    when 'DOWN'  # Go down in history
      if lift
        @history.unshift("")
        @history[0] = @history[@stk].dup
        @stk += 1 
      end
      if @stk == 0
        @history[0] = ""
        @pos = 0
      elsif @stk == 1
        @stk -= 1 
        @history[0] = ""
        @pos = 0
      else
        @stk -= 1 
        @history[0] = @history[@stk].dup
        @pos = @history[0].length
      end
      lift = false
      @c.row(@row0)
      @c.clear_screen_down
    when 'RIGHT' # Move right on the readline
      if right 
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        @history[0] = @history[@ci].dup
        @pos = @history[0].length
      end
      @pos += 1 unless @pos >= @history[0].length
    when 'LEFT'  # Move left on the readline
      @pos -= 1 unless @pos <= 0
    when 'HOME'  # Go to beginning of the readline
      @pos = 0
    when 'END'   # Go to the end of the readline
      @pos = @history[0].length
    when 'DEL'   # Delete one character
      @history[0][@pos] = ""
      lift = true
    when 'BACK'  # Delete one character to the left
      unless @pos <= 0
        @pos -= 1
        @history[0][@pos] = ""
      end
      lift = true
      @c.clear_line_after
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      unless @pos == @pos0
        until @history[0][@pos - 1] == " " or @pos == 0
          @pos -= 1
          @history[0][@pos] = ""
        end
        if @history[0][@pos - 1] == " "
          @pos -= 1
          @history[0][@pos] = ""
        end
      end
      lift = true
      @c.clear_line_after
    when 'C-Y'   # Copy command line to primary selection
      system("echo -n '#{@history[0]}' | xclip")
      puts "\n#{Time.now.strftime("%H:%M:%S")}: Copied to primary selection (paste with middle buttoni)".c(@c_stamp)
    when 'C-Z'   # Suspend current process (background job)
      if @current_pid
        puts "\n[#{@job_id}] Suspended #{@current_pid}"
        Process.kill("STOP", @current_pid)
        @jobs[@job_id] = {pid: @current_pid, cmd: @cmd, status: :stopped}
      else
        puts "\nNo active job to suspend"
      end
    when 'C-K'   # Kill/delete that entry in the history
      @history.delete_at(@stk)
      @stk -= 1
      if @stk == 0
        @history[0] = "" 
        @pos = 0
      else
        @history[0] = @history[@stk].dup
        @history[0] = "" unless @history[0]
        @pos = @history[0].length
      end
    when 'LDEL'  # Delete readline (Ctrl-U)
      @history[0] = ""
      @pos = 0
      lift = true
    when 'TAB'   # Tab completion of dirs and files
      @ci = nil
      #@tabsearch =~ /^-/ ? tabbing("switch") : tabbing("all")
      tab("all")
      lift = true
    when 'S-TAB'
      @ci = nil
      tabbing("hist")
      lift = true
    when /^.$/
      @history[0].insert(@pos,chr)
      @pos += 1
      lift = true
    end
    while $stdin.ready?
      chr = $stdin.getc
      @history[0].insert(@pos,chr)
      @pos += 1
    end
  end
  @c.clear_screen_down
end
def tab(type)
  i = 0
  chr = ""
  @tabarray = []
  @pretab   = @history[0][0...@pos].to_s        # Extract the current line up to cursor
  @postab   = @history[0][@pos..].to_s          # Extract the current line from cursor to end
  @c_row, @c_col = @c.pos                       # Get cursor position
  @row0     = @c_row                            # Save original row
  @tabstr   = @pretab.split(/[|, ]/).last.to_s  # Get the sustring that is being tab completed
  @tabstr   = "" if @pretab[-1] =~ /[ |]/       # Tab from nothing if tabbing starts with space or pipe
  @tabstr   = @pretab if type == "hist"         # Searching for matches with whole string in history
  @pretab   = @pretab.delete_suffix(@tabstr)
  type = "switch" if @tabstr[0] == "-"
  while chr != "ENTER"
    case type
    when "hist"         # Handle history completions ('UP' key)
      @tabarray = @history.select {|el| el =~ /#{@tabstr}/} # Select history items matching @tabstr
      @tabarray.shift   # Take away @history[0]
      return if @tabarray.empty?
    when "switch"
      cmdswitch = @pretab.split(/[|, ]/).last.to_s
      hlp = `#{cmdswitch} --help 2>/dev/null`
      hlp = hlp.split("\n").grep(/^\s*-{1,2}[^-]/)
      hlp = hlp.map{|h| h.sub(/^\s*/, '').sub(/^--/, '    --')}
      hlp = hlp.reject{|h| /-</ =~ h}
      @tabarray = hlp
    when "all"          # Handle all other tab completions
      ex  = []
      ex += @exe
      ex.sort!
      ex.prepend(*@nick.keys)        # Add nicks
      ex.prepend(*@gnick.keys)       # Add gnicks
      compl      = ex.select {|s| s =~ Regexp.new(@tabstr)} # Select only that which matches so far
      fdir       = @tabstr + "*"
      compl.prepend(*Dir.glob(fdir)).map! do |e| 
        if e =~ /(?<!\\) / 
          e = e.sub(/(.*\/|^)(.*)/, '\1\'\2\'') unless  e =~ /'/
        end
        Dir.exist?(e) ? e + "/" : e   # Add matching dirs
      end
      @tabarray = compl               # Finally put it into @tabarray
    end
    return if @tabarray.empty?
    @tabarray.delete("")                                      # Don't remember why
    @c.clear_screen_down                                      # Here we go
    @tabarray.length.to_i - i < 5 ? l = @tabarray.length.to_i - i : l = 5 # Max 5 rows of completion items
    l.times do |x|                                            # Iterate through
      if x == 0                                               # First item goes onto the commandline
        @c.clear_line                                         # Clear the line
        tabchoice = @tabarray[i]                              # Select the item from the @tabarray
        tabchoice = tabchoice.sub(/\s*(-.*?)[,\s].*/, '\1') if type == "switch"
        @newhist0 = @pretab + tabchoice + @postab             # Remember now the new value to be given to @history[0]
        line1     = cmd_check(@pretab).to_s                   # Syntax highlight before @tabstr
        line2     = cmd_check(@postab).to_s                   # Syntax highlight after  @tabstr
        # Color and underline the current tabchoice on the commandline:
        tabline   = tabchoice.sub(/(.*)#{@tabstr}(.*)/, '\1'.c(@c_tabselect) + @tabstr.u.c(@c_tabselect) + '\2'.c(@c_tabselect))
        print @prompt + line1 + tabline + line2               # Print the commandline
        @pos   = @pretab.length.to_i + tabchoice.length.to_i  # Set the position on that commandline
        @c_col = @pos0 + @pos                                 # The cursor position must include the prompt as well
        @c.col(@c_col)                                        # Set the cursor position
        nextline                                              # Then start showing the completion items
        tabline  = @tabarray[i]                               # Get the next matching tabline
        # Can't nest ANSI codes, they must each complete/conclude or they will mess eachother up
        tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_tabselect) # Color the part before the @tabstr
        tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_tabselect) # Color the part after the @tabstr
        print " " + tabline1 + @tabstr.c(@c_tabselect).u + tabline2       # Color & underline @tabstr
      else
        begin
          tabline = @tabarray[i+x]    # Next tabline, and next, etc (usually 4 times here)
          tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_taboption) # Color before @tabstr
          tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_taboption) # Color after @tabstr
          print " " + tabline1 + @tabstr.c(@c_taboption).u + tabline2       # Print the whole line
        rescue
        end
      end
      nextline      # To not run off screen
    end
    @c.row(@c_row)  # Set cursor row to commandline
    @c.col(@c_col)  # Set cursor col on commandline 
    chr = getchr    # Now get user input
    case chr        # Treat the keypress
    when 'C-G', 'C-C', 'ESC'
      tabend; return
    when 'DOWN'
      i += 1 unless i > @tabarray.length.to_i - 2
    when 'UP'
      i -= 1 unless i == 0
    when 'TAB', 'RIGHT'  # Effectively the same as ENTER 
      chr = "ENTER"
    when 'BACK', 'LEFT'  # Delete one character to the left
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.chop!
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.sub!(/#{@tabstr.split(/[|, ]/).last}.*/, '')
    when ' '
      @tabstr += " "
      chr = "ENTER"
    when /^[[:print:]]$/
      @tabstr += chr
      i = 0
    end
  end
  @c.clear_screen_down
  @row0 = @c_row
  @c.row(@c_row)
  @c.col(@c_col)
  @history[0] = @newhist0
end
def nextline # Handle going to the next line in the terminal
  row, col = @c.pos
  if row == @maxrow
    @c.scroll_down
    @c_row -= 1
  end
  @c.next_line
end
def tabend
  @c.clear_screen_down
  @pos = @history[0].length
  @c_col = @pos0 + @pos
  @c.col(@c_col)
end
def hist_clean # Clean up @history
  @history.uniq!
  @history.compact!
  @history.delete("")
end
def cmd_check(str) # Check if each element on the readline matches commands, nicks, paths; color them
  return if str.nil?
  str.gsub(/(?:\S'[^']*'|[^ '])+/) do |el|
    if @exe.include?(el)
      el.c(@c_cmd)
    elsif el == "cd"
      el.c(@c_cmd)
    elsif File.exist?(el.gsub("'", ""))
      el.c(@c_path)
    elsif @nick.include?(el)
      el.c(@c_nick)
    elsif el == "r" or el == "f"
      el.c(@c_nick)
    elsif @gnick.include?(el)
      el.c(@c_gnick)
    elsif self.respond_to?(el) && singleton_class.instance_methods(false).include?(el.to_sym)
      el.c(@c_nick).b  # Ruby functions in bold nick color
    elsif el[0] == "-"
      el.c(@c_switch)
    else
      el
    end
  end
end
def rshrc # Write updates to .rshrc
  hist_clean
  if File.exist?(Dir.home+'/.rshrc')
    conf = File.read(Dir.home+'/.rshrc')
  else
    conf = ""
  end
  conf.sub!(/^@nick.*\n/, "") 
  conf += "@nick = #{@nick}\n"
  conf.sub!(/^@gnick.*\n/, "") 
  conf += "@gnick = #{@gnick}\n"
  conf.sub!(/^@history.*\n/, "") 
  conf += "@history = #{@history.last(@histsize)}\n"
  File.write(Dir.home+'/.rshrc', conf)
  puts "\n.rshrc updated"
end

# RSH FUNCTIONS
def help
  puts @help
end
def version
  puts "rsh version = #{@version} (latest RubyGems version is #{Gem.latest_version_for("ruby-shell").version} - https://github.com/isene/rsh)"
end
def history # Show most recent history (up to 50 entries)
  puts "History:"
  @history.each_with_index {|h,i| puts i.to_s + "; " + h if i < 50}
end
def rmhistory # Delete history
  @history = []
  puts "History deleted."
end
def nick(nick_str)  # Define a new nick like this: `:nick "ls = ls --color"`
  if nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @nick.delete(source)
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @nick[source] = target
  end
  rshrc
end
def gnick(nick_str) # Define a generic/global nick to match not only commands (format like nick)
  if nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @gnick.delete(source)
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @gnick[source] = target
  end
  rshrc
end
def nick? # Show nicks
  puts "  Command nicks:".c(@c_nick)
  @nick.sort.each {|key, value| puts "  #{key} = #{value}"}
  puts "  General nicks:".c(@c_gnick)
  @gnick.sort.each {|key, value| puts "  #{key} = #{value}"}
end
def dirs
  puts "Past direactories:"
  @dirs.each_with_index do |e,i|
    puts "#{i}: #{e}"
  end
end
def jobs
  puts "Active jobs:"
  @jobs.each do |id, job|
    begin
      Process.kill(0, job[:pid])  # Check if process exists
      puts "[#{id}] #{job[:pid]} #{job[:status]} #{job[:cmd]}"
    rescue Errno::ESRCH
      @jobs.delete(id)  # Clean up dead jobs
    end
  end
end
def fg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  puts "Bringing job #{job_id} to foreground: #{job[:cmd]}"
  begin
    if job[:status] == :stopped
      Process.kill("CONT", job[:pid])
    end
    @current_pid = job[:pid]
    Process.wait(job[:pid])
    @jobs.delete(job_id)
    @current_pid = nil
  rescue Errno::ECHILD, Errno::ESRCH
    @jobs.delete(job_id)
    @current_pid = nil
  end
end
def bg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  return puts "Job #{job_id} already running" if job[:status] == :running
  puts "Resuming job #{job_id} in background: #{job[:cmd]}"
  begin
    Process.kill("CONT", job[:pid])
    @jobs[job_id][:status] = :running
  rescue Errno::ESRCH
    @jobs.delete(job_id)
    puts "Job #{job_id} no longer exists"
  end
end
def defun(func_def)  # Define a Ruby function like: `:defun "myls(*args) = Dir.glob('*').each {|f| puts f}"`
  if func_def.match(/^\s*-/)
    # Remove function
    func_name = func_def.sub(/^\s*-/, '')
    if self.respond_to?(func_name)
      singleton_class.remove_method(func_name.to_sym)
      puts "Function '#{func_name}' removed"
    else
      puts "Function '#{func_name}' not found"
    end
  else
    # Define function
    # Extract function name, params, and body from "name(params) = body" format
    if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
      func_name = $1
      func_params = $2
      func_body = $3
      
      begin
        eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
        puts "  DEBUG: Evaluating: #{eval_code}" if ENV['RSH_DEBUG']
        singleton_class.class_eval(eval_code)
        puts "Function '#{func_name}' defined"
        puts "  DEBUG: Method created? #{respond_to?(func_name)}" if ENV['RSH_DEBUG']
      rescue SyntaxError => e
        puts "Syntax error in function definition: #{e}"
      rescue => e
        puts "Error in function definition: #{e}"
      end
    else
      puts "Invalid function format. Use: name(params) = body"
    end
  end
  rshrc
end
def defun?  # Show all user-defined functions
  puts "User-defined Ruby functions:"
  # Get only methods defined by defun, excluding built-ins and rsh internals
  all_methods = singleton_class.instance_methods(false)
  puts "  All singleton methods: #{all_methods}"
  excluded = [:defun, :defun?, :execute_conditional, :expand_braces]
  methods = all_methods - excluded
  if methods.empty?
    puts "  (none defined after filtering)"
  else
    methods.each do |method|
      puts "  #{method}"
    end
  end
end
def execute_conditional(cmd_line)
  # Split on && and || while preserving the operators
  parts = cmd_line.split(/(\s*&&\s*|\s*\|\|\s*)/)
  
  result = true
  i = 0
  while i < parts.length
    command = parts[i].strip
    next if command.empty?
    
    if command == '&&'
      i += 1
      next unless result  # Skip if previous command failed
    elsif command == '||'
      i += 1
      next if result      # Skip if previous command succeeded
    else
      # Execute the command
      success = system(command)
      result = success
      puts " Command failed: #{command} (exit #{$?.exitstatus})" unless success
    end
    i += 1
  end
end
def expand_braces(str)
  # Simple brace expansion: {a,b,c} -> a b c
  str.gsub(/\{([^}]+)\}/) do |match|
    items = $1.split(',').map(&:strip)
    items.join(' ')
  end
end

# INITIAL SETUP
begin # Load .rshrc and populate @history
  trap "SIGINT" do end
  trap "SIGHUP" do 
    rshrc
    exit
  end
  trap "SIGTERM" do 
    rshrc
    exit
  end
  firstrun unless File.exist?(Dir.home+'/.rshrc') # Initial loading - to get history
  load(Dir.home+'/.rshrc')
  # Load login shell files if rsh is running as login shell
  if ENV['LOGIN_SHELL'] or $0 == "-rsh" or ARGV.include?('-l') or ARGV.include?('--login')
    ['/etc/profile', Dir.home+'/.profile', Dir.home+'/.bash_profile', Dir.home+'/.bashrc'].each do |f|
      if File.exist?(f)
        puts "Loading #{f}..." if ENV['RSH_DEBUG']
        begin
          # Source shell files by extracting export statements
          File.readlines(f).each do |line|
            if line =~ /^\s*export\s+(\w+)=(.*)/
              ENV[$1] = $2.gsub(/['"]/, '')
            end
          end
        rescue => e
          puts "Warning: Could not source #{f}: #{e}" if ENV['RSH_DEBUG']
        end
      end
    end
  end 
  ENV["SHELL"] = __FILE__
  ENV["TERM"]  = "rxvt-unicode-256color"
  ENV["PATH"]  ? ENV["PATH"] += ":" : ENV["PATH"] = ""
  ENV["PATH"] += "/home/#{@user}/bin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  if @lscolors and File.exist?(@lscolors)
    ls = File.read(@lscolors) 
    ls.sub!(/export.*/, '')
    ls.sub!(/^LS_COLORS=/, 'ENV["LS_COLORS"]=')
    eval(ls)
  end
  @c = Cursor               # Initiate @c as Cursor
  @c.save                   # Get max row & col
  @c.row(8000)
  @c.col(8000)
  @maxrow, @maxcol = @c.pos
  @c.restore                # Max row & col gotten, cursor restored
  hist_clean                # Remove duplicates, etc
  @path.map! {|p| p + "/*"} # Set proper format for path search
end

# MAIN PART
loop do 
  begin
    @user = Etc.getpwuid(Process.euid).name # For use in @prompt
    @node = Etc.uname[:nodename]            # For use in @prompt
    h = @history; load(Dir.home+'/.rshrc') if File.exist?(Dir.home+'/.rshrc'); @history = h # reload prompt but not history
    @prompt.gsub!(/#{Dir.home}/, '~') # Simplify path in prompt
    system("printf \"\033]0;rsh: #{Dir.pwd}\007\"")   # Set Window title to path 
    @history[0] = "" unless @history[0]
    @exe = []
    @path.each do |p| # Add all executables in @path
      Dir.glob(p).each do |c|
        @exe.append(File.basename(c)) if File.executable?(c) and not Dir.exist?(c)
      end
    end
    getstr # Main work is here
    @cmd = @history[0]
    @dirs.unshift(Dir.pwd)
    @dirs.pop
    hist_clean # Clean up the history
    @cmd = "ls" if @cmd == "" # Default to ls when no command is given
    if @cmd.match(/^!\d+/)
      hi = @history[@cmd.sub(/^!(\d+)$/, '\1').to_i+1] 
      @cmd = hi if hi
    end
    print "\n"; @c.clear_screen_down
    if @cmd == "r" # Integration with rtfm (https://github.com/isene/RTFM)
      t  = Time.now
      t0 = t.nsec.to_s
      tf = "/tmp/.rshpwd" + t0
      File.write(tf, Dir.pwd)
      system("rtfm #{tf}")
      Dir.chdir(File.read(tf))
      File.delete(tf)
      system("git status .") if Dir.exist?(".git")
      next
    end
    if @cmd =~ /^\=/ # Integration with xrpn (https://github.com/isene/xrpn)
      @cmd.gsub!("  ", ",")
      @cmd = "echo \"#{@cmd[1...]},prx,off\" | xrpn" 
    end
    if @cmd.match(/^\s*:/) # Ruby commands are prefixed with ":"
      begin
        eval(@cmd[1..-1])
      #rescue StandardError => err
      rescue Exception => err
        puts "\n#{err}"
      end
    elsif @cmd == '#' # List previous directories
      dirs
    else # Execute command
      # Check if it's a user-defined Ruby function FIRST (before any expansions)
      cmd_parts = @cmd.split(/\s+/)
      func_name = cmd_parts[0]
      if self.respond_to?(func_name) && singleton_class.instance_methods(false).include?(func_name.to_sym)
        begin
          args = cmd_parts[1..]
          puts "DEBUG: Calling #{func_name} with args: #{args}" if ENV['RSH_DEBUG']
          result = self.send(func_name, *args)
          puts "DEBUG: Result: #{result.inspect}" if ENV['RSH_DEBUG']
          puts result unless result.nil?
        rescue => e
          puts "Error calling function '#{func_name}': #{e}"
        end
      else
        # Handle conditional execution (&& and ||)
        if @cmd.include?('&&') || @cmd.include?('||')
          execute_conditional(@cmd)
          next
        end
        # Expand brace expansion {a,b,c}
        @cmd = expand_braces(@cmd)
        # Expand command substitution $(command) and backticks
        @cmd = @cmd.gsub(/\$\(([^)]+)\)/) { `#{$1}`.chomp }
        @cmd = @cmd.gsub(/`([^`]+)`/) { `#{$1}`.chomp }
        # Expand environment variables and exit status
        @cmd = @cmd.gsub(/\$\?/) { @last_exit.to_s }
        @cmd = @cmd.gsub(/\$(\w+)|\$\{(\w+)\}/) { ENV[$1 || $2] || '' }
        # Expand tilde
        @cmd = @cmd.gsub(/~/, Dir.home)
        ca = @nick.transform_keys {|k| /((^\K\s*\K)|(\|\K\s*\K))\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ca.keys), @nick)
        ga = @gnick.transform_keys {|k| /\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ga.keys), @gnick)
        @cmd = "~" if @cmd == "cd"
        @cmd.sub!(/^cd (\S*).*/, '\1')
        @cmd = Dir.home if @cmd == "~"
        @cmd = @dirs[1] if @cmd == "-"
        @cmd = @dirs[@cmd.to_i] if @cmd =~ /^\d$/
        # Check if it's a directory to change to
        dir = @cmd.strip.sub(/~/, Dir.home)
        if Dir.exist?(dir)
          Dir.chdir(dir) 
          system("git status .") if Dir.exist?(".git")
        else
          puts "#{Time.now.strftime("%H:%M:%S")}: #{@cmd}".c(@c_stamp)
          if @cmd == "f" # fzf integration (https://github.com/junegunn/fzf)
            res = `fzf`.chomp
            Dir.chdir(File.dirname(res))
          elsif File.exist?(@cmd) and not File.executable?(@cmd) and not @cmd.include?(" ")
            # Only auto-open files if it's a single filename (no spaces = no command with args)
            if File.read(@cmd).force_encoding("UTF-8").valid_encoding?
              system("#{ENV['EDITOR']} #{@cmd}") # Try open with user's editor
            else
              if @runmailcap
                Thread.new { system("run-mailcap #{@cmd} 2>/dev/null") }
              else
                Thread.new { system("xdg-open #{@cmd} 2>/dev/null") }
              end
            end
          else 
            begin
              pre_cmd
              # Handle background jobs
              if @cmd.end_with?(' &')
                @cmd = @cmd[0..-3]  # Remove the &
                @job_id += 1
                # Handle pipes and redirections in background
                if @cmd.include?('|') || @cmd.include?('>') || @cmd.include?('<')
                  pid = spawn(@cmd, pgroup: true)
                else
                  pid = spawn(@cmd)
                end
                @jobs[@job_id] = {pid: pid, cmd: @cmd, status: :running}
                puts "[#{@job_id}] #{pid} #{@cmd}"
              else
                # Better handling of pipes and redirections  
                @current_pid = spawn(@cmd)
                Process.wait(@current_pid)
                @last_exit = $?.exitstatus
                @current_pid = nil
                puts " Command failed: #{@cmd} (exit #{@last_exit})" unless @last_exit == 0
              end
              post_cmd
            rescue StandardError => err
              puts "\nError: #{err}"
            end
          end
        end
      end
    end
  rescue StandardError => err # Throw error nicely
    puts "\n#{err}"
  end
end

# vim: set sw=2 sts=2 et fdm=syntax fdn=2 fcs=fold\:\ :
