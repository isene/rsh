#!/usr/bin/env ruby
# encoding: utf-8
#
# SCRIPT INFO 
# Name:       rsh - Ruby SHell
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/rsh
# License:    Public domain
@version    = "2.10.1" # Bug fix: Improved && operator logic for proper conditional execution

# MODULES, CLASSES AND EXTENSIONS
class String # Add coloring to strings (with escaping for Readline)
  def c(code);  color(self, "\001\e[38;5;#{code}m\002"); end  # Color code
  def b;        color(self, "\001\e[1m\002"); end             # Bold
  def i;        color(self, "\001\e[3m\002"); end             # Italic
  def u;        color(self, "\001\e[4m\002"); end             # Underline
  def l;        color(self, "\001\e[5m\002"); end             # Blink
  def r;        color(self, "\001\e[7m\002"); end             # Reverse
  def color(text, color_code)  "#{color_code}#{text}\001\e[0m\002" end
end
module Cursor # Terminal cursor movement ANSI codes (thanks to https://github.com/piotrmurach/tty-cursor)
  module_function
  ESC = "\e".freeze
  CSI = "\e[".freeze
  def save # Save current position
    print(Gem.win_platform? ? CSI + 's' : ESC + '7')
  end
  def restore # Restore cursor position
    print(Gem.win_platform? ? CSI + 'u' : ESC + '8')
  end
  def pos # Query cursor current position
    res = ''
    begin
      $stdin.raw do |stdin|
        $stdout << CSI + '6n' # Tha actual ANSI get-position
        $stdout.flush
        while (c = stdin.getc) != 'R'
          res << c if c
      end
      end
    rescue Errno::ENOTTY
      # Not a TTY, return default values
      return 25, 80
    end
    m = res.match /(?<row>\d+);(?<col>\d+)/
    return m ? [m[:row].to_i, m[:col].to_i] : [25, 80]
  end
  def rowget
    row, col = self.pos
    return row
  end
  def colget
    row, col = self.pos
    return col
  end
  def col(n = nil) # Cursor moves to nth position horizontally in the current line
    print(CSI + "#{n || 1}G")
  end
  def row(n = nil) # Cursor moves to the nth position vertically in the current column
    print(CSI + "#{n || 1}d")
  end
  def next_line # Move cursor down to beginning of next line
    print(CSI + 'E' + CSI + "1G")
  end
  def clear_line # Erase the entire current line and return to beginning of the line
    print(CSI + '2K' +  CSI + "1G")
  end
  def clear_line_after # Erase from the current position (inclusive) to the end of the line
    print(CSI + '0K')
  end
  def scroll_down # Scroll display down one line
    print(ESC + 'D')
  end
  def clear_screen_down
    print(CSI + 'J')
  end
end

# INITIALIZATION
begin # Requires
  require 'etc'
  require 'io/console'
  require 'io/wait'
end
begin # Initialization
  # Theming
  @c_prompt    = 10                       # Color for basic prompt
  @c_cmd       = 2                        # Color for valid command
  @c_nick      = 6                        # Color for matching nick
  @c_gnick     = 14                       # Color for matching gnick
  @c_path      = 3                        # Color for valid path
  @c_switch    = 6                        # Color for switches/options
  @c_tabselect = 5                        # Color for selected tabcompleted item
  @c_taboption = 244                      # Color for unselected tabcompleted item
  @c_stamp     = 244                      # Color for time stamp/command
  # Prompt
  @prompt      = "rsh > ".c(@c_prompt).b  # Very basic prompt if not defined in .rshrc
  # Hash & array initializations
  @nick        = {}                       # Initiate alias/nick hash
  @gnick       = {}                       # Initiate generic/global alias/nick hash
  @history     = []                       # Initiate history array
  @exe = []
  # Paths
  @user = Etc.getpwuid(Process.euid).name # For use in @prompt
  @path        = ENV["PATH"].split(":")   # Get paths
  # History
  @histsize    = 200                      # Max history if not set in .rshrc
  @hloaded     = false                    # Variable to determine if history is loaded
  # Use run-mailcap instead of xgd-open? Set "= true" in .rshrc if you want run-mailcap
  @runmailcap  = false
  # Variable initializations
  @dirs        = ["."]*10
  @jobs        = {}                       # Background jobs tracking
  @job_id      = 0                        # Job counter
  @ai_suggestion = nil                    # Store AI command suggestion
  @last_exit   = 0                        # Last command exit status
  def pre_cmd; end                        # User-defined function to be run BEFORE command execution
  def post_cmd; end                       # User-defined function to be run AFTER  command execution
end

# HELP TEXT
@info = <<~INFO

  Hello #{@user}, welcome to rsh - the Ruby SHell. 
  
  rsh does not attempt to compete with the grand old shells like bash and zsh. 
  It serves the specific needs and wants of its author. If you like it, then feel free 
  to ask for more or different features here: https://github.com/isene/rsh.
  
  Features:
  * Aliases (called nicks in rsh) - both for commands and general nicks
  * Syntax highlighting, matching nicks, system commands and valid dirs/files
  * Tab completions for nicks, system commands, command switches and dirs/files
  * Tab completion presents matches in a list to pick from
  * When you start to write a command, rsh will suggest the first match in the history and
    present that in "toned down" letters - press the arrow right key to accept the suggestion
  * Writing a partial command and pressing `UP` will search history for matches.
    Go down/up in the list and press `TAB` or `ENTER` to accept, `Ctrl-g` or `Ctrl-c` to discard
  * History with editing, search and repeat a history command (with `!`)
  * Config file (.rshrc) updates on exit (with Ctrl-d) or not (with Ctrl-e)
  * Set of simple rsh specific commands like nick, nick?, history and rmhistory
  * rsh specific commands and full set of Ruby commands available via :<command>
  * All colors are themeable in .rshrc (see github link for possibilities)
  * Copy current command line to primary selection (paste w/middle button) with `Ctrl-y`
  * AI integration: Use @ for text responses and @@ for command suggestions (requires ollama or OpenAI)
  
  Use `:help` for command reference.
  
INFO

@help = <<~HELP

HELP

# GENERIC FUNCTIONS
def firstrun
  puts @info
  puts "Since there is no rsh configuration file (.rshrc), I will help you set it up to suit your needs.\n\n"
  puts "The prompt you see now is the very basic rsh prompt:"
  print "#{@prompt} (press ENTER)"
  $stdin.gets
  puts "\nI will now change the prompt into something more useful."
  puts "Feel free to amend the prompt in your .rshrc.\n\n"
  rc = <<~RSHRC
  # PROMPT
  # The numbers in parenthesis are 256 color codes (the '.c()' is a String extention
  # to color text in the terminal. Add '.b' for bold and '.i' for italics.
  @prompt = "\#{@user}@\#{@node}".c(46) + ":".c(255) + " \#{Dir.pwd}/".c(196) + " ".c(7)

  # THEME
  @c_prompt    = 196  # Color for basic prompt
  @c_cmd       = 48   # Color for valid command
  @c_nick      = 51   # Color for matching nick
  @c_gnick     = 87   # Color for matching gnick
  @c_path      = 208  # Color for valid path
  @c_switch    = 148  # Color for switches/options
  @c_tabselect = 207  # Color for selected tabcompleted item
  @c_taboption = 244  # Color for unselected tabcompleted item
  @c_stamp     = 244  # Color for time stamp/command

  @nick = {"ls"=>"ls --color -F"}
RSHRC
  File.write(Dir.home+'/.rshrc', rc)
end
def getchr # Process key presses
  c = $stdin.getch
  case c
  when "\e"    # ANSI escape sequences (with only ESC, it should stop right here)
    return "ESC" if $stdin.ready? == nil
    case $stdin.getc
    when '['   # CSI
      case $stdin.getc  # Will get (or ASK) for more (remaining part of special character)
      when 'A' then chr = "UP"
      when 'B' then chr = "DOWN"
      when 'C' then chr = "RIGHT"
      when 'D' then chr = "LEFT"
      when 'Z' then chr = "S-TAB"
      when '2' then chr = "INS"    ; chr = "C-INS"    if $stdin.getc == "^"
      when '3' then chr = "DEL"    ; chr = "C-DEL"    if $stdin.getc == "^"
      when '5' then chr = "PgUP"   ; chr = "C-PgUP"   if $stdin.getc == "^"
      when '6' then chr = "PgDOWN" ; chr = "C-PgDOWN" if $stdin.getc == "^"
      when '7' then chr = "HOME"   ; chr = "C-HOME"   if $stdin.getc == "^"
      when '8' then chr = "END"    ; chr = "C-END"    if $stdin.getc == "^"
      else chr = ""
      end
    when 'O'   # Set Ctrl+ArrowKey equal to ArrowKey; May be used for other purposes in the future
      case $stdin.getc
      when 'a' then chr = "C-UP"
      when 'b' then chr = "C-DOWN"
      when 'c' then chr = "C-RIGHT"
      when 'd' then chr = "C-LEFT"
      else chr = ""
      end
    end
  when "", "" then chr = "BACK"
  when "" then chr = "C-C"
  when "" then chr = "C-D"
  when "" then chr = "C-E"
  when "" then chr = "C-G"
  when "" then chr = "C-K"
  when "" then chr = "C-L"
  when "" then chr = "C-N"
  when "" then chr = "C-O"
  when "" then chr = "C-P"
  when "" then chr = "C-T"
  when "" then chr = "C-Y"
  when "" then chr = "WBACK"
  when "\u001A" then chr = "C-Z"
  when "" then chr = "LDEL"
  when "\r" then chr = "ENTER"
  when "\t" then chr = "TAB"
  when /[[:print:]]/  then chr = c
  else chr = ""
  end
  return chr
end
def getstr # A custom Readline-like function
  @stk  = 0
  @pos  = 0
  chr   = ""
  @history.unshift("")
  # Check if we have an AI suggestion to pre-fill
  if @ai_suggestion
    @history[0] = @ai_suggestion
    @pos = @ai_suggestion.length
    @ai_suggestion = nil
  end
  @row0, p = @c.pos
  while chr != "ENTER" # Keep going with readline until user presses ENTER
    @ci   = nil
    lift  = false
    right = false
    # The actual printing og the command line
    @c.row(@row0)
    @c.clear_line
    print @prompt
    @c.clear_screen_down
    row, @pos0 = @c.pos
    #@history[0] = "" if @history[0].nil?
    print cmd_check(@history[0])
    @ci  = @history[1..].find_index {|e| e =~ /^#{Regexp.escape(@history[0].to_s)}./}
    unless @ci == nil
      @ci += 1
      @ciprompt = @history[@ci][@history[0].to_s.length..].to_s
    end
    if @history[0].to_s.length > 1 and @ci
      print @ciprompt.c(@c_stamp)
      right = true
    end
    c_col = @pos0 + @pos
    c_row = @row0 + c_col/(@maxcol)
    c_col == 0 ? @c.row(c_row + 1) : @c.row(c_row)
    if c_col.modulo(@maxcol) == 0
      @c.col(c_col)
      @c.row(@c.rowget - 1)
    else
      @c.col(c_col.modulo(@maxcol))
    end
    chr = getchr
    case chr
    when 'C-G', 'C-C'
      @history[0] = "" 
      @pos = 0
    when 'C-E'   # Ctrl-C exits gracefully but without updating .rshrc
      print "\n"
      exit
    when 'C-D'   # Ctrl-D exits after updating .rshrc
      rshrc
      exit
    when 'C-L'   # Clear screen and set position to top of the screen
      @c.row(1)
      @row0 = 1
      @c.clear_screen_down
    when 'UP'    # Go up in history
      if @stk == 0 and @history[0].length > 0
        @tabsearch = @history[0]
        tab("hist")
      else
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        unless @stk >= @history.length - 1
          @stk += 1 
          @history[0] = @history[@stk].dup
          @history[0] = "" unless @history[0]
          @pos = @history[0].length
        end
        lift = false
      end
      @c.row(@row0)
      @c.clear_screen_down
    when 'DOWN'  # Go down in history
      if lift
        @history.unshift("")
        @history[0] = @history[@stk].dup
        @stk += 1 
      end
      if @stk == 0
        @history[0] = ""
        @pos = 0
      elsif @stk == 1
        @stk -= 1 
        @history[0] = ""
        @pos = 0
      else
        @stk -= 1 
        @history[0] = @history[@stk].dup
        @pos = @history[0].length
      end
      lift = false
      @c.row(@row0)
      @c.clear_screen_down
    when 'RIGHT' # Move right on the readline
      if right 
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        @history[0] = @history[@ci].dup
        @pos = @history[0].length
      end
      @pos += 1 unless @pos >= @history[0].length
    when 'LEFT'  # Move left on the readline
      @pos -= 1 unless @pos <= 0
    when 'HOME'  # Go to beginning of the readline
      @pos = 0
    when 'END'   # Go to the end of the readline
      @pos = @history[0].length
    when 'DEL'   # Delete one character
      @history[0][@pos] = ""
      lift = true
    when 'BACK'  # Delete one character to the left
      unless @pos <= 0
        @pos -= 1
        @history[0][@pos] = ""
      end
      lift = true
      @c.clear_line_after
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      unless @pos == @pos0
        until @history[0][@pos - 1] == " " or @pos == 0
          @pos -= 1
          @history[0][@pos] = ""
        end
        if @history[0][@pos - 1] == " "
          @pos -= 1
          @history[0][@pos] = ""
        end
      end
      lift = true
      @c.clear_line_after
    when 'C-Y'   # Copy command line to primary selection
      system("echo -n '#{@history[0]}' | xclip")
      puts "\n#{Time.now.strftime("%H:%M:%S")}: Copied to primary selection (paste with middle buttoni)".c(@c_stamp)
    when 'C-Z'   # Suspend current process (background job)
      if @current_pid
        puts "\n[#{@job_id}] Suspended #{@current_pid}"
        Process.kill("STOP", @current_pid)
        @jobs[@job_id] = {pid: @current_pid, cmd: @cmd, status: :stopped}
      else
        puts "\nNo active job to suspend"
      end
    when 'C-K'   # Kill/delete that entry in the history
      @history.delete_at(@stk)
      @stk -= 1
      if @stk == 0
        @history[0] = "" 
        @pos = 0
      else
        @history[0] = @history[@stk].dup
        @history[0] = "" unless @history[0]
        @pos = @history[0].length
      end
    when 'LDEL'  # Delete readline (Ctrl-U)
      @history[0] = ""
      @pos = 0
      lift = true
    when 'TAB'   # Tab completion of dirs and files
      @ci = nil
      #@tabsearch =~ /^-/ ? tabbing("switch") : tabbing("all")
      tab("all")
      lift = true
    when 'S-TAB'
      @ci = nil
      tabbing("hist")
      lift = true
    when /^.$/
      @history[0].insert(@pos,chr)
      @pos += 1
      lift = true
    end
    while $stdin.ready?
      chr = $stdin.getc
      @history[0].insert(@pos,chr)
      @pos += 1
    end
  end
  @c.clear_screen_down
end
def tab(type)
  i = 0
  chr = ""
  @tabarray = []
  @pretab   = @history[0][0...@pos].to_s        # Extract the current line up to cursor
  @postab   = @history[0][@pos..].to_s          # Extract the current line from cursor to end
  @c_row, @c_col = @c.pos                       # Get cursor position
  @row0     = @c_row                            # Save original row
  @tabstr   = @pretab.split(/[|, ]/).last.to_s  # Get the sustring that is being tab completed
  @tabstr   = "" if @pretab[-1] =~ /[ |]/       # Tab from nothing if tabbing starts with space or pipe
  @tabstr   = @pretab if type == "hist"         # Searching for matches with whole string in history
  @pretab   = @pretab.delete_suffix(@tabstr)
  type = "switch" if @tabstr[0] == "-"
  while chr != "ENTER"
    case type
    when "hist"         # Handle history completions ('UP' key)
      @tabarray = @history.select {|el| el =~ /#{@tabstr}/} # Select history items matching @tabstr
      @tabarray.shift   # Take away @history[0]
      return if @tabarray.empty?
    when "switch"
      cmdswitch = @pretab.split(/[|, ]/).last.to_s
      hlp = `#{cmdswitch} --help 2>/dev/null`
      hlp = hlp.split("\n").grep(/^\s*-{1,2}[^-]/)
      hlp = hlp.map{|h| h.sub(/^\s*/, '').sub(/^--/, '    --')}
      hlp = hlp.reject{|h| /-</ =~ h}
      @tabarray = hlp
    when "all"          # Handle all other tab completions
      ex  = []
      ex += @exe
      ex.sort!
      ex.prepend(*@nick.keys)        # Add nicks
      ex.prepend(*@gnick.keys)       # Add gnicks
      compl      = ex.select {|s| s =~ Regexp.new(@tabstr)} # Select only that which matches so far
      fdir       = @tabstr + "*"
      compl.prepend(*Dir.glob(fdir)).map! do |e| 
        if e =~ /(?<!\\) / 
          e = e.sub(/(.*\/|^)(.*)/, '\1\'\2\'') unless  e =~ /'/
        end
        Dir.exist?(e) ? e + "/" : e   # Add matching dirs
      end
      @tabarray = compl               # Finally put it into @tabarray
    end
    return if @tabarray.empty?
    @tabarray.delete("")                                      # Don't remember why
    @c.clear_screen_down                                      # Here we go
    @tabarray.length.to_i - i < 5 ? l = @tabarray.length.to_i - i : l = 5 # Max 5 rows of completion items
    l.times do |x|                                            # Iterate through
      if x == 0                                               # First item goes onto the commandline
        @c.clear_line                                         # Clear the line
        tabchoice = @tabarray[i]                              # Select the item from the @tabarray
        tabchoice = tabchoice.sub(/\s*(-.*?)[,\s].*/, '\1') if type == "switch"
        @newhist0 = @pretab + tabchoice + @postab             # Remember now the new value to be given to @history[0]
        line1     = cmd_check(@pretab).to_s                   # Syntax highlight before @tabstr
        line2     = cmd_check(@postab).to_s                   # Syntax highlight after  @tabstr
        # Color and underline the current tabchoice on the commandline:
        tabline   = tabchoice.sub(/(.*)#{@tabstr}(.*)/, '\1'.c(@c_tabselect) + @tabstr.u.c(@c_tabselect) + '\2'.c(@c_tabselect))
        print @prompt + line1 + tabline + line2               # Print the commandline
        @pos   = @pretab.length.to_i + tabchoice.length.to_i  # Set the position on that commandline
        @c_col = @pos0 + @pos                                 # The cursor position must include the prompt as well
        @c.col(@c_col)                                        # Set the cursor position
        nextline                                              # Then start showing the completion items
        tabline  = @tabarray[i]                               # Get the next matching tabline
        # Can't nest ANSI codes, they must each complete/conclude or they will mess eachother up
        tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_tabselect) # Color the part before the @tabstr
        tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_tabselect) # Color the part after the @tabstr
        print " " + tabline1 + @tabstr.c(@c_tabselect).u + tabline2       # Color & underline @tabstr
      else
        begin
          tabline = @tabarray[i+x]    # Next tabline, and next, etc (usually 4 times here)
          tabline1 = tabline.sub(/(.*?)#{@tabstr}.*/, '\1').c(@c_taboption) # Color before @tabstr
          tabline2 = tabline.sub(/.*?#{@tabstr}(.*)/, '\1').c(@c_taboption) # Color after @tabstr
          print " " + tabline1 + @tabstr.c(@c_taboption).u + tabline2       # Print the whole line
        rescue
        end
      end
      nextline      # To not run off screen
    end
    @c.row(@c_row)  # Set cursor row to commandline
    @c.col(@c_col)  # Set cursor col on commandline 
    chr = getchr    # Now get user input
    case chr        # Treat the keypress
    when 'C-G', 'C-C', 'ESC'
      tabend; return
    when 'DOWN'
      i += 1 unless i > @tabarray.length.to_i - 2
    when 'UP'
      i -= 1 unless i == 0
    when 'TAB', 'RIGHT'  # Effectively the same as ENTER 
      chr = "ENTER"
    when 'BACK', 'LEFT'  # Delete one character to the left
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.chop!
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.sub!(/#{@tabstr.split(/[|, ]/).last}.*/, '')
    when ' '
      @tabstr += " "
      chr = "ENTER"
    when /^[[:print:]]$/
      @tabstr += chr
      i = 0
    end
  end
  @c.clear_screen_down
  @row0 = @c_row
  @c.row(@c_row)
  @c.col(@c_col)
  @history[0] = @newhist0
end
def nextline # Handle going to the next line in the terminal
  row, col = @c.pos
  if row == @maxrow
    @c.scroll_down
    @c_row -= 1
  end
  @c.next_line
end
def tabend
  @c.clear_screen_down
  @pos = @history[0].length
  @c_col = @pos0 + @pos
  @c.col(@c_col)
end
def hist_clean # Clean up @history
  @history.uniq!
  @history.compact!
  @history.delete("")
end
def cmd_check(str) # Check if each element on the readline matches commands, nicks, paths; color them
  return if str.nil?

  # Special handling for @ and @@ commands
  if str =~ /^(@@?)\s+(.*)$/
    prefix = $1
    rest = $2
    return prefix.c(4) + " " + rest  # Color @ or @@ in blue (4), rest uncolored
  end

  str.gsub(/(?:\S'[^']*'|[^ '])+/) do |el|
    clean_el = el.gsub("'", "")
    if @exe.include?(el)
      el.c(@c_cmd)
    elsif el == "cd"
      el.c(@c_cmd)
    elsif clean_el =~ /^\.\/(.+)/ && File.exist?(clean_el) && File.executable?(clean_el)
      # Color local executables starting with ./
      el.c(@c_cmd)
    elsif File.exist?(clean_el)
      el.c(@c_path)
    elsif @nick.include?(el)
      el.c(@c_nick)
    elsif el == "r" or el == "f"
      el.c(@c_nick)
    elsif @gnick.include?(el)
      el.c(@c_gnick)
    elsif self.respond_to?(el) && singleton_class.instance_methods(false).include?(el.to_sym)
      el.c(@c_nick).b  # Ruby functions in bold nick color
    elsif el[0] == "-"
      el.c(@c_switch)
    else
      el
    end
  end
end
def rshrc # Write updates to .rshrc
  hist_clean
  if File.exist?(Dir.home+'/.rshrc')
    conf = File.read(Dir.home+'/.rshrc')
  else
    conf = ""
  end
  conf.sub!(/^@nick.*\n/, "")
  conf += "@nick = #{@nick}\n"
  conf.sub!(/^@gnick.*\n/, "")
  conf += "@gnick = #{@gnick}\n"
  conf.sub!(/^@history.*\n/, "")
  # Ensure history is properly formatted as valid Ruby array
  begin
    history_str = @history.last(@histsize).inspect
    conf += "@history = #{history_str}\n"
  rescue => e
    conf += "@history = []\n"
    puts "Warning: Error saving history: #{e.message}"
  end
  File.write(Dir.home+'/.rshrc', conf)
  puts "\n.rshrc updated"
end

# RSH FUNCTIONS
def help
  # Get terminal width
  term_width = @maxcol || 80
  col_width = 48  # Fixed width for left column
  
  # Helper function to strip ANSI codes for length calculation
  def strip_ansi(str)
    str.gsub(/\001?\e\[[0-9;]*m\002?/, '')
  end
  
  left_col = []
  right_col = []
  
  # Left column content
  left_col << "KEYBOARD SHORTCUTS:".c(@c_prompt).b
  left_col << "RIGHT/Ctrl-F    Accept suggestion"
  left_col << "UP/DOWN         Navigate history"
  left_col << "TAB             Tab complete"
  left_col << "Ctrl-Y          Copy to clipboard"
  left_col << "Ctrl-D          Exit + save .rshrc"
  left_col << "Ctrl-E          Exit without save"
  left_col << "Ctrl-L          Clear screen"
  left_col << "Ctrl-Z          Suspend job"
  left_col << "Ctrl-C/G        Clear line"
  left_col << "Ctrl-K          Delete history item"
  left_col << "Ctrl-U          Clear line"
  left_col << "Ctrl-W          Delete previous word"
  left_col << ""
  left_col << "SPECIAL COMMANDS:".c(@c_prompt).b
  left_col << ":nick 'll = ls -l'  Command alias"
  left_col << ":gnick 'h = /home'  General alias"
  left_col << ":nickdel 'name'     Delete nick"
  left_col << ":gnickdel 'name'    Delete gnick"
  left_col << ":nick?              List all nicks"
  left_col << ":history            Show history"
  left_col << ":rmhistory          Clear history"
  left_col << ":info               About rsh"
  left_col << ":version            Version info"
  left_col << ":help               This help"
  
  # Right column content
  right_col << "RUBY FUNCTIONS:".c(@c_prompt).b
  right_col << ":defun 'f(x) = x*2' Define function"
  right_col << ":defun?             List functions"
  right_col << ":defun '-f'         Remove function"
  right_col << "Call as: f 5        (returns 10)"
  right_col << ""
  right_col << "JOB CONTROL:".c(@c_prompt).b
  right_col << "command &           Background job"
  right_col << ":jobs               List jobs"
  right_col << ":fg [id]            Foreground job"
  right_col << ":bg [id]            Resume in bg"
  right_col << ""
  right_col << "INTEGRATIONS:".c(@c_prompt).b
  right_col << "r                   Launch rtfm"
  right_col << "f                   Launch fzf"
  right_col << "= <expr>            xrpn calculator"
  right_col << ":<ruby code>        Execute Ruby"
  right_col << ""
  right_col << "AI FEATURES:".c(@c_prompt).b
  right_col << "@ <question>        AI text response"
  right_col << "@@ <request>        AI command â†’ prompt"
  right_col << ""
  right_col << "EXPANSIONS:".c(@c_prompt).b
  right_col << "~                   Home directory"
  right_col << "$VAR, ${VAR}        Environment var"
  right_col << "$?                  Exit status"
  right_col << "$(cmd), `cmd`       Command subst"
  right_col << "{a,b,c}             Brace expansion"
  right_col << "cmd1 && cmd2        Conditional"
  right_col << "cmd1 || cmd2        Alternative"
  
  # Pad columns to same length
  max_lines = [left_col.length, right_col.length].max
  left_col.fill("", left_col.length...max_lines)
  right_col.fill("", right_col.length...max_lines)
  
  # Print in two columns
  puts
  max_lines.times do |i|
    left_text = left_col[i].to_s
    right_text = right_col[i].to_s
    # Calculate padding based on visible characters (without ANSI codes)
    visible_length = strip_ansi(left_text).length
    padding = col_width - visible_length
    padding = 0 if padding < 0
    puts "  #{left_text}#{' ' * padding} #{right_text}"
  end
  puts
end
def info
  puts @info
end
def version
  puts "rsh version = #{@version} (latest RubyGems version is #{Gem.latest_version_for("ruby-shell").version} - https://github.com/isene/rsh)"
end
def history # Show most recent history (up to 50 entries)
  puts "History:"
  @history.each_with_index {|h,i| puts i.to_s + "; " + h if i < 50}
end
def rmhistory # Delete history
  @history = []
  puts "History deleted."
end
def nick(nick_str)  # Define a new nick like this: `:nick "ls = ls --color"`
  if nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @nick.delete(source)
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @nick[source] = target
  end
  rshrc
end
def gnick(nick_str) # Define a generic/global nick to match not only commands (format like nick)
  if nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    @gnick.delete(source)
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @gnick[source] = target
  end
  rshrc
end
def nick? # Show nicks
  puts "  Command nicks:".c(@c_nick)
  @nick.sort.each {|key, value| puts "  #{key} = #{value}"}
  puts "  General nicks:".c(@c_gnick)
  @gnick.sort.each {|key, value| puts "  #{key} = #{value}"}
end
def nickdel(nick_name) # Delete a command nick
  @nick.delete(nick_name)
  rshrc
  puts "Nick '#{nick_name}' deleted"
end
def gnickdel(nick_name) # Delete a general/global nick
  @gnick.delete(nick_name)
  rshrc
  puts "General nick '#{nick_name}' deleted"
end
def dirs
  puts "Past direactories:"
  @dirs.each_with_index do |e,i|
    puts "#{i}: #{e}"
  end
end
def jobs
  puts "Active jobs:"
  @jobs.each do |id, job|
    begin
      Process.kill(0, job[:pid])  # Check if process exists
      puts "[#{id}] #{job[:pid]} #{job[:status]} #{job[:cmd]}"
    rescue Errno::ESRCH
      @jobs.delete(id)  # Clean up dead jobs
    end
  end
end
def fg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  puts "Bringing job #{job_id} to foreground: #{job[:cmd]}"
  begin
    if job[:status] == :stopped
      Process.kill("CONT", job[:pid])
    end
    @current_pid = job[:pid]
    Process.wait(job[:pid])
    @jobs.delete(job_id)
    @current_pid = nil
  rescue Errno::ECHILD, Errno::ESRCH
    @jobs.delete(job_id)
    @current_pid = nil
  end
end
def bg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  return puts "Job #{job_id} already running" if job[:status] == :running
  puts "Resuming job #{job_id} in background: #{job[:cmd]}"
  begin
    Process.kill("CONT", job[:pid])
    @jobs[job_id][:status] = :running
  rescue Errno::ESRCH
    @jobs.delete(job_id)
    puts "Job #{job_id} no longer exists"
  end
end
def defun(func_def)  # Define a Ruby function like: `:defun "myls(*args) = Dir.glob('*').each {|f| puts f}"`
  if func_def.match(/^\s*-/)
    # Remove function
    func_name = func_def.sub(/^\s*-/, '')
    if self.respond_to?(func_name)
      singleton_class.remove_method(func_name.to_sym)
      puts "Function '#{func_name}' removed"
    else
      puts "Function '#{func_name}' not found"
    end
  else
    # Define function
    # Extract function name, params, and body from "name(params) = body" format
    if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
      func_name = $1
      func_params = $2
      func_body = $3
      
      begin
        eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
        puts "  DEBUG: Evaluating: #{eval_code}" if ENV['RSH_DEBUG']
        singleton_class.class_eval(eval_code)
        puts "Function '#{func_name}' defined"
        puts "  DEBUG: Method created? #{respond_to?(func_name)}" if ENV['RSH_DEBUG']
      rescue SyntaxError => e
        puts "Syntax error in function definition: #{e}"
      rescue => e
        puts "Error in function definition: #{e}"
      end
    else
      puts "Invalid function format. Use: name(params) = body"
    end
  end
  rshrc
end
def defun?  # Show all user-defined functions
  puts "User-defined Ruby functions:"
  # Get only methods defined by defun, excluding built-ins and rsh internals
  all_methods = singleton_class.instance_methods(false)
  puts "  All singleton methods: #{all_methods}"
  excluded = [:defun, :defun?, :execute_conditional, :expand_braces]
  methods = all_methods - excluded
  if methods.empty?
    puts "  (none defined after filtering)"
  else
    methods.each do |method|
      puts "  #{method}"
    end
  end
end
def execute_conditional(cmd_line)
  # Split on && and || while preserving the operators
  parts = cmd_line.split(/(\s*&&\s*|\s*\|\|\s*)/)

  result = nil  # Start with nil to handle first command
  i = 0

  while i < parts.length
    part = parts[i].strip
    i += 1
    next if part.empty?

    if part == '&&'
      # If previous command failed, skip the rest until we find || or end
      unless result
        while i < parts.length && parts[i].strip != '||'
          i += 1
        end
      end
    elsif part == '||'
      # If previous command succeeded, skip the rest until we find && or end
      if result
        while i < parts.length && parts[i].strip != '&&'
          i += 1
        end
      end
    else
      # Execute the command
      success = system(part)
      result = success
      @last_exit = $?.exitstatus
      puts " Command failed: #{part} (exit #{@last_exit})" unless success
    end
  end

  result
end
def expand_braces(str)
  # Simple brace expansion: {a,b,c} -> a b c
  str.gsub(/\{([^}]+)\}/) do |match|
    items = $1.split(',').map(&:strip)
    items.join(' ')
  end
end

# AI INTEGRATION FUNCTIONS
def get_ollama_model
  begin
    # Try to get list of available models
    output = `ollama list 2>/dev/null`
    return nil if output.empty? || $?.exitstatus != 0
    
    # Parse the output to find a suitable model
    lines = output.split("\n")
    return nil if lines.length < 2
    
    # Skip header line and get first available model
    model_line = lines[1]
    return nil if model_line.nil?
    
    # Extract model name (first column)
    model_name = model_line.split(/\s+/)[0]
    return model_name
  rescue => e
    return nil
  end
end

def ai_query(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        return ai_setup_help unless ollama_model
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: prompt,
          stream: false,
          options: {
            num_predict: 200
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['response']
        else
          return ai_setup_help
        end
      rescue => e
        return ai_setup_help
      end
    else
      return ai_setup_help
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: prompt}],
          max_tokens: 200,
          temperature: 0.7
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['choices'][0]['message']['content']
        else
          return "Error: #{response.code} - #{response.body}"
        end
      rescue => e
        return "Error connecting to OpenAI: #{e.message}"
      end
    else
      return "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
    end
  end
end

def ai_command_suggest(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  # Modify prompt to request command output
  cmd_prompt = "You are a Linux/Unix command line expert. Given this request: '#{prompt}', output ONLY the exact shell command that would accomplish this task. Output just the command itself with no explanation, no backticks, no markdown. For example, if asked 'list files' you would output: ls"
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        unless ollama_model
          puts ai_setup_help
          return nil
        end
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: cmd_prompt,
          stream: false,
          options: {
            num_predict: 50,
            temperature: 0.3
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['response'].strip.split("\n")[0]
          return cmd
        else
          puts ai_setup_help
          return nil
        end
      rescue => e
        puts ai_setup_help
        return nil
      end
    else
      puts ai_setup_help
      return nil
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: cmd_prompt}],
          max_tokens: 50,
          temperature: 0.3
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['choices'][0]['message']['content'].strip.split("\n")[0]
          return cmd
        else
          puts "Error: #{response.code} - #{response.body}"
          return nil
        end
      rescue => e
        puts "Error connecting to OpenAI: #{e.message}"
        return nil
      end
    else
      puts "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
      return nil
    end
  end
end

def ai_setup_help
  help_text = <<~HELP
    
    AI is not configured. To use AI features, you have two options:
    
    1. Install Ollama (recommended for local AI):
       curl -fsSL https://ollama.com/install.sh | sh
       ollama pull llama3.2  # or any model you prefer
    
    2. Configure external AI model in ~/.rshrc:
       @aimodel = "gpt-4"
       @aikey = "your-api-key-here"
    
    Once configured:
    - Use @ for AI text responses: @ What is the GDP of Norway?
    - Use @@ for AI command suggestions: @@ list files sorted by size
  HELP
  return help_text.c(@c_path)
end

# INITIAL SETUP
def load_rshrc_safe
  return unless File.exist?(Dir.home+'/.rshrc')

  begin
    # Try to load the .rshrc file
    load(Dir.home+'/.rshrc')

    # Validate critical variables
    @history = [] unless @history.is_a?(Array)
    @nick = {} unless @nick.is_a?(Hash)
    @gnick = {} unless @gnick.is_a?(Hash)

  rescue SyntaxError => e
    puts "\n\033[31mERROR: Syntax error in .rshrc:\033[0m"
    puts e.message
    puts "\n\033[33mAttempting to auto-heal .rshrc...\033[0m\n"

    if auto_heal_rshrc
      puts "\033[32m.rshrc has been healed! Retrying...\033[0m\n"
      begin
        load(Dir.home+'/.rshrc')
      rescue => e2
        puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
        load_defaults
      end
    else
      puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
      load_defaults
    end

  rescue => e
    puts "\n\033[31mERROR loading .rshrc: #{e.message}\033[0m"
    puts "\033[33mLoading with defaults...\033[0m\n"
    load_defaults
  end
end

def auto_heal_rshrc
  begin
    rshrc_path = Dir.home + '/.rshrc'
    return false unless File.exist?(rshrc_path)

    # Backup the corrupted file
    backup_path = rshrc_path + '.backup.' + Time.now.strftime('%Y%m%d_%H%M%S')
    File.write(backup_path, File.read(rshrc_path))
    puts "Backed up corrupted .rshrc to #{backup_path}"

    content = File.read(rshrc_path)
    original_content = content.dup
    healed = false

    # Fix common history array issues
    if content =~ /^@history\s*=\s*\[.*\]\s*\n\s*,/m
      # Fix case where array ends with ] followed by comma on next line
      content.gsub!(/^(@history\s*=\s*\[.*\])\s*\n\s*,(.*)$/m) do |match|
        # Remove the extra closing bracket and merge the lines
        history_line = $1
        continuation = $2
        # Remove trailing ] from first part
        history_line = history_line.sub(/\]\s*$/, '')
        # Combine and close properly
        "#{history_line}, #{continuation}]"
      end
      healed = true
    end

    # Fix unclosed arrays
    ['@history', '@nick', '@gnick'].each do |var|
      if content =~ /^#{var}\s*=\s*[[{](?!.*[}\]]\s*$)/m
        content.sub!(/^(#{var}\s*=\s*)(\[.*?)$/m) { "#{$1}#{$2}]" }
        content.sub!(/^(#{var}\s*=\s*)({.*?)$/m) { "#{$1}#{$2}}" }
        healed = true
      end
    end

    # Validate Ruby syntax of the healed content
    begin
      # Try to parse the content
      eval("BEGIN {return true}\n" + content)
    rescue SyntaxError => e
      # If still has syntax errors, extract only valid parts
      new_content = ""

      # Extract valid variable assignments
      content.each_line do |line|
        if line =~ /^(@\w+|\w+)\s*=\s*.+$/
          begin
            eval(line)
            new_content += line
          rescue
            # Skip invalid lines
          end
        elsif line =~ /^(def|class|module|end|if|else|elsif|when|case|begin|rescue)/
          new_content += line
        elsif line.strip.start_with?('#') || line.strip.empty?
          new_content += line
        end
      end

      content = new_content
      healed = true
    end

    if healed && content != original_content
      File.write(rshrc_path, content)
      return true
    end

    false
  rescue => e
    puts "Error during auto-heal: #{e.message}"
    false
  end
end

def load_defaults
  @history ||= []
  @nick ||= {"ls" => "ls --color -F"}
  @gnick ||= {}
  puts "Loaded with default configuration."
end

begin # Load .rshrc and populate @history
  trap "SIGINT" do end
  trap "SIGHUP" do
    rshrc
    exit
  end
  trap "SIGTERM" do
    rshrc
    exit
  end
  firstrun unless File.exist?(Dir.home+'/.rshrc') # Initial loading - to get history
  load_rshrc_safe
  # Load login shell files if rsh is running as login shell
  if ENV['LOGIN_SHELL'] or $0 == "-rsh" or ARGV.include?('-l') or ARGV.include?('--login')
    ['/etc/profile', Dir.home+'/.profile', Dir.home+'/.bash_profile', Dir.home+'/.bashrc'].each do |f|
      if File.exist?(f)
        puts "Loading #{f}..." if ENV['RSH_DEBUG']
        begin
          # Source shell files by extracting export statements
          File.readlines(f).each do |line|
            if line =~ /^\s*export\s+(\w+)=(.*)/
              ENV[$1] = $2.gsub(/['"]/, '')
            end
          end
        rescue => e
          puts "Warning: Could not source #{f}: #{e}" if ENV['RSH_DEBUG']
        end
      end
    end
  end 
  ENV["SHELL"] = __FILE__
  ENV["TERM"]  = "rxvt-unicode-256color"
  ENV["PATH"]  ? ENV["PATH"] += ":" : ENV["PATH"] = ""
  ENV["PATH"] += "/home/#{@user}/bin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  if @lscolors and File.exist?(@lscolors)
    ls = File.read(@lscolors) 
    ls.sub!(/export.*/, '')
    ls.sub!(/^LS_COLORS=/, 'ENV["LS_COLORS"]=')
    eval(ls)
  end
  @c = Cursor               # Initiate @c as Cursor
  @c.save                   # Get max row & col
  @c.row(8000)
  @c.col(8000)
  @maxrow, @maxcol = @c.pos
  @c.restore                # Max row & col gotten, cursor restored
  hist_clean                # Remove duplicates, etc
  @path.map! {|p| p + "/*"} # Set proper format for path search
end

# MAIN PART
loop do 
  begin
    @user = Etc.getpwuid(Process.euid).name # For use in @prompt
    @node = Etc.uname[:nodename]            # For use in @prompt
    h = @history; load_rshrc_safe; @history = h # reload prompt but not history safely
    @prompt.gsub!(/#{Dir.home}/, '~') # Simplify path in prompt
    system("printf \"\033]0;rsh: #{Dir.pwd}\007\"")   # Set Window title to path 
    @history[0] = "" unless @history[0]
    @exe = []
    @path.each do |p| # Add all executables in @path
      Dir.glob(p).each do |c|
        @exe.append(File.basename(c)) if File.executable?(c) and not Dir.exist?(c)
      end
    end
    getstr # Main work is here
    @cmd = @history[0]
    @dirs.unshift(Dir.pwd)
    @dirs.pop
    hist_clean # Clean up the history
    @cmd = "ls" if @cmd == "" # Default to ls when no command is given
    if @cmd.match(/^!\d+/)
      hi = @history[@cmd.sub(/^!(\d+)$/, '\1').to_i+1] 
      @cmd = hi if hi
    end
    # Move cursor to end of line and print the full command before clearing
    @c.row(@row0)
    @c.clear_line
    print @prompt + cmd_check(@cmd)
    print "\n"; @c.clear_screen_down
    if @cmd == "r" # Integration with rtfm (https://github.com/isene/RTFM)
      t  = Time.now
      t0 = t.nsec.to_s
      tf = "/tmp/.rshpwd" + t0
      File.write(tf, Dir.pwd)
      system("rtfm #{tf}")
      Dir.chdir(File.read(tf))
      File.delete(tf)
      system("git status .") if Dir.exist?(".git")
      next
    end
    if @cmd =~ /^\=/ # Integration with xrpn (https://github.com/isene/xrpn)
      @cmd.gsub!("  ", ",")
      @cmd = "echo \"#{@cmd[1...]},prx,off\" | xrpn" 
    end
    # AI integration with @ and @@
    if @cmd =~ /^@@\s+(.+)/ # AI command suggestion
      prompt = $1
      response = ai_command_suggest(prompt)
      if response
        # Store the suggestion for the next prompt
        @ai_suggestion = response
        # Also add to history for record keeping
        @history.unshift(response)
      end
      next
    elsif @cmd =~ /^@\s+(.+)/ # AI text response
      prompt = $1
      response = ai_query(prompt)
      puts response if response
      next
    end
    if @cmd.match(/^\s*:/) # Ruby commands are prefixed with ":"
      begin
        eval(@cmd[1..-1])
      #rescue StandardError => err
      rescue Exception => err
        puts "\n#{err}"
      end
    elsif @cmd == '#' # List previous directories
      dirs
    else # Execute command
      # Check if it's a user-defined Ruby function FIRST (before any expansions)
      cmd_parts = @cmd.split(/\s+/)
      func_name = cmd_parts[0]
      if self.respond_to?(func_name) && singleton_class.instance_methods(false).include?(func_name.to_sym)
        begin
          args = cmd_parts[1..]
          puts "DEBUG: Calling #{func_name} with args: #{args}" if ENV['RSH_DEBUG']
          result = self.send(func_name, *args)
          puts "DEBUG: Result: #{result.inspect}" if ENV['RSH_DEBUG']
          puts result unless result.nil?
        rescue => e
          puts "Error calling function '#{func_name}': #{e}"
        end
      else
        # Handle conditional execution (&& and ||)
        if @cmd.include?('&&') || @cmd.include?('||')
          execute_conditional(@cmd)
          next
        end
        # Expand brace expansion {a,b,c}
        @cmd = expand_braces(@cmd)
        # Expand command substitution $(command) and backticks
        @cmd = @cmd.gsub(/\$\(([^)]+)\)/) { `#{$1}`.chomp }
        @cmd = @cmd.gsub(/`([^`]+)`/) { `#{$1}`.chomp }
        # Expand environment variables and exit status
        @cmd = @cmd.gsub(/\$\?/) { @last_exit.to_s }
        @cmd = @cmd.gsub(/\$(\w+)|\$\{(\w+)\}/) { ENV[$1 || $2] || '' }
        # Expand tilde
        @cmd = @cmd.gsub(/~/, Dir.home)
        ca = @nick.transform_keys {|k| /((^\K\s*\K)|(\|\K\s*\K))\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ca.keys), @nick)
        ga = @gnick.transform_keys {|k| /\b(?<!-)#{Regexp.escape k}\b/}
        @cmd = @cmd.gsub(Regexp.union(ga.keys), @gnick)
        @cmd = "~" if @cmd == "cd"
        @cmd.sub!(/^cd (\S*).*/, '\1')
        @cmd = Dir.home if @cmd == "~"
        @cmd = @dirs[1] if @cmd == "-"
        @cmd = @dirs[@cmd.to_i] if @cmd =~ /^\d$/
        # Check if it's a directory to change to
        dir = @cmd.strip.sub(/~/, Dir.home)
        if Dir.exist?(dir)
          Dir.chdir(dir) 
          system("git status .") if Dir.exist?(".git")
        else
          puts "#{Time.now.strftime("%H:%M:%S")}: #{@cmd}".c(@c_stamp)
          if @cmd == "f" # fzf integration (https://github.com/junegunn/fzf)
            res = `fzf`.chomp
            Dir.chdir(File.dirname(res))
          elsif File.exist?(@cmd) and not File.executable?(@cmd) and not @cmd.include?(" ")
            # Only auto-open files if it's a single filename (no spaces = no command with args)
            if File.read(@cmd).force_encoding("UTF-8").valid_encoding?
              system("#{ENV['EDITOR']} #{@cmd}") # Try open with user's editor
            else
              if @runmailcap
                Thread.new { system("run-mailcap #{@cmd} 2>/dev/null") }
              else
                Thread.new { system("xdg-open #{@cmd} 2>/dev/null") }
              end
            end
          else 
            begin
              pre_cmd
              # Handle background jobs
              if @cmd.end_with?(' &')
                @cmd = @cmd[0..-3]  # Remove the &
                @job_id += 1
                # Handle pipes and redirections in background
                if @cmd.include?('|') || @cmd.include?('>') || @cmd.include?('<')
                  pid = spawn(@cmd, pgroup: true)
                else
                  pid = spawn(@cmd)
                end
                @jobs[@job_id] = {pid: pid, cmd: @cmd, status: :running}
                puts "[#{@job_id}] #{pid} #{@cmd}"
              else
                # Better handling of pipes and redirections  
                @current_pid = spawn(@cmd)
                Process.wait(@current_pid)
                @last_exit = $?.exitstatus
                @current_pid = nil
                puts " Command failed: #{@cmd} (exit #{@last_exit})" unless @last_exit == 0
              end
              post_cmd
            rescue StandardError => err
              puts "\nError: #{err}"
            end
          end
        end
      end
    end
  rescue StandardError => err # Throw error nicely
    puts "\n#{err}"
  end
end

# vim: set sw=2 sts=2 et fdm=syntax fdn=2 fcs=fold\:\ :
