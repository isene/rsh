#!/usr/bin/env ruby
# encoding: utf-8
#
# SCRIPT INFO 
# Name:       rsh - Ruby SHell
# Language:   Pure Ruby, best viewed in VIM
# Author:     Geir Isene <g@isene.com>
# Web_site:   http://isene.com/
# Github:     https://github.com/isene/rsh
# License:    Public domain
@version    = "3.4.9" # Improved :calc with safer eval, Math sandbox, better error messages

# MODULES, CLASSES AND EXTENSIONS
class String # Add coloring to strings (with escaping for Readline)
  def c(code);  color(self, "\001\e[38;5;#{code}m\002"); end  # Color code
  def b;        color(self, "\001\e[1m\002"); end             # Bold
  def i;        color(self, "\001\e[3m\002"); end             # Italic
  def u;        color(self, "\001\e[4m\002"); end             # Underline
  def l;        color(self, "\001\e[5m\002"); end             # Blink
  def r;        color(self, "\001\e[7m\002"); end             # Reverse
  def color(text, color_code)  "#{color_code}#{text}\001\e[0m\002" end
end
module Cursor # Terminal cursor movement ANSI codes (thanks to https://github.com/piotrmurach/tty-cursor)
  module_function
  ESC = "\e".freeze
  CSI = "\e[".freeze
  def save # Save current position
    print(Gem.win_platform? ? CSI + 's' : ESC + '7')
  end
  def restore # Restore cursor position
    print(Gem.win_platform? ? CSI + 'u' : ESC + '8')
  end
  def pos # Query cursor current position
    res = ''
    begin
      $stdin.raw do |stdin|
        $stdout << CSI + '6n' # Tha actual ANSI get-position
        $stdout.flush
        while (c = stdin.getc) != 'R'
          res << c if c
      end
      end
    rescue Errno::ENOTTY
      # Not a TTY, return default values
      return 25, 80
    end
    m = res.match /(?<row>\d+);(?<col>\d+)/
    return m ? [m[:row].to_i, m[:col].to_i] : [25, 80]
  end
  def rowget
    row, col = self.pos
    return row
  end
  def colget
    row, col = self.pos
    return col
  end
  def col(n = nil) # Cursor moves to nth position horizontally in the current line
    print(CSI + "#{n || 1}G")
  end
  def row(n = nil) # Cursor moves to the nth position vertically in the current column
    print(CSI + "#{n || 1}d")
  end
  def next_line # Move cursor down to beginning of next line
    print(CSI + 'E' + CSI + "1G")
  end
  def clear_line # Erase the entire current line and return to beginning of the line
    print(CSI + '2K' +  CSI + "1G")
  end
  def clear_line_after # Erase from the current position (inclusive) to the end of the line
    print(CSI + '0K')
  end
  def scroll_down # Scroll display down one line
    print(ESC + 'D')
  end
  def clear_screen_down
    print(CSI + 'J')
  end
end

# INITIALIZATION
begin # Requires
  require 'etc'
  require 'io/console'
  require 'io/wait'
end
begin # Initialization
  # Theming
  @c_prompt    = 10                       # Color for basic prompt
  @c_cmd       = 2                        # Color for valid command
  @c_nick      = 6                        # Color for matching nick
  @c_gnick     = 14                       # Color for matching gnick
  @c_path      = 3                        # Color for valid path
  @c_switch    = 6                        # Color for switches/options
  @c_bookmark  = 13                       # Color for bookmarks
  @c_colon     = 4                        # Color for colon commands
  @c_tabselect = 5                        # Color for selected tabcompleted item
  @c_taboption = 244                      # Color for unselected tabcompleted item
  @c_stamp     = 244                      # Color for time stamp/command
  # File type colors for tab completion
  @c_dir       = 33                       # Color for directories (blue)
  @c_exec      = 2                        # Color for executables (green)
  @c_image     = 13                       # Color for images (magenta)
  @c_archive   = 11                       # Color for archives (yellow)
  @c_file      = 7                        # Color for regular files (white/default)
  # Prompt
  @prompt      = "rsh > ".c(@c_prompt).b  # Very basic prompt if not defined in .rshrc
  # Hash & array initializations
  @nick        = {}                       # Initiate alias/nick hash
  @gnick       = {}                       # Initiate generic/global alias/nick hash
  @history     = []                       # Initiate history array
  @exe = []
  @exe_cache_time = 0                     # Cache timestamp for executables
  @exe_cache_paths = ""                   # Cached PATH value
  @cmd_frequency = {}                     # Track command usage frequency
  # Paths
  @user = Etc.getpwuid(Process.euid).name # For use in @prompt
  @path        = ENV["PATH"].split(":")   # Get paths
  # History
  @histsize    = 200                      # Max history if not set in .rshrc
  @hloaded     = false                    # Variable to determine if history is loaded
  # Use run-mailcap instead of xgd-open? Set "= true" in .rshrc if you want run-mailcap
  @runmailcap  = false
  # Variable initializations
  @dirs        = ["."]*10
  @jobs        = {}                       # Background jobs tracking
  @job_id      = 0                        # Job counter
  @ai_suggestion = nil                    # Store AI command suggestion
  @last_exit   = 0                        # Last command exit status
  # Command completions for subcommands
  @cmd_completions = {
    "git" => %w[add bisect branch checkout clone commit diff fetch grep init log merge mv pull push rebase reset restore rm show stash status switch tag],
    "apt" => %w[install remove update upgrade search show list autoremove purge],
    "apt-get" => %w[install remove update upgrade dist-upgrade autoremove purge clean autoclean],
    "docker" => %w[build run ps images pull push start stop restart rm rmi exec logs inspect network volume],
    "systemctl" => %w[start stop restart reload status enable disable is-active is-enabled list-units],
    "cargo" => %w[build run test check clean doc new init add search publish install update],
    "npm" => %w[install uninstall update run build test start init publish],
    "gem" => %w[install uninstall update list search build push],
    "bundle" => %w[install update exec check config]
  }
  # New v3.0 features initialization
  @switch_cache = {}                      # Cache for command switches from --help
  @switch_cache_time = {}                 # Timestamp for cache expiry
  @bookmarks = {}                         # Enhanced bookmarks with tags
  @defuns = {}                            # Store defun definitions for persistence
  @cmd_stats = {}                         # Command execution statistics
  @session_dir = Dir.home + '/.rsh/sessions' # Sessions directory
  @session_file = @session_dir + '/default.json' # Default session file
  @session_autosave = 0                   # Auto-save interval (0 = disabled)
  @session_last_save = Time.now.to_i      # Last auto-save timestamp
  @history_dedup = 'smart'                # History dedup mode: 'off', 'full', 'smart'
  @auto_correct = false                   # Auto-correct typos (default: off)
  @slow_command_threshold = 0             # Threshold for slow command alerts (0 = disabled)
  @plugin_dir = Dir.home + '/.rsh/plugins' # Plugins directory
  @plugins = []                           # Loaded plugin instances
  @plugin_enabled = []                    # List of enabled plugin names (whitelist)
  @plugin_commands = {}                   # Commands added by plugins
  @validation_rules = []                  # Custom validation rules
  @completion_weights = {}                # Completion learning weights
  @completion_learning = true             # Enable completion learning (default: on)
  @completion_show_metadata = false       # Show file metadata in completions (default: off)
  @recording = {active: false, name: nil, commands: []} # Command recording state
  @recordings = {}                        # Saved recordings
  @command_cache = {}                     # Cache for expensive shell command outputs
  @last_prompt_dir = nil                  # Track directory for .rshrc reload optimization
  # Built-in rsh commands are called with : prefix, so no need for separate tracking
  Dir.mkdir(Dir.home + '/.rsh') unless Dir.exist?(Dir.home + '/.rsh')
  Dir.mkdir(@session_dir) unless Dir.exist?(@session_dir)
  Dir.mkdir(@plugin_dir) unless Dir.exist?(@plugin_dir)
  def pre_cmd; end                        # User-defined function to be run BEFORE command execution
  def post_cmd; end                       # User-defined function to be run AFTER  command execution
end

# HELP TEXT
@info = <<~INFO

  Hello #{@user}, welcome to rsh v3.3 - the Ruby SHell.

  rsh does not attempt to compete with the grand old shells like bash and zsh.
  It serves the specific needs and wants of its author. If you like it, then feel free
  to ask for more or different features here: https://github.com/isene/rsh.

  Core Features:
  * Aliases (called nicks in rsh) - both for commands and general nicks
  * Syntax highlighting for nicks, bookmarks, commands, switches and valid dirs/files
  * Tab completions for nicks, system commands, command switches and dirs/files
  * Smart context-aware tab completion for git, apt, docker, systemctl, cargo, npm, gem, bundle
  * History with editing, search and repeat (use `!` or UP arrow)
  * Auto-suggestions from history (press RIGHT arrow to accept)
  * Ruby functions callable as shell commands (persistent across sessions)
  * AI integration: Use @ for text responses and @@ for command suggestions

  NEW in v3.0:
  * Command analytics - :stats shows usage patterns and performance metrics
  * Enhanced bookmarks with tags - :bm "name path #tag1,tag2" then just type name to jump
  * Session management - :save_session and :load_session preserve your entire shell state
  * Smart typo detection - "Did you mean...?" suggestions for misspelled commands
  * Switch caching - Faster TAB completion for command options
  * Option value completion - TAB complete values like --format=json
  * Syntax validation - Pre-execution warnings for dangerous or malformed commands
  * Unified command syntax - :nick, :gnick, :bm all work the same way (list/create/delete)

  NEW in v3.4:
  * Completion learning - Shell learns which TAB completions you use and ranks them higher
  * Context-aware - Separate learning for each command (git, ls, docker, etc.)
  * :completion_stats - View learned patterns with visual bar charts
  * Persistent - Learning data saves to .rshrc across sessions

  v3.3 Features:
  * Quote-less syntax - No more quotes! Use :nick la = ls -la
  * Parametrized nicks - :nick gp = git push origin {{branch}}, then: gp branch=main
  * Ctrl-G multi-line edit - Press Ctrl-G to edit command in $EDITOR
  * Custom validation - :validate rm -rf / = block prevents dangerous commands
  * Shell script support - for/while/if loops work with full bash syntax

  v3.2 Features:
  * Plugin system - Extensible architecture for custom commands, completions, and hooks
  * Auto-correct typos - :config auto_correct on (with confirmation prompt)
  * Command timing alerts - :config slow_command_threshold 5 warns on slow commands
  * Inline calculator - :calc 2 + 2, :calc "Math::PI", full Ruby Math library
  * Enhanced history - !!, !-2, !5:7 for repeat last, nth-to-last, and chaining
  * Stats visualization - :stats --graph for colorful ASCII bar charts

  v3.1 Features:
  * Multiple named sessions - :save_session "project" and :load_session "project"
  * Stats export - :stats --csv or :stats --json for data analysis
  * Session auto-save - Set @session_autosave = 300 in .rshrc for 5-min auto-save
  * Bookmark import/export - :bm --export file.json and :bm --import file.json
  * Bookmark statistics - :bm --stats shows usage patterns and tag distribution
  * Color themes - :theme solarized|dracula|gruvbox|nord|monokai
  * Config management - :config shows/sets history_dedup, session_autosave, etc.
  * Environment management - :env for listing/setting/exporting environment variables

  Config file (.rshrc) updates on exit (Ctrl-d) or not (Ctrl-e).
  All colors are themeable in .rshrc (see github link for possibilities).

  Use `:help` for complete command reference.

INFO

@help = <<~HELP

HELP

# GENERIC FUNCTIONS
def firstrun
  puts @info
  puts "Since there is no rsh configuration file (.rshrc), I will help you set it up to suit your needs.\n\n"
  puts "The prompt you see now is the very basic rsh prompt:"
  print "#{@prompt} (press ENTER)"
  $stdin.gets
  puts "\nI will now change the prompt into something more useful."
  puts "Feel free to amend the prompt in your .rshrc.\n\n"
  rc = <<~RSHRC
  # PROMPT
  # The numbers in parenthesis are 256 color codes (the '.c()' is a String extention
  # to color text in the terminal. Add '.b' for bold and '.i' for italics.
  @prompt = "\#{@user}@\#{@node}".c(46) + ":".c(255) + " \#{Dir.pwd}/".c(196) + " ".c(7)

  # THEME
  @c_prompt    = 196  # Color for basic prompt
  @c_cmd       = 48   # Color for valid command
  @c_nick      = 51   # Color for matching nick
  @c_gnick     = 87   # Color for matching gnick
  @c_path      = 208  # Color for valid path
  @c_switch    = 148  # Color for switches/options
  @c_bookmark  = 13   # Color for bookmarks
  @c_colon     = 4    # Color for colon commands
  @c_tabselect = 207  # Color for selected tabcompleted item
  @c_taboption = 244  # Color for unselected tabcompleted item
  @c_stamp     = 244  # Color for time stamp/command

  # TAB COMPLETION SETTINGS
  @completion_limit = 10              # Max completion items to show
  @completion_case_sensitive = false  # Case-insensitive completion
  @completion_show_descriptions = false # Show help text inline
  @completion_fuzzy = true            # Enable fuzzy matching

  @nick = {"ls"=>"ls --color -F"}
RSHRC
  File.write(Dir.home+'/.rshrc', rc)
end
def getchr # Process key presses
  c = $stdin.getch
  case c
  when "\e"    # ANSI escape sequences (with only ESC, it should stop right here)
    return "ESC" if $stdin.ready? == nil
    case $stdin.getc
    when '['   # CSI
      case $stdin.getc  # Will get (or ASK) for more (remaining part of special character)
      when 'A' then chr = "UP"
      when 'B' then chr = "DOWN"
      when 'C' then chr = "RIGHT"
      when 'D' then chr = "LEFT"
      when 'Z' then chr = "S-TAB"
      when '2' then chr = "INS"    ; chr = "C-INS"    if $stdin.getc == "^"
      when '3' then chr = "DEL"    ; chr = "C-DEL"    if $stdin.getc == "^"
      when '5' then chr = "PgUP"   ; chr = "C-PgUP"   if $stdin.getc == "^"
      when '6' then chr = "PgDOWN" ; chr = "C-PgDOWN" if $stdin.getc == "^"
      when '7' then chr = "HOME"   ; chr = "C-HOME"   if $stdin.getc == "^"
      when '8' then chr = "END"    ; chr = "C-END"    if $stdin.getc == "^"
      else chr = ""
      end
    when 'O'   # Set Ctrl+ArrowKey equal to ArrowKey; May be used for other purposes in the future
      case $stdin.getc
      when 'a' then chr = "C-UP"
      when 'b' then chr = "C-DOWN"
      when 'c' then chr = "C-RIGHT"
      when 'd' then chr = "C-LEFT"
      else chr = ""
      end
    end
  when "", "" then chr = "BACK"
  when "" then chr = "C-C"
  when "" then chr = "C-D"
  when "" then chr = "C-E"
  when "" then chr = "C-G"
  when "" then chr = "C-K"
  when "" then chr = "C-L"
  when "" then chr = "C-N"
  when "" then chr = "C-O"
  when "" then chr = "C-P"
  when "" then chr = "C-T"
  when "" then chr = "C-Y"
  when "" then chr = "WBACK"
  when "\u001A" then chr = "C-Z"
  when "" then chr = "LDEL"
  when "\r" then chr = "ENTER"
  when "\t" then chr = "TAB"
  when /[[:print:]]/  then chr = c
  else chr = ""
  end
  return chr
end
def getstr # A custom Readline-like function
  @stk  = 0
  @pos  = 0
  chr   = ""
  @history.unshift("")
  # Check if we have an AI suggestion to pre-fill
  if @ai_suggestion
    @history[0] = @ai_suggestion
    @pos = @ai_suggestion.length
    @ai_suggestion = nil
  end
  @row0, p = @c.pos
  while chr != "ENTER" # Keep going with readline until user presses ENTER
    @ci   = nil
    lift  = false
    right = false
    # The actual printing og the command line
    @c.row(@row0)
    @c.clear_line
    print @display_prompt
    @c.clear_screen_down
    row, @pos0 = @c.pos
    #@history[0] = "" if @history[0].nil?
    print cmd_check(@history[0])
    @ci  = @history[1..].find_index {|e| e =~ /^#{Regexp.escape(@history[0].to_s)}./}
    unless @ci == nil
      @ci += 1
      @ciprompt = @history[@ci][@history[0].to_s.length..].to_s
    end
    if @history[0].to_s.length > 1 and @ci
      print @ciprompt.c(@c_stamp)
      right = true
    end
    c_col = @pos0 + @pos
    c_row = @row0 + c_col/(@maxcol)
    c_col == 0 ? @c.row(c_row + 1) : @c.row(c_row)
    if c_col.modulo(@maxcol) == 0
      @c.col(c_col)
      @c.row(@c.rowget - 1)
    else
      @c.col(c_col.modulo(@maxcol))
    end
    chr = getchr
    puts "DEBUG: Got char: '#{chr}' (length: #{chr.length})" if ENV['RSH_DEBUG']
    case chr
    when 'C-G'   # Ctrl-G opens command in $EDITOR
      temp_file = "/tmp/rsh_edit_#{Process.pid}.tmp"
      File.write(temp_file, @history[0] || "")
      system("#{ENV['EDITOR'] || 'vi'} #{temp_file}")
      if File.exist?(temp_file)
        edited = File.read(temp_file).strip
        # Convert multi-line to single line with proper separators
        if edited.include?("\n")
          # Join lines with semicolons, preserving quoted strings
          edited = edited.split("\n").map(&:strip).reject(&:empty?).join('; ')
        end
        @history[0] = edited
        @pos = edited.length
        File.delete(temp_file)
      end
    when 'C-C'
      @history[0] = ""
      @pos = 0
    when 'C-E'   # Ctrl-C exits gracefully but without updating .rshrc
      print "\n"
      exit
    when 'C-D'   # Ctrl-D exits after updating .rshrc
      rshrc
      exit
    when 'C-L'   # Clear screen and set position to top of the screen
      @c.row(1)
      @row0 = 1
      @c.clear_screen_down
    when 'UP'    # Go up in history
      if @stk == 0 and @history[0].length > 0
        @tabsearch = @history[0]
        tab("hist")
      else
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        unless @stk >= @history.length - 1
          @stk += 1 
          @history[0] = @history[@stk].dup
          @history[0] = "" unless @history[0]
          @pos = @history[0].length
        end
        lift = false
      end
      @c.row(@row0)
      @c.clear_screen_down
    when 'DOWN'  # Go down in history
      if lift
        @history.unshift("")
        @history[0] = @history[@stk].dup
        @stk += 1 
      end
      if @stk == 0
        @history[0] = ""
        @pos = 0
      elsif @stk == 1
        @stk -= 1 
        @history[0] = ""
        @pos = 0
      else
        @stk -= 1 
        @history[0] = @history[@stk].dup
        @pos = @history[0].length
      end
      lift = false
      @c.row(@row0)
      @c.clear_screen_down
    when 'RIGHT' # Move right on the readline
      if right 
        if lift
          @history.unshift("")
          @history[0] = @history[@stk].dup
          @stk += 1 
        end
        @history[0] = @history[@ci].dup
        @pos = @history[0].length
      end
      @pos += 1 unless @pos >= @history[0].length
    when 'LEFT'  # Move left on the readline
      @pos -= 1 unless @pos <= 0
    when 'HOME'  # Go to beginning of the readline
      @pos = 0
    when 'END'   # Go to the end of the readline
      @pos = @history[0].length
    when 'DEL'   # Delete one character
      @history[0][@pos] = ""
      lift = true
    when 'BACK'  # Delete one character to the left
      unless @pos <= 0
        @pos -= 1
        @history[0][@pos] = ""
      end
      lift = true
      @c.clear_line_after
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      unless @pos == @pos0
        # Skip over any trailing spaces first
        while @pos > 0 && @history[0][@pos - 1] == " "
          @pos -= 1
          @history[0][@pos] = ""
        end
        # Delete the word (until we hit a space or start)
        while @pos > 0 && @history[0][@pos - 1] != " "
          @pos -= 1
          @history[0][@pos] = ""
        end
      end
      lift = true
      @c.clear_line_after
    when 'C-Y'   # Copy command line to primary selection
      system("echo -n '#{@history[0]}' | xclip")
      puts "\n#{Time.now.strftime("%H:%M:%S")}: Copied to primary selection (paste with middle buttoni)".c(@c_stamp)
    when 'C-Z'   # Suspend current process (background job)
      if @current_pid
        puts "\n[#{@job_id}] Suspended #{@current_pid}"
        Process.kill("STOP", @current_pid)
        @jobs[@job_id] = {pid: @current_pid, cmd: @cmd, status: :stopped}
      else
        puts "\nNo active job to suspend"
      end
    when 'C-K'   # Kill/delete that entry in the history
      @history.delete_at(@stk)
      @stk -= 1
      if @stk == 0
        @history[0] = "" 
        @pos = 0
      else
        @history[0] = @history[@stk].dup
        @history[0] = "" unless @history[0]
        @pos = @history[0].length
      end
    when 'LDEL'  # Delete readline (Ctrl-U)
      @history[0] = ""
      @pos = 0
      lift = true
    when 'TAB'   # Tab completion of dirs and files
      puts "\n=== TAB KEY DETECTED ===" if ENV['RSH_DEBUG']
      puts "Current line: '#{@history[0]}'" if ENV['RSH_DEBUG']
      puts "Cursor pos: #{@pos}" if ENV['RSH_DEBUG']
      puts "======================" if ENV['RSH_DEBUG']
      @ci = nil
      #@tabsearch =~ /^-/ ? tabbing("switch") : tabbing("all")
      tab("all")
      lift = true
    when 'S-TAB'
      @ci = nil
      tab("hist")
      lift = true
    when /^.$/
      @history[0].insert(@pos,chr)
      @pos += 1
      lift = true
    end
    while $stdin.ready?
      chr = $stdin.getc
      @history[0].insert(@pos,chr)
      @pos += 1
    end
  end
  @c.clear_screen_down
end
def tab(type)
  i = 0
  chr = ""
  @tabarray = []

  @pretab   = @history[0][0...@pos].to_s        # Extract the current line up to cursor
  @postab   = @history[0][@pos..].to_s          # Extract the current line from cursor to end
  @c_row, @c_col = @c.pos                       # Get cursor position
  @row0     = @c_row                            # Save original row
  # Special handling for environment variables first
  if @pretab =~ /\$\w*$/
    @tabstr = @pretab.match(/\$\w*$/)[0]
    @pretab = @pretab.sub(/\$\w*$/, '')
  else
    @tabstr   = @pretab.split(/[|;&, ]/).last.to_s  # Get the sustring that is being tab completed
    @tabstr   = "" if @pretab[-1] =~ /[ |;&]/       # Tab from nothing if tabbing starts with space, pipe, etc.
    @tabstr   = @pretab if type == "hist"         # Searching for matches with whole string in history
    @pretab   = @pretab.delete_suffix(@tabstr)
  end
  type = "switch" if @tabstr && @tabstr[0] == "-" && !@tabstr.include?("=")
  type = "option_value" if @tabstr && @tabstr =~ /^--?[\w-]+=/
  type = "env_vars" if @tabstr && @tabstr[0] == "$"
  type = "colon_commands" if @tabstr && @tabstr[0] == ":"

  # Debug output when RSH_DEBUG is set
  if ENV['RSH_DEBUG']
    puts "\n=== TAB DEBUG ==="
    puts "Input type: #{type}"
    puts "@pretab: '#{@pretab}'"
    puts "@tabstr: '#{@tabstr}'"
    puts "Length: #{@tabstr.length}"
    puts "First char: '#{@tabstr[0] if @tabstr}'"
    puts "=================="
  end

  # Smart context-aware completion
  unless type == "switch" || type == "hist"
    if @pretab && !@pretab.empty?
      cmd_parts = @pretab.strip.split(/[|;&]/).last.strip.split
      last_cmd = cmd_parts.first if cmd_parts.any?
    else
      cmd_parts = []
      last_cmd = nil
    end

    # Check for colon command arguments
    if @pretab =~ /:record\s*$/
      type = "record_args"
    elsif @pretab =~ /:replay\s*$/
      type = "replay_args"
    elsif @pretab =~ /:plugins\s*$/
      type = "plugin_args"
    else
      case last_cmd
      when "cd", "pushd", "rmdir"
        type = "dirs_only"
      when "vim", "nano", "cat", "less", "more", "head", "tail", "file"
        type = "files_only"
      when "man", "info", "which", "whatis"
        type = "commands_only"
      when "export", "unset"
        type = "env_vars"
      else
        # Check if command has defined completions and we're on the first argument
        if @cmd_completions.key?(last_cmd) && cmd_parts.length == 1
          type = "cmd_subcommands"
          @current_cmd = last_cmd
        # If we're completing after a command (not at start of line), show only files
        elsif last_cmd
          type = "files_dirs_only"
        end
      end
    end
  end

  # Auto-complete . and .. for directory navigation commands
  if type == "dirs_only" && (@tabstr == ".." || @tabstr == ".")
    completed = @tabstr + "/"
    @history[0] = @pretab + completed + @postab
    @pos = @pretab.length + completed.length
    @c_col = @pos0 + @pos
    @c.clear_line
    line_display = cmd_check(@history[0]).to_s
    print @display_prompt + line_display
    @c.col(@c_col)
    return
  end

  while chr != "ENTER"
    case type
    when "hist"         # Handle history completions ('UP' key)
      @tabarray = @history.select {|el| el =~ /#{@tabstr}/} # Select history items matching @tabstr
      @tabarray.shift   # Take away @history[0]
      return if @tabarray.empty?
    when "record_args"
      # Completions for :record command
      @tabarray = %w[start stop status show]
      # Add existing recording names for show
      @tabarray += @recordings.keys.map { |k| "show #{k}" } if @recordings.any?
      # Add delete options
      @tabarray += @recordings.keys.map { |k| "-#{k}" } if @recordings.any?
    when "replay_args"
      # Completions for :replay command - just recording names
      @tabarray = @recordings.keys
    when "plugin_args"
      # Completions for :plugins command
      @tabarray = %w[reload]
      # Add help for all available plugins
      if Dir.exist?(@plugin_dir)
        available = Dir.glob(@plugin_dir + '/*.rb').map { |f| File.basename(f, '.rb') }
        @tabarray += available.map { |p| "help #{p}" }
        @tabarray += available.map { |p| "info #{p}" }
      end
      # Add plugin names for enable/disable
      if @plugins.any?
        @tabarray += @plugins.map { |p| "disable #{p[:name]}" }
      end
      # Show "enable" for disabled plugins (available but not enabled)
      if Dir.exist?(@plugin_dir)
        available = Dir.glob(@plugin_dir + '/*.rb').map { |f| File.basename(f, '.rb') }
        disabled = available - @plugin_enabled
        @tabarray += disabled.map { |p| "enable #{p}" } if disabled.any?
      end
    when "switch"
      cmdswitch = @pretab.split(/[|, ]/).last.to_s.strip
      @tabarray = get_command_switches(cmdswitch)
    when "option_value"  # Completion for option values like --format=<value>
      if @tabstr =~ /^--?[\w-]+=(.*)/
        value_prefix = $1
        option = @tabstr.sub(/=.*/, '')
        # Define common option value completions
        value_completions = {
          /format/ => %w[json yaml xml csv plain],
          /output/ => %w[json yaml xml text html],
          /level|log-level/ => %w[debug info warn error fatal],
          /color/ => %w[auto always never],
          /type/ => %w[file dir link all]
        }
        matches = []
        value_completions.each do |pattern, values|
          if option =~ pattern
            matches = values.select { |v| v.start_with?(value_prefix) }
            break unless matches.empty?
          end
        end
        @tabarray = matches.map { |v| "#{option}=#{v}" }
      end
    when "dirs_only"    # Only show directories
      fdir = @tabstr + "*"
      dirs = Dir.glob(fdir).select { |d| Dir.exist?(d) }.map { |d| d + "/" }
      @tabarray = dirs
    when "files_only"   # Only show files, not directories
      fdir = @tabstr + "*"
      files = Dir.glob(fdir).reject { |f| Dir.exist?(f) }
      @tabarray = files
    when "files_dirs_only"  # Show files and directories, but not commands
      fdir = @tabstr + "*"
      files = Dir.glob(fdir)
      # Only show hidden files if tabstr starts with .
      unless @tabstr.start_with?('.')
        files.reject! { |f| File.basename(f).start_with?('.') }
      end
      files.map! do |e|
        if e =~ /(?<!\\) /
          e = e.sub(/(.*\/|^)(.*)/, '\1\'\2\'') unless e =~ /'/
        end
        Dir.exist?(e) ? e + "/" : e
      end
      # Separate directories and files for better ordering
      dirs = files.select { |f| f.end_with?('/') }
      files_only = files.reject { |f| f.end_with?('/') }
      # Order: directories first, then files
      @tabarray = dirs + files_only
    when "commands_only" # Only show executable commands
      ex = @exe.dup
      ex.prepend(*@nick.keys, *@gnick.keys)
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = ex.select { |s| s =~ Regexp.new(@tabstr, regex_flags) }
    when "cmd_subcommands" # Command-specific subcommands (git, apt, docker, etc.)
      subcommands = @cmd_completions[@current_cmd] || []
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = subcommands.select { |cmd| cmd =~ Regexp.new(@tabstr, regex_flags) }
    when "env_vars"     # Environment variables
      env_vars = ENV.keys.map { |k| "$#{k}" }
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      @tabarray = env_vars.select { |var| var =~ Regexp.new(@tabstr, regex_flags) }
    when "colon_commands"  # Ruby/rsh commands starting with :
      colon_cmds = %w[
        :nick :gnick :bm :bookmark :stats :defun :defun?
        :history :rmhistory :jobs :fg :bg
        :save_session :load_session :list_sessions :delete_session :rmsession
        :config :env :theme :plugins :calc :validate
        :completion_stats :completion_reset
        :record :replay
        :info :version :help
      ]
      search_str = @tabstr[1..-1] || ""  # Remove leading :
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE
      matches = colon_cmds.select { |cmd| cmd[1..-1] =~ Regexp.new("^#{search_str}", regex_flags) }
      @tabarray = matches
    when "all"          # Handle all other tab completions
      ex  = []
      ex += @exe
      ex.sort!
      ex.prepend(*@nick.keys)        # Add nicks
      ex.prepend(*@gnick.keys)       # Add gnicks
      ex.prepend(*@bookmarks.keys) if @bookmarks  # Add bookmarks

      # Enhanced matching with case sensitivity and fuzzy support
      regex_flags = @completion_case_sensitive ? 0 : Regexp::IGNORECASE

      # Try multiple matching strategies
      compl = []

      # First try exact prefix matching
      compl = ex.select { |s| s =~ Regexp.new("^#{@tabstr}", regex_flags) }

      # If no results and fuzzy enabled, try fuzzy matching
      if compl.empty? && @completion_fuzzy && @tabstr.length > 1
        # Fuzzy matching: match from start with characters in order
        fuzzy_pattern = "^#{@tabstr.chars.join('.*')}"
        compl = ex.select { |s| s =~ Regexp.new(fuzzy_pattern, regex_flags) }
      end

      # If still no results, try substring matching
      if compl.empty?
        compl = ex.select { |s| s =~ Regexp.new(@tabstr, regex_flags) }
      end

      # Sort by frequency (most used first), then alphabetically
      compl.sort! do |a, b|
        freq_a = @cmd_frequency[a] || 0
        freq_b = @cmd_frequency[b] || 0
        if freq_a == freq_b
          a <=> b
        else
          freq_b <=> freq_a
        end
      end

      # File completion with hidden file handling
      fdir = @tabstr + "*"
      files = Dir.glob(fdir)

      # Only show hidden files if tabstr starts with .
      unless @tabstr.start_with?('.')
        files.reject! { |f| File.basename(f).start_with?('.') }
      end

      files.map! do |e|
        if e =~ /(?<!\\) /
          e = e.sub(/(.*\/|^)(.*)/, '\1\'\2\'') unless e =~ /'/
        end
        Dir.exist?(e) ? e + "/" : e   # Add matching dirs
      end

      # Separate directories and files for better ordering
      dirs = files.select { |f| f.end_with?('/') }
      files_only = files.reject { |f| f.end_with?('/') }

      # Order: directories first, then files, then commands
      @tabarray = dirs + files_only + compl

      # Debug completion results
      if ENV['RSH_DEBUG']
        puts "=== COMPLETION RESULTS ==="
        puts "Type: #{type}"
        puts "Total matches: #{@tabarray.length}"
        puts "First 5: #{@tabarray.first(5).inspect}"
        puts "=========================="
      end
    end
    return if @tabarray.empty?
    @tabarray.delete("")                                      # Don't remember why

    # Apply completion learning to sort results
    if @completion_learning && type != "hist"
      # Determine context for learning
      completion_context = if @pretab && !@pretab.empty?
        # Use the command being completed
        @pretab.strip.split(/[|;&]/).last.strip.split.first || "all"
      else
        "all"
      end
      @tabarray = sort_by_learning(completion_context, @tabarray)
    end

    @c.clear_screen_down                                      # Here we go
    max_items = @completion_limit || 5
    @tabarray.length.to_i - i < max_items ? l = @tabarray.length.to_i - i : l = max_items
    l.times do |x|                                            # Iterate through
      if x == 0                                               # First item goes onto the commandline
        @c.clear_line                                         # Clear the line
        tabchoice = @tabarray[i]                              # Select the item from the @tabarray
        tabchoice = tabchoice.sub(/\s*(-.*?)[,\s].*/, '\1') if type == "switch"
        @newhist0 = @pretab + tabchoice + @postab             # Remember now the new value to be given to @history[0]
        line1     = cmd_check(@pretab).to_s                   # Syntax highlight before @tabstr
        line2     = cmd_check(@postab).to_s                   # Syntax highlight after  @tabstr
        # Color and underline the current tabchoice on the commandline with file type color:
        display_choice = tabchoice.dup
        clean_choice = tabchoice.gsub(/['"]/, '').chomp('/')
        if !tabchoice.end_with?('/') && File.exist?(clean_choice) && File.executable?(clean_choice) && !File.directory?(clean_choice)
          display_choice += '*'
        end
        choice_color = get_file_color(tabchoice)
        # Escape regex special characters in @tabstr for pattern matching
        escaped_tabstr = Regexp.escape(@tabstr)
        tabline   = display_choice.sub(/(.*)#{escaped_tabstr}(.*)/, '\1'.c(choice_color) + @tabstr.u.c(choice_color) + '\2'.c(choice_color))
        print @display_prompt + line1 + tabline + line2       # Print the commandline
        @pos   = @pretab.length.to_i + tabchoice.length.to_i  # Set the position on that commandline
        @c_col = @pos0 + @pos                                 # The cursor position must include the prompt as well
        @c.col(@c_col)                                        # Set the cursor position
        nextline                                              # Then start showing the completion items
        tabline  = @tabarray[i]                               # Get the next matching tabline
        # Add executable indicator
        display_item = tabline.dup
        clean_item = tabline.gsub(/['"]/, '').chomp('/')
        if !tabline.end_with?('/') && File.exist?(clean_item) && File.executable?(clean_item) && !File.directory?(clean_item)
          display_item += '*'
        end
        # Get file type color, but make selected item bold for distinction
        file_color = get_file_color(tabline)
        # Can't nest ANSI codes, they must each complete/conclude or they will mess eachother up
        escaped_tabstr = Regexp.escape(@tabstr)
        if display_item.include?(@tabstr)
          tabline1 = display_item.sub(/(.*?)#{escaped_tabstr}.*/, '\1').c(file_color).b # Bold + color for selected
          tabline2 = display_item.sub(/.*?#{escaped_tabstr}(.*)/, '\1').c(file_color).b
          print " " + tabline1 + @tabstr.c(file_color).u.b + tabline2       # Bold, color & underline @tabstr
        else
          # For fuzzy matches, just show the whole word highlighted
          print " " + display_item.c(file_color).b
        end
        # Add metadata if enabled
        if @completion_show_metadata && File.exist?(clean_item)
          if File.directory?(clean_item)
            begin
              count = Dir.entries(clean_item).length - 2
              print " [#{count}]".c(244)
            rescue
            end
          else
            size = File.size(clean_item)
            size_str = size < 1024 ? "#{size}B" :
                       size < 1024*1024 ? "#{(size/1024.0).round(1)}K" :
                       "#{(size/(1024.0*1024)).round(1)}M"
            print " [#{size_str}]".c(244)
          end
        end
      else
        begin
          tabline = @tabarray[i+x]    # Next tabline, and next, etc (usually 4 times here)
          # Add executable indicator
          display_item = tabline.dup
          clean_item = tabline.gsub(/['"]/, '').chomp('/')
          if !tabline.end_with?('/') && File.exist?(clean_item) && File.executable?(clean_item) && !File.directory?(clean_item)
            display_item += '*'
          end
          # Get file type color for unselected items (no bold)
          file_color = get_file_color(tabline)
          escaped_tabstr = Regexp.escape(@tabstr)
          if display_item.include?(@tabstr)
            tabline1 = display_item.sub(/(.*?)#{escaped_tabstr}.*/, '\1').c(file_color) # Color before @tabstr
            tabline2 = display_item.sub(/.*?#{escaped_tabstr}(.*)/, '\1').c(file_color) # Color after @tabstr
            print " " + tabline1 + @tabstr.c(file_color).u + tabline2       # Print the whole line
          else
            # For fuzzy matches, just show the whole word
            print " " + display_item.c(file_color)
          end
          # Add metadata if enabled
          if @completion_show_metadata && File.exist?(clean_item)
            if File.directory?(clean_item)
              begin
                count = Dir.entries(clean_item).length - 2
                print " [#{count}]".c(244)
              rescue
              end
            else
              size = File.size(clean_item)
              size_str = size < 1024 ? "#{size}B" :
                         size < 1024*1024 ? "#{(size/1024.0).round(1)}K" :
                         "#{(size/(1024.0*1024)).round(1)}M"
              print " [#{size_str}]".c(244)
            end
          end
        rescue => e
          # Log completion errors if debugging enabled
          File.write("/tmp/rsh_completion.log", "#{Time.now}: Completion error - #{e}\n", mode: 'a') if ENV['RSH_DEBUG']
        end
      end
      nextline      # To not run off screen
    end
    @c.row(@c_row)  # Set cursor row to commandline
    @c.col(@c_col)  # Set cursor col on commandline 
    chr = getchr    # Now get user input
    case chr        # Treat the keypress
    when 'C-G', 'C-C', 'ESC'
      tabend; return
    when 'DOWN'
      i += 1 unless i > @tabarray.length.to_i - 2
    when 'UP'
      i -= 1 unless i == 0
    when 'TAB', 'RIGHT'  # Effectively the same as ENTER 
      chr = "ENTER"
    when 'BACK', 'LEFT'  # Delete one character to the left
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return
      end
      @tabstr.chop!
    when 'WBACK' # Delete one word to the left (Ctrl-W)
      if @tabstr == ""
        @history[0] = @pretab + @postab
        tabend
        return 
      end
      @tabstr.sub!(/#{@tabstr.split(/[|, ]/).last}.*/, '')
    when ' '
      @tabstr += " "
      chr = "ENTER"
    when /^[[:print:]]$/
      @tabstr += chr
      i = 0
    end
  end
  @c.clear_screen_down
  @row0 = @c_row
  @c.row(@c_row)
  @c.col(@c_col)
  @history[0] = @newhist0

  # Track completion selection for learning
  if @completion_learning && @tabarray && @tabarray[i] && type != "hist"
    completion_context = if @pretab && !@pretab.empty?
      @pretab.strip.split(/[|;&]/).last.strip.split.first || "all"
    else
      "all"
    end
    selected = @tabarray[i]
    selected = selected.sub(/\s*(-.*?)[,\s].*/, '\1') if type == "switch"
    track_completion(completion_context, selected)
  end
end
def nextline # Handle going to the next line in the terminal
  row, col = @c.pos
  if row == @maxrow
    @c.scroll_down
    @c_row -= 1
  end
  @c.next_line
end
def tabend
  @c.clear_screen_down
  @pos = @history[0].length
  @c_col = @pos0 + @pos
  @c.col(@c_col)
end
def get_command_switches(command) # Helper function to extract switches from --help
  # Check cache first (cache expires after 1 hour)
  cache_key = command.to_s.strip
  return [] if cache_key.empty?

  current_time = Time.now.to_i
  if @switch_cache[cache_key] && @switch_cache_time[cache_key] && (current_time - @switch_cache_time[cache_key]) < 3600
    return @switch_cache[cache_key]
  end

  # Parse --help output
  hlp = `#{command} --help 2>/dev/null`
  # Try -h if --help didn't work
  hlp = `#{command} -h 2>/dev/null` if hlp.empty?
  return [] if hlp.empty?

  switches = []

  # Method 1: Lines starting with switches (traditional format)
  switches = hlp.split("\n").grep(/^\s*-{1,2}[^-]/)
  switches.map! { |h| h.sub(/^\s*/, '').sub(/^--/, '    --') }
  switches.reject! { |h| /-</ =~ h }

  # Method 2: Extract switches from usage line (git-style format)
  if switches.empty?
    usage_lines = hlp.split("\n").select { |l| l =~ /usage:|Usage:/ }
    usage_lines.each do |line|
      # Extract all switches from the usage line
      line.scan(/(-[a-zA-Z]|--[a-z-]+)/).each do |match|
        switch = match[0]
        switches << (switch.start_with?('--') ? "    #{switch}" : switch)
      end
    end
    switches.uniq!
  end

  # Cache the result (even if empty, to avoid repeated failures)
  @switch_cache[cache_key] = switches
  @switch_cache_time[cache_key] = current_time

  switches
end
def levenshtein_distance(s, t) # Calculate edit distance for smart suggestions
  m = s.length
  n = t.length
  return m if n == 0
  return n if m == 0
  d = Array.new(m+1) {Array.new(n+1)}
  (0..m).each {|i| d[i][0] = i}
  (0..n).each {|j| d[0][j] = j}
  (1..n).each do |j|
    (1..m).each do |i|
      d[i][j] = if s[i-1] == t[j-1]
        d[i-1][j-1]
      else
        [d[i-1][j]+1, d[i][j-1]+1, d[i-1][j-1]+1].min
      end
    end
  end
  d[m][n]
end
def suggest_command(cmd) # Smart command suggestions for typos
  return nil if cmd.nil? || cmd.empty?
  return nil if @exe.include?(cmd) || @nick.include?(cmd)

  # Find commands with small edit distance
  candidates = (@exe + @nick.keys).select do |c|
    next false if c.length < 2
    dist = levenshtein_distance(cmd, c)
    max_dist = [cmd.length / 3, 2].max
    dist <= max_dist && dist > 0
  end

  return nil if candidates.empty?

  # Sort by distance
  candidates.sort_by! { |c| levenshtein_distance(cmd, c) }
  candidates.first(3)
end
def ensure_type(var_name, type, default) # Helper to ensure instance variable has correct type
  var = instance_variable_get(var_name)
  instance_variable_set(var_name, default) unless var.is_a?(type)
end
def persist_var(conf, var_name, value, condition = true) # Helper to persist variable to config
  return conf unless condition
  conf.sub!(/^#{Regexp.escape(var_name)}.*(\n|$)/, "")
  conf += "#{var_name} = #{value.inspect}\n"
  conf
end
def hist_clean # Clean up @history
  @history.compact!
  @history.delete("")

  # Apply deduplication based on mode
  case @history_dedup
  when 'off'
    # No deduplication
  when 'full', 'smart'
    # Remove duplicates, keeping first (most recent) occurrence
    @history.uniq!
  else
    # Default to smart
    @history.uniq!
  end
end
def config(*args) # Configure rsh settings
  setting = args[0]
  value = args[1]

  if setting.nil?
    # Show current configuration
    puts "\n  Current Configuration:".c(@c_prompt).b
    puts "    history_dedup:      #{@history_dedup}"
    puts "    session_autosave:   #{@session_autosave}s #{@session_autosave > 0 ? '(enabled)' : '(disabled)'}"
    puts "    auto_correct:       #{@auto_correct ? 'on' : 'off'}"
    puts "    slow_command_threshold: #{@slow_command_threshold}s #{@slow_command_threshold > 0 ? '(enabled)' : '(disabled)'}"
    puts "    completion_learning: #{@completion_learning ? 'on' : 'off'}"
    puts "    completion_limit:   #{@completion_limit}"
    puts "    completion_fuzzy:   #{@completion_fuzzy}"
    puts "    completion_case_sensitive: #{@completion_case_sensitive}"
    puts
    return
  end

  case setting
  when 'history_dedup'
    if %w[off full smart].include?(value)
      @history_dedup = value
      puts "History deduplication set to '#{value}'"
      rshrc
    else
      puts "Invalid value. Use: off, full, or smart"
    end
  when 'session_autosave'
    @session_autosave = value.to_i
    puts "Session auto-save set to #{value}s #{value.to_i > 0 ? '(enabled)' : '(disabled)'}"
    rshrc
  when 'auto_correct'
    @auto_correct = %w[on true yes 1].include?(value.to_s.downcase)
    puts "Auto-correct #{@auto_correct ? 'enabled' : 'disabled'}"
    rshrc
  when 'slow_command_threshold'
    @slow_command_threshold = value.to_i
    puts "Slow command threshold set to #{value}s #{value.to_i > 0 ? '(enabled)' : '(disabled)'}"
    rshrc
  when 'completion_learning'
    @completion_learning = %w[on true yes 1].include?(value.to_s.downcase)
    puts "Completion learning #{@completion_learning ? 'enabled' : 'disabled'}"
    rshrc
  when 'completion_limit'
    @completion_limit = value.to_i
    puts "Completion limit set to #{value}"
    rshrc
  when 'completion_show_metadata'
    @completion_show_metadata = %w[on true yes 1].include?(value.to_s.downcase)
    puts "Completion metadata display #{@completion_show_metadata ? 'enabled' : 'disabled'}"
    rshrc
  else
    puts "Unknown setting '#{setting}'"
    puts "Available: history_dedup, session_autosave, auto_correct, slow_command_threshold, completion_learning, completion_limit, completion_show_metadata"
  end
end
def env(*args) # Environment variable management
  arg_str = args.join(' ')

  if args.empty?
    # List all environment variables
    puts "\n  Environment Variables:".c(@c_prompt).b
    ENV.sort.first(20).each do |key, value|
      value_display = value.length > 50 ? value[0..47] + '...' : value
      puts "    #{key.c(@c_gnick).ljust(25)} = #{value_display}"
    end
    puts "    ... (#{ENV.length} total, showing first 20)"
    puts "\n  Use :env \"VARNAME\" to see specific variable"
    puts
  elsif arg_str =~ /^set\s+(\w+)\s+(.+)$/
    # Set environment variable
    var_name, var_value = $1, $2
    ENV[var_name] = var_value
    puts "#{var_name} = #{var_value}"
  elsif arg_str =~ /^unset\s+(\w+)$/
    # Unset environment variable
    var_name = $1
    ENV.delete(var_name)
    puts "#{var_name} unset"
  elsif arg_str =~ /^export\s+(.+)$/
    # Export to shell script
    filename = $1
    File.write(filename, ENV.map { |k,v| "export #{k}=\"#{v}\"" }.join("\n"))
    puts "Environment exported to #{filename}"
  else
    # Show specific variable
    var_name = arg_str.strip
    if ENV[var_name]
      puts "#{var_name} = #{ENV[var_name]}"
    else
      puts "Environment variable '#{var_name}' not set"
    end
  end
end
def parse_ls_colors # Parse LS_COLORS into a hash for file type coloring
  @ls_colors = {}

  # Map ANSI basic color codes (30-37, 90-97) to 256-color equivalents
  ansi_to_256 = {
    30 => 0,   # black
    31 => 196, # red -> bright red
    32 => 2,   # green
    33 => 11,  # yellow -> bright yellow
    34 => 33,  # blue -> nice blue
    35 => 13,  # magenta -> nice magenta
    36 => 14,  # cyan -> bright cyan
    37 => 7,   # white
    90 => 8,   # bright black (gray)
    91 => 9,   # bright red
    92 => 10,  # bright green
    93 => 11,  # bright yellow
    94 => 12,  # bright blue
    95 => 13,  # bright magenta
    96 => 14,  # bright cyan
    97 => 15   # bright white
  }

  if ENV['LS_COLORS']
    ENV['LS_COLORS'].split(':').each do |entry|
      next if entry.empty?
      key, value = entry.split('=')
      next unless key && value

      # LS_COLORS can use multiple formats:
      # - "38;5;111" or "38;5;111;1" = 256-color format (use color 111 directly)
      # - "01;34" = ANSI format (bold + basic color 34, needs conversion)
      # - "34" = simple ANSI basic color (needs conversion)

      if value =~ /38;5;(\d+)/ # 256-color format (check this first!)
        @ls_colors[key] = $1.to_i
      elsif value =~ /(\d+);(\d+)/ # ANSI with attributes (e.g., "01;34")
        ansi_code = $2.to_i
        @ls_colors[key] = ansi_to_256[ansi_code] || ansi_code
      elsif value =~ /^(\d+)$/ # Simple ANSI color
        ansi_code = $1.to_i
        @ls_colors[key] = ansi_to_256[ansi_code] || ansi_code
      end
    end
  end

  # Always set defaults (even if LS_COLORS isn't available)
  @ls_colors['di'] ||= 33   # directories = blue
  @ls_colors['ex'] ||= 2    # executables = green
  @ls_colors['ln'] ||= 14   # symlinks = cyan
  @ls_colors['fi'] ||= 7    # regular files = white
end
def get_file_color(filename) # Get color for a file based on LS_COLORS
  return 7 unless @ls_colors  # Default to white if not initialized

  # Remove quotes and trailing slash for checking
  clean_name = filename.gsub(/['"]/, '').chomp('/')

  # Check if it's a symlink (before directory check!)
  if File.symlink?(clean_name)
    return @ls_colors['ln'] || 14  # Symlinks get special color
  end

  # Check if it's a directory
  if filename.end_with?('/')
    return @ls_colors['di'] || 33
  end

  # Check if file exists and is executable
  if File.exist?(clean_name) && File.executable?(clean_name) && !File.directory?(clean_name)
    return @ls_colors['ex'] || 2
  end

  # Check extension patterns (*.jpg, *.tar, etc.)
  ext = File.extname(clean_name)
  if ext && !ext.empty? && @ls_colors["*#{ext}"]
    return @ls_colors["*#{ext}"]
  end

  # Default to regular file color (if 0, use 7/white as 0 means "default" in LS_COLORS)
  file_color = @ls_colors['fi'] || 7
  file_color = 7 if file_color == 0  # 0 means "reset to default" in LS_COLORS
  file_color
end
def get_dir_color(path) # Get color for directory path in prompt
  # Check pattern matches first (like RTFM's @topmatch)
  # Set @dir_colors in .rshrc as array of [pattern, color] pairs
  # Example: @dir_colors = [["PassionFruit", 171], ["Dualog", 72], ["/G", 172], ["", 33]]
  if @dir_colors && @dir_colors.is_a?(Array)
    match = @dir_colors.find { |pattern, _| pattern.empty? || path.include?(pattern) }
    return match.last if match
  end

  # Fall back to LS_COLORS directory color
  @ls_colors['di'] || 33
end
def format_tab_item(item, show_metadata: false) # Format tab item with color and optional metadata
  color = get_file_color(item)
  formatted = item

  # Add executable indicator
  clean_name = item.gsub(/['"]/, '')
  if !item.end_with?('/') && File.exist?(clean_name) && File.executable?(clean_name)
    formatted += '*'
  end

  # Add metadata if requested
  if show_metadata && @completion_show_metadata
    clean_name = clean_name.chomp('/')
    if File.exist?(clean_name)
      if File.directory?(clean_name)
        begin
          count = Dir.entries(clean_name).length - 2  # Exclude . and ..
          meta = "[dir, #{count} items]"
        rescue
          meta = "[dir]"
        end
      else
        size = File.size(clean_name)
        size_str = size < 1024 ? "#{size}B" :
                   size < 1024*1024 ? "#{(size/1024.0).round(1)}K" :
                   "#{(size/(1024.0*1024)).round(1)}M"
        meta = "[#{size_str}]"
      end
      formatted = formatted.ljust(30) + " #{meta}".c(244)
    end
  end

  formatted.c(color)
end
def cmd_check(str) # Check if each element on the readline matches commands, nicks, paths; color them
  return if str.nil?

  # Special handling for @ and @@ commands
  if str =~ /^(@@?)\s+(.*)$/
    prefix = $1
    rest = $2
    return prefix.c(@c_colon) + " " + rest  # Color @ or @@ in colon color
  end

  # Special handling for : commands
  if str =~ /^(:[\w?_]+)/
    colon_cmd = $1
    rest = str.sub(/^:[\w?_]+/, '')
    return colon_cmd.c(@c_colon) + rest  # Color colon commands
  end

  str.gsub(/(?:\S'[^']*'|[^ '])+/) do |el|
    clean_el = el.gsub("'", "")
    # Priority: commands > nicks > bookmarks > paths
    if @exe.include?(el)
      el.c(@c_cmd)
    elsif el == "cd"
      el.c(@c_cmd)
    elsif clean_el =~ /^\.\/(.+)/ && File.exist?(clean_el) && File.executable?(clean_el)
      # Color local executables starting with ./
      el.c(@c_cmd)
    elsif @nick.include?(el)
      el.c(@c_nick)
    elsif el == "r" or el == "f"
      el.c(@c_nick)
    elsif @gnick.include?(el)
      el.c(@c_gnick)
    elsif self.respond_to?(el) && singleton_class.instance_methods(false).include?(el.to_sym)
      el.c(@c_nick).b  # Ruby functions in bold nick color
    elsif @bookmarks && @bookmarks.include?(el)
      # Color bookmarks (after commands and nicks)
      el.c(@c_bookmark)
    elsif File.exist?(clean_el)
      # Use directory color matching for directories, @c_path for files
      if File.directory?(clean_el)
        el.c(get_dir_color(File.expand_path(clean_el)))
      else
        el.c(@c_path)
      end
    elsif el[0] == "-"
      el.c(@c_switch)
    else
      el
    end
  end
end
def rshrc # Write user configuration to .rshrc (portable between machines)
  hist_clean  # Clean history before saving
  if File.exist?(Dir.home+'/.rshrc')
    conf = File.read(Dir.home+'/.rshrc')
  else
    conf = ""
  end

  # Persist user-editable configuration using helper
  conf = persist_var(conf, '@nick', @nick)
  conf = persist_var(conf, '@gnick', @gnick)
  conf = persist_var(conf, '@bookmarks', @bookmarks, !@bookmarks.empty?)
  conf = persist_var(conf, '@defuns', @defuns, !@defuns.empty?)
  conf = persist_var(conf, '@history_dedup', @history_dedup, @history_dedup && @history_dedup != 'smart')
  conf = persist_var(conf, '@session_autosave', @session_autosave, @session_autosave && @session_autosave > 0)
  conf = persist_var(conf, '@auto_correct', @auto_correct, @auto_correct)
  conf = persist_var(conf, '@slow_command_threshold', @slow_command_threshold, @slow_command_threshold && @slow_command_threshold > 0)
  conf = persist_var(conf, '@completion_learning', @completion_learning, !@completion_learning)
  conf = persist_var(conf, '@completion_show_metadata', @completion_show_metadata, @completion_show_metadata)
  conf = persist_var(conf, '@plugin_disabled', @plugin_disabled, !@plugin_disabled.empty?)
  conf = persist_var(conf, '@validation_rules', @validation_rules, !@validation_rules.empty?)

  File.write(Dir.home+'/.rshrc', conf)
  rshstate  # Also save runtime state
end
def rshstate # Write runtime state to .rshstate (auto-managed, machine-specific)
  state = ""

  # Runtime data that changes frequently
  state += "@cmd_frequency = #{@cmd_frequency}\n" unless @cmd_frequency.empty?
  state += "@cmd_stats = #{@cmd_stats}\n" unless @cmd_stats.empty?
  state += "@completion_weights = #{@completion_weights}\n" unless @completion_weights.empty?
  state += "@recordings = #{@recordings}\n" unless @recordings.empty?

  # Persist executable cache for faster startup
  if @exe && @exe.length > 100
    state += "@exe_cache = #{@exe.inspect}\n"
    state += "@exe_cache_path = #{ENV['PATH'].inspect}\n"
    state += "@exe_cache_time = #{Time.now.to_i}\n"
  end

  # Ensure history is properly formatted as valid Ruby array
  begin
    history_str = @history.last(@histsize).inspect
    state += "@history = #{history_str}\n"
  rescue => e
    state += "@history = []\n"
    puts "Warning: Error saving history: #{e.message}" if ENV['RSH_DEBUG']
  end

  File.write(Dir.home+'/.rshstate', state)
end
def migrate_to_split_config # Migrate from old single .rshrc to split .rshrc + .rshstate
  return if File.exist?(Dir.home+'/.rshstate')  # Already migrated
  return unless File.exist?(Dir.home+'/.rshrc')  # Nothing to migrate

  puts "\nMigrating to split configuration (.rshrc + .rshstate)..."

  # Runtime data will already be loaded from .rshrc by load_rshrc_safe
  # Just need to save it to .rshstate and clean .rshrc

  # Create .rshstate with current runtime data
  rshstate

  # Clean runtime data from .rshrc
  conf = File.read(Dir.home+'/.rshrc')
  conf.sub!(/^@cmd_frequency.*(\n|$)/, "")
  conf.sub!(/^@cmd_stats.*(\n|$)/, "")
  conf.sub!(/^@exe_cache.*(\n|$)/, "")
  conf.sub!(/^@exe_cache_path.*(\n|$)/, "")
  conf.sub!(/^@exe_cache_time.*(\n|$)/, "")
  conf.sub!(/^@completion_weights.*(\n|$)/, "")
  conf.sub!(/^@history =.*(\n|$)/, "")
  File.write(Dir.home+'/.rshrc', conf)

  puts "Migration complete!"
  puts "  .rshrc     -> User config (portable)"
  puts "  .rshstate  -> Runtime data (auto-managed)\n"
end

# RSH FUNCTIONS
def help
  # Get terminal width
  term_width = @maxcol || 120
  col_width = 36  # Width for each of 3 columns (wider)

  # Helper function to strip ANSI codes for length calculation
  def strip_ansi(str)
    str.gsub(/\001?\e\[[0-9;]*m\002?/, '')
  end

  col1 = []
  col2 = []
  col3 = []

  # Column 1: Keyboard + Commands + Jobs
  col1 << "KEYBOARD:".c(@c_prompt).b
  col1 << "Ctrl-G    Edit in \$EDITOR"
  col1 << "Ctrl-Y    Copy line"
  col1 << "Ctrl-D    Exit + save"
  col1 << "Ctrl-C    Clear line"
  col1 << "TAB       Complete"
  col1 << "Shift-TAB History search"
  col1 << ""
  col1 << "CORE COMMANDS:".c(@c_prompt).b
  col1 << ":nick a = b      Create alias"
  col1 << ":nick            List all"
  col1 << ":nick -a         Delete"
  col1 << ":defun f()=x     Create function"
  col1 << ":defun           List all"
  col1 << ":defun -f        Delete"
  col1 << ":bm name         Bookmark"
  col1 << ":stats           Analytics"
  col1 << ":validate p=a    Safety rules"
  col1 << ":calc expr       Calculator"
  col1 << ":theme name      Color schemes"
  col1 << ":plugins         Extensions"
  col1 << ""
  col1 << "JOBS:".c(@c_prompt).b
  col1 << "cmd &       Background"
  col1 << ":jobs       List jobs"
  col1 << ":fg [id]    Foreground"

  # Column 2: Sessions + Bookmarks + Recording
  col2 << "SESSIONS:".c(@c_prompt).b
  col2 << ":save_session nm   Save state"
  col2 << ":load_session nm   Load state"
  col2 << ":list_sessions     Show all"
  col2 << ":rmsession nm|*    Delete"
  col2 << ""
  col2 << "BOOKMARKS:".c(@c_prompt).b
  col2 << ":bm nm path #tag   Create"
  col2 << "name               Jump to bookmark"
  col2 << ":bm                List all"
  col2 << ":bm --stats        Statistics"
  col2 << ":bm --export f     Export"
  col2 << ""
  col2 << "RECORDING:".c(@c_prompt).b
  col2 << ":record start nm   Start recording"
  col2 << ":record stop       Stop recording"
  col2 << ":record show nm    Show commands"
  col2 << ":record -nm        Delete"
  col2 << ":replay nm         Execute"
  col2 << ":record            List all"
  col2 << ""
  col2 << "FEATURES:".c(@c_prompt).b
  col2 << "gp branch=main     Nick template"
  col2 << "!!                 Repeat last"
  col2 << "!-2                2nd to last"
  col2 << "!5:7               Chain commands"
  col2 << ":stats --graph     Visual charts"
  col2 << ":completion_stats  Learn patterns"

  # Column 3: Config + Integrations + Expansions
  col3 << "CONFIG:".c(@c_prompt).b
  col3 << ":config auto_correct on         Auto-fix"
  col3 << ":config completion_learning on  Learn TAB"
  col3 << ":config slow_command_threshold 5  Slow warn"
  col3 << ":config session_autosave 300    Auto-save"
  col3 << ":config history_dedup smart     Dedup"
  col3 << ""
  col3 << "INTEGRATIONS:".c(@c_prompt).b
  col3 << "r          rtfm file manager"
  col3 << "f          fzf fuzzy finder"
  col3 << "= expr     xrpn calculator"
  col3 << "@ text     AI text response"
  col3 << "@@ cmd     AI command suggest"
  col3 << ""
  col3 << "EXPANSIONS:".c(@c_prompt).b
  col3 << "~            Home directory"
  col3 << "$VAR         Environment var"
  col3 << "$(cmd)       Command subst"
  col3 << "{a,b,c}      Brace expansion"
  col3 << "cmd1 && cmd2 Conditional AND"
  col3 << "for i in...  Bash scripts"
  col3 << ""
  col3 << "MORE:".c(@c_prompt).b
  col3 << ":help        This help"
  col3 << ":info        About rsh"
  col3 << ":version     Version info"
  col3 << ":history     Show history"
  col3 << ":rehash      Rebuild cache"

  # Pad columns to same length
  max_lines = [col1.length, col2.length, col3.length].max
  col1.fill("", col1.length...max_lines)
  col2.fill("", col2.length...max_lines)
  col3.fill("", col3.length...max_lines)

  # Print in three columns
  puts
  max_lines.times do |i|
    text1 = col1[i].to_s
    text2 = col2[i].to_s
    text3 = col3[i].to_s

    # Calculate padding for each column
    vis1 = strip_ansi(text1).length
    vis2 = strip_ansi(text2).length
    pad1 = col_width - vis1
    pad2 = col_width - vis2
    pad1 = 0 if pad1 < 0
    pad2 = 0 if pad2 < 0

    puts "  #{text1}#{' ' * pad1} #{text2}#{' ' * pad2} #{text3}"
  end
  puts
end
def info
  puts @info
end
def version
  puts "rsh version = #{@version} (latest RubyGems version is #{Gem.latest_version_for("ruby-shell").version} - https://github.com/isene/rsh)"
end
def history # Show most recent history (up to 50 entries)
  puts "History:"
  @history.each_with_index {|h,i| puts i.to_s + "; " + h if i < 50}
end
def rmhistory # Delete history
  @history = []
  puts "History deleted."
end
def rehash # Force rebuild of executable cache
  @exe_cache = nil
  @exe_cache_path = nil
  @exe_cache_time = 0
  @exe_cache_paths = ""
  cache_executables
  puts "Executable cache rebuilt (#{@exe.length} commands cached)."
end
def nick(nick_str = nil)  # Define a new nick like this: `:nick "ls = ls --color"`
  if nick_str.nil? || nick_str.empty?
    # List all nicks
    puts "\n  Command nicks:".c(@c_nick).b
    if @nick.empty?
      puts "  (none defined)"
    else
      @nick.sort.each {|key, value| puts "  #{key.c(@c_nick)} = #{value}"}
    end
    puts
  elsif nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    if @nick.delete(source)
      puts "Nick '#{source}' deleted"
      rshrc
    else
      puts "Nick '#{source}' not found"
    end
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @nick[source] = target
    puts "Nick '#{source}' → '#{target}'"
    rshrc
  end
end
def gnick(nick_str = nil) # Define a generic/global nick to match not only commands (format like nick)
  if nick_str.nil? || nick_str.empty?
    # List all gnicks
    puts "\n  General nicks:".c(@c_gnick).b
    if @gnick.empty?
      puts "  (none defined)"
    else
      @gnick.sort.each {|key, value| puts "  #{key.c(@c_gnick)} = #{value}"}
    end
    puts
  elsif nick_str.match(/^\s*-/)
    source = nick_str.sub(/^\s*-/, '')
    if @gnick.delete(source)
      puts "Gnick '#{source}' deleted"
      rshrc
    else
      puts "Gnick '#{source}' not found"
    end
  else
    source = nick_str.sub(/ =.*/, '')
    target = nick_str.sub(/.*= /, '')
    @gnick[source] = target
    puts "Gnick '#{source}' → '#{target}'"
    rshrc
  end
end
def dirs
  puts "Past direactories:"
  @dirs.each_with_index do |e,i|
    puts "#{i}: #{e}"
  end
end
def jobs
  puts "Active jobs:"
  @jobs.each do |id, job|
    begin
      Process.kill(0, job[:pid])  # Check if process exists
      puts "[#{id}] #{job[:pid]} #{job[:status]} #{job[:cmd]}"
    rescue Errno::ESRCH
      @jobs.delete(id)  # Clean up dead jobs
    end
  end
end
def fg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  puts "Bringing job #{job_id} to foreground: #{job[:cmd]}"
  begin
    if job[:status] == :stopped
      Process.kill("CONT", job[:pid])
    end
    @current_pid = job[:pid]
    Process.wait(job[:pid])
    @jobs.delete(job_id)
    @current_pid = nil
  rescue Errno::ECHILD, Errno::ESRCH
    @jobs.delete(job_id)
    @current_pid = nil
  end
end
def bg(job_id = nil)
  job_id ||= @jobs.keys.max
  return puts "No jobs" if job_id.nil?
  job = @jobs[job_id]
  return puts "Job #{job_id} not found" unless job
  return puts "Job #{job_id} already running" if job[:status] == :running
  puts "Resuming job #{job_id} in background: #{job[:cmd]}"
  begin
    Process.kill("CONT", job[:pid])
    @jobs[job_id][:status] = :running
  rescue Errno::ESRCH
    @jobs.delete(job_id)
    puts "Job #{job_id} no longer exists"
  end
end
def defun(func_def = nil)  # Define a Ruby function like: `:defun myls(*args) = Dir.glob('*').each {|f| puts f}`
  if func_def.nil? || func_def.strip.empty?
    # List all defined functions
    puts "User-defined Ruby functions:"
    all_methods = singleton_class.instance_methods(false)
    excluded = [:defun, :defun?, :execute_conditional, :expand_braces]
    methods = all_methods - excluded
    if methods.empty?
      puts "  (none defined)"
    else
      methods.each do |method|
        puts "  #{method}"
      end
    end
  elsif func_def.match(/^\s*-/)
    # Remove function
    func_name = func_def.sub(/^\s*-/, '').strip
    if self.respond_to?(func_name)
      singleton_class.remove_method(func_name.to_sym)
      @defuns.delete(func_name)
      puts "Function '#{func_name}' removed"
    else
      puts "Function '#{func_name}' not found"
    end
  else
    # Define function
    # Extract function name, params, and body from "name(params) = body" format
    if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
      func_name = $1
      func_params = $2
      func_body = $3

      begin
        eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
        puts "  DEBUG: Evaluating: #{eval_code}" if ENV['RSH_DEBUG']
        singleton_class.class_eval(eval_code)
        @defuns[func_name] = func_def  # Store for persistence
        puts "Function '#{func_name}' defined"
        puts "  DEBUG: Method created? #{respond_to?(func_name)}" if ENV['RSH_DEBUG']
      rescue SyntaxError => e
        puts "Syntax error in function definition: #{e}"
      rescue => e
        puts "Error in function definition: #{e}"
      end
    else
      puts "Invalid function format. Use: name(params) = body"
    end
  end
  rshrc
end
def defun?  # Show all user-defined functions
  puts "User-defined Ruby functions:"
  # Get only methods defined by defun, excluding built-ins and rsh internals
  all_methods = singleton_class.instance_methods(false)
  puts "  All singleton methods: #{all_methods}"
  excluded = [:defun, :defun?, :execute_conditional, :expand_braces]
  methods = all_methods - excluded
  if methods.empty?
    puts "  (none defined after filtering)"
  else
    methods.each do |method|
      puts "  #{method}"
    end
  end
end
def stats(*args) # Show command execution statistics and analytics
  format = args[0]
  filename = args[1]

  if format == "--export"
    # Export to file
    fname = filename || "rsh_stats.json"
    export_stats(fname)
    return
  elsif format == "--json"
    fname = filename || "rsh_stats.json"
    export_stats_json(fname)
    return
  elsif format == "--csv"
    fname = filename || "rsh_stats.csv"
    export_stats_csv(fname)
    return
  elsif format == "--graph"
    stats_graph
    return
  elsif format == "--clear"
    # Clear all statistics
    @cmd_frequency = {}
    @cmd_stats = {}
    puts "All statistics cleared"
    rshrc
    return
  end

  # Display stats (existing code)
  puts "\n  Command Execution Statistics".c(@c_prompt).b
  puts "  " + "="*50

  # Most used commands
  if @cmd_frequency && !@cmd_frequency.empty?
    puts "\n  Top 10 Most Used Commands:".c(@c_nick)
    sorted = @cmd_frequency.sort_by { |_, count| -count }.first(10)
    sorted.each_with_index do |(cmd, count), i|
      bar = "■" * ([count / 5, 20].min)
      puts "  #{(i+1).to_s.rjust(2)}. #{cmd.ljust(20)} #{count.to_s.rjust(5)}x #{bar.c(@c_path)}"
    end
  end

  # Command statistics from @cmd_stats
  if @cmd_stats && !@cmd_stats.empty?
    total_time = @cmd_stats.values.map { |s| s[:total_time] || 0 }.sum
    total_cmds = @cmd_stats.values.map { |s| s[:count] || 0 }.sum

    puts "\n  Performance Statistics:".c(@c_nick)
    puts "  Total commands executed: #{total_cmds}"
    puts "  Total execution time: #{'%.2f' % total_time}s"
    puts "  Average time per command: #{'%.2f' % (total_time / total_cmds)}s" if total_cmds > 0

    puts "\n  Slowest Commands:".c(@c_nick)
    slowest = @cmd_stats.sort_by { |_, s| -(s[:avg_time] || 0) }.first(5)
    slowest.each_with_index do |(cmd, stats), i|
      puts "  #{(i+1).to_s.rjust(2)}. #{cmd.ljust(20)} avg: #{'%.3f' % (stats[:avg_time] || 0)}s"
    end
  end

  # History statistics
  puts "\n  History Statistics:".c(@c_nick)
  puts "  Total history entries: #{@history.length}"
  puts "  Unique commands: #{@history.uniq.length}"

  # Success/failure tracking
  puts "\n  Last command exit status: #{@last_exit == 0 ? 'Success'.c(@c_path) : "Failed (#{@last_exit})".c(196)}"
  puts
end
def stats_graph # Visual graph mode for stats
  puts "\n  Command Usage Graph".c(@c_prompt).b
  puts "  " + "="*50

  return puts "No data to display" if @cmd_frequency.nil? || @cmd_frequency.empty?

  sorted = @cmd_frequency.sort_by { |_, count| -count }.first(15)
  max_count = sorted.first[1]
  max_width = 40

  puts
  sorted.each_with_index do |(cmd, count), i|
    # Calculate bar width (scaled to max_width)
    bar_width = (count.to_f / max_count * max_width).round
    bar = "█" * bar_width

    # Color bars by intensity
    color = case bar_width
    when 0..10 then 244    # Gray
    when 11..20 then 3     # Yellow
    when 21..30 then 214   # Orange
    else 196               # Red
    end

    puts "  #{cmd.ljust(15)} #{count.to_s.rjust(4)}x #{bar.c(color)}"
  end

  # Performance graph if data exists
  if @cmd_stats && !@cmd_stats.empty?
    puts "\n  Command Performance Graph (avg time)".c(@c_prompt).b
    puts "  " + "="*50
    puts

    slowest = @cmd_stats.sort_by { |_, s| -(s[:avg_time] || 0) }.first(10)
    max_time = slowest.first[1][:avg_time]

    slowest.each do |cmd, stats|
      bar_width = (stats[:avg_time] / max_time * max_width).round
      bar = "█" * bar_width

      color = case bar_width
      when 0..10 then 2      # Green (fast)
      when 11..20 then 214   # Orange
      else 196               # Red (slow)
      end

      time_str = "#{'%.3f' % stats[:avg_time]}s"
      puts "  #{cmd.ljust(15)} #{time_str.rjust(8)} #{bar.c(color)}"
    end
  end

  puts
end
def export_stats(filename) # Export stats to file (JSON or CSV based on extension)
  if filename.end_with?('.csv')
    export_stats_csv(filename)
  else
    filename += '.json' unless filename.end_with?('.json')
    export_stats_json(filename)
  end
end
def export_stats_json(filename = 'rsh_stats.json') # Export stats to JSON
  stats_data = {
    generated: Time.now.to_i,
    cmd_frequency: @cmd_frequency,
    cmd_stats: @cmd_stats,
    history: {
      total: @history.length,
      unique: @history.uniq.length
    },
    last_exit: @last_exit
  }
  begin
    require 'json'
    File.write(filename, JSON.pretty_generate(stats_data))
    puts "Stats exported to #{filename}"
  rescue => e
    puts "Error exporting stats: #{e.message}"
  end
end
def export_stats_csv(filename = 'rsh_stats.csv') # Export stats to CSV
  begin
    lines = []
    lines << "command,frequency,count,total_time,avg_time"

    # Merge frequency and performance data
    all_cmds = (@cmd_frequency.keys + @cmd_stats.keys).uniq
    all_cmds.sort.each do |cmd|
      freq = @cmd_frequency[cmd] || 0
      count = @cmd_stats.dig(cmd, :count) || 0
      total = @cmd_stats.dig(cmd, :total_time) || 0.0
      avg = @cmd_stats.dig(cmd, :avg_time) || 0.0
      lines << "#{cmd},#{freq},#{count},#{'%.3f' % total},#{'%.3f' % avg}"
    end

    File.write(filename, lines.join("\n"))
    puts "Stats exported to #{filename}"
  rescue => e
    puts "Error exporting stats: #{e.message}"
  end
end
def bm(arg_str = nil) # Enhanced bookmark management with tags
  if arg_str.nil? || arg_str.empty?
    # List all bookmarks
    if @bookmarks.empty?
      puts "No bookmarks defined. Use :bm \"name\" to bookmark current directory"
      return
    end
    puts "\n  Bookmarks:".c(@c_prompt).b
    @bookmarks.each do |name, data|
      path = data.is_a?(Hash) ? data[:path] : data
      tags = data.is_a?(Hash) && data[:tags] ? " [#{data[:tags].join(', ')}]" : ""
      puts "  #{name.c(@c_nick)} → #{path}#{tags.c(@c_stamp)}"
    end
    puts
  elsif arg_str =~ /^--export\s*(.*)/
    # Export bookmarks to file
    filename = $1.strip
    filename = 'bookmarks.json' if filename.empty?
    export_bookmarks(filename)
  elsif arg_str =~ /^--import\s+(.*)/
    # Import bookmarks from file
    filename = $1.strip
    import_bookmarks(filename) if filename
  elsif arg_str == '--stats'
    # Show bookmark statistics
    bookmark_stats
  elsif arg_str =~ /^(\w+)\s+(.+)$/
    # Set bookmark with optional tags
    name, rest = $1, $2
    if rest.include?('#')
      path_part, tag_part = rest.split('#', 2)
      path = path_part.strip
      path = Dir.pwd if path.empty?
      tags = tag_part.split(',').map(&:strip)
      @bookmarks[name] = {path: path, tags: tags}
    else
      @bookmarks[name] = {path: rest.strip, tags: []}
    end
    puts "Bookmark '#{name}' set to #{@bookmarks[name][:path]}"
    rshrc
  elsif arg_str =~ /^-(\w+)$/
    # Delete bookmark
    name = $1
    if @bookmarks.delete(name)
      puts "Bookmark '#{name}' deleted"
      rshrc
    else
      puts "Bookmark '#{name}' not found"
    end
  elsif arg_str =~ /^\?(\w*)$/
    # Search bookmarks by tag
    tag = $1
    if tag.empty?
      puts "Available tags:"
      all_tags = @bookmarks.values.flat_map { |d| d.is_a?(Hash) ? d[:tags] : [] }.uniq.sort
      puts "  " + all_tags.join(", ")
    else
      matches = @bookmarks.select do |_, data|
        data.is_a?(Hash) && data[:tags] && data[:tags].include?(tag)
      end
      if matches.empty?
        puts "No bookmarks with tag '#{tag}'"
      else
        puts "Bookmarks with tag '#{tag}':"
        matches.each { |name, data| puts "  #{name} → #{data[:path]}" }
      end
    end
  else
    # Bookmark current directory
    name = arg_str.strip
    @bookmarks[name] = {path: Dir.pwd, tags: []}
    puts "Bookmark '#{name}' set to #{Dir.pwd}"
    rshrc
  end
end
def bookmark(arg_str = nil) # Alias for bm
  bm(arg_str)
end
def export_bookmarks(filename = 'bookmarks.json') # Export bookmarks to JSON
  begin
    require 'json'
    File.write(filename, JSON.pretty_generate(@bookmarks))
    puts "Bookmarks exported to #{filename}"
  rescue => e
    puts "Error exporting bookmarks: #{e.message}"
  end
end
def import_bookmarks(filename) # Import bookmarks from JSON
  unless File.exist?(filename)
    puts "File '#{filename}' not found"
    return
  end
  begin
    require 'json'
    imported = JSON.parse(File.read(filename))
    imported.each do |name, data|
      # Convert to proper format
      if data.is_a?(Hash)
        @bookmarks[name] = {
          path: data['path'] || data[:path],
          tags: data['tags'] || data[:tags] || []
        }.transform_keys(&:to_sym)
      else
        @bookmarks[name] = {path: data.to_s, tags: []}
      end
    end
    puts "Imported #{imported.length} bookmarks from #{filename}"
    rshrc
  rescue => e
    puts "Error importing bookmarks: #{e.message}"
  end
end
def bookmark_stats # Show bookmark usage statistics
  if @bookmarks.empty?
    puts "No bookmarks defined"
    return
  end

  puts "\n  Bookmark Statistics".c(@c_prompt).b
  puts "  " + "="*50
  puts "\n  Total bookmarks: #{@bookmarks.length}"

  # Count by tags
  all_tags = @bookmarks.values.flat_map { |d| d.is_a?(Hash) ? (d[:tags] || []) : [] }
  unless all_tags.empty?
    puts "\n  Tags Distribution:".c(@c_nick)
    tag_counts = all_tags.group_by(&:itself).transform_values(&:count)
    tag_counts.sort_by { |_, count| -count }.each do |tag, count|
      puts "    #{tag.ljust(15)} #{count}x"
    end
  end

  # Bookmarks by directory depth
  puts "\n  Path Analysis:".c(@c_nick)
  paths = @bookmarks.values.map { |d| d.is_a?(Hash) ? d[:path] : d }
  avg_depth = paths.map { |p| p.split('/').length }.sum / paths.length
  puts "    Average path depth: #{avg_depth}"
  puts
end
def save_session(*args) # Save current session state
  session_name = args[0] || 'default'
  silent = args[1] == :silent  # Optional silent flag
  session_path = @session_dir + "/#{session_name}.json"

  session = {
    name: session_name,
    pwd: Dir.pwd,
    history: @history.first(50),
    bookmarks: @bookmarks,
    defuns: @defuns,
    timestamp: Time.now.to_i
  }
  begin
    require 'json'
    File.write(session_path, JSON.pretty_generate(session))
    puts "Session '#{session_name}' saved to #{session_path}" unless silent
  rescue => e
    puts "Error saving session: #{e.message}" unless silent
  end
end
def load_session(*args) # Restore previous session
  session_name = args[0] || 'default'
  session_path = @session_dir + "/#{session_name}.json"

  unless File.exist?(session_path)
    puts "Session '#{session_name}' not found"
    list_sessions
    return
  end
  begin
    require 'json'
    session = JSON.parse(File.read(session_path), symbolize_names: true)

    # Restore state
    Dir.chdir(session[:pwd]) if session[:pwd] && Dir.exist?(session[:pwd])

    # Merge history (prepend saved history)
    if session[:history]
      @history = (session[:history] + @history).uniq.first(@histsize)
    end

    # Restore bookmarks
    if session[:bookmarks]
      session[:bookmarks].each do |name, data|
        bookmark_data = data.is_a?(Hash) ? data.transform_keys(&:to_sym) : data
        @bookmarks[name.to_s] = bookmark_data
      end
    end

    # Restore defuns
    if session[:defuns]
      session[:defuns].each do |name, func_def|
        next unless func_def.is_a?(String)
        @defuns[name.to_s] = func_def
        # Re-evaluate the function
        if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
          func_name, func_params, func_body = $1, $2, $3
          eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
          singleton_class.class_eval(eval_code) rescue nil
        end
      end
    end

    saved_time = Time.at(session[:timestamp] || 0).strftime("%Y-%m-%d %H:%M:%S")
    puts "Session '#{session_name}' restored from #{saved_time}"
    rshrc
  rescue => e
    puts "Error loading session: #{e.message}"
  end
end
def list_sessions # List all saved sessions
  unless Dir.exist?(@session_dir)
    puts "No sessions directory found"
    return
  end

  sessions = Dir.glob(@session_dir + '/*.json').map { |f| File.basename(f, '.json') }

  if sessions.empty?
    puts "No saved sessions found. Use :save_session \"name\" to create one"
    return
  end

  puts "\n  Saved Sessions:".c(@c_prompt).b
  sessions.sort.each do |name|
    session_path = @session_dir + "/#{name}.json"
    begin
      require 'json'
      session = JSON.parse(File.read(session_path), symbolize_names: true)
      timestamp = Time.at(session[:timestamp] || 0).strftime("%Y-%m-%d %H:%M")
      pwd = session[:pwd] || '?'
      puts "  #{name.c(@c_bookmark).ljust(20)} #{timestamp.c(@c_stamp)} #{pwd.c(@c_path)}"
    rescue => e
      puts "  #{name.c(@c_bookmark).ljust(20)} [corrupted]".c(196)
    end
  end
  puts
end
def delete_session(*args) # Delete a saved session
  name = args[0]

  if name == '*'
    # Delete all sessions except default
    sessions = Dir.glob(@session_dir + '/*.json').map { |f| File.basename(f, '.json') }
    sessions.reject! { |s| s == 'default' || s == 'autosave' }

    if sessions.empty?
      puts "No sessions to delete (keeping default and autosave)"
      return
    end

    sessions.each do |session_name|
      session_path = @session_dir + "/#{session_name}.json"
      File.delete(session_path)
    end
    puts "Deleted #{sessions.length} sessions: #{sessions.join(', ')}"
    return
  end

  return puts "Cannot delete default session" if name == 'default'
  return puts "Cannot delete autosave session (use * to delete all)" if name == 'autosave'

  session_path = @session_dir + "/#{name}.json"
  unless File.exist?(session_path)
    puts "Session '#{name}' not found"
    return
  end

  File.delete(session_path)
  puts "Session '#{name}' deleted"
end
def rmsession(*args) # Alias for delete_session
  delete_session(*args)
end
def theme(*args) # Apply color scheme presets
  name = args[0]

  if name.nil?
    puts "\n  Available themes:".c(@c_prompt).b
    puts "    default, solarized, dracula, gruvbox, nord, monokai"
    puts "\n  Current theme colors:"
    puts "    prompt:#{' '*5}#{@c_prompt}   cmd:#{' '*8}#{@c_cmd}   nick:#{' '*7}#{@c_nick}"
    puts "    gnick:#{' '*6}#{@c_gnick}   path:#{' '*7}#{@c_path}   switch:#{' '*5}#{@c_switch}"
    puts "    bookmark:#{' '*3}#{@c_bookmark}   colon:#{' '*6}#{@c_colon}   tabselect:#{' '*2}#{@c_tabselect}"
    puts "    taboption:#{' '*2}#{@c_taboption}   stamp:#{' '*6}#{@c_stamp}"
    puts
    return
  end

  case name.downcase
  when 'default'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 10, 2, 6, 14
    @c_path, @c_switch, @c_bookmark, @c_colon = 3, 6, 13, 4
    @c_tabselect, @c_taboption, @c_stamp = 5, 244, 244
  when 'solarized'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 33, 64, 37, 117
    @c_path, @c_switch, @c_bookmark, @c_colon = 136, 125, 61, 33
    @c_tabselect, @c_taboption, @c_stamp = 166, 240, 240
  when 'dracula'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 141, 84, 117, 212
    @c_path, @c_switch, @c_bookmark, @c_colon = 228, 215, 141, 141
    @c_tabselect, @c_taboption, @c_stamp = 212, 238, 238
  when 'gruvbox'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 214, 142, 109, 175
    @c_path, @c_switch, @c_bookmark, @c_colon = 208, 142, 167, 214
    @c_tabselect, @c_taboption, @c_stamp = 208, 243, 243
  when 'nord'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 110, 109, 116, 152
    @c_path, @c_switch, @c_bookmark, @c_colon = 180, 109, 139, 110
    @c_tabselect, @c_taboption, @c_stamp = 143, 240, 240
  when 'monokai'
    @c_prompt, @c_cmd, @c_nick, @c_gnick = 197, 112, 81, 141
    @c_path, @c_switch, @c_bookmark, @c_colon = 228, 208, 141, 197
    @c_tabselect, @c_taboption, @c_stamp = 197, 238, 238
  else
    puts "Unknown theme '#{name}'. Available: default, solarized, dracula, gruvbox, nord, monokai"
    return
  end

  puts "Theme '#{name}' applied"
  puts "Add this to .rshrc to make it permanent: :theme \"#{name}\""
end
def load_plugins # Load all plugins from plugin directory
  return unless Dir.exist?(@plugin_dir)

  plugin_files = Dir.glob(@plugin_dir + '/*.rb').sort

  plugin_files.each do |plugin_file|
    plugin_name = File.basename(plugin_file, '.rb')

    # Only load if explicitly enabled (whitelist)
    next unless @plugin_enabled.include?(plugin_name)

    begin
      # Load the plugin file
      load(plugin_file)

      # Find the plugin class (conventionally PluginNamePlugin)
      class_name = plugin_name.split('_').map(&:capitalize).join + 'Plugin'

      # Try to instantiate the plugin
      if Object.const_defined?(class_name)
        plugin_class = Object.const_get(class_name)
        rsh_context = {
          version: @version,
          history: @history,
          bookmarks: @bookmarks,
          nick: @nick,
          gnick: @gnick,
          pwd: Dir.pwd,
          config: method(:config),
          rsh: self
        }
        plugin_instance = plugin_class.new(rsh_context)
        @plugins << { name: plugin_name, instance: plugin_instance, class: class_name }

        # Load plugin completions
        if plugin_instance.respond_to?(:add_completions)
          completions = plugin_instance.add_completions
          @cmd_completions.merge!(completions) if completions.is_a?(Hash)
        end

        # Load plugin commands
        if plugin_instance.respond_to?(:add_commands)
          commands = plugin_instance.add_commands
          @plugin_commands.merge!(commands) if commands.is_a?(Hash)
        end

        puts "  Loaded plugin: #{plugin_name} (#{class_name})" if ENV['RSH_DEBUG']
      end
    rescue => e
      puts "Warning: Failed to load plugin '#{plugin_name}': #{e.message}" if ENV['RSH_DEBUG']
      puts "  #{e.backtrace.first}" if ENV['RSH_DEBUG']
    end
  end

  # Call on_startup for all plugins
  @plugins.each do |plugin|
    begin
      plugin[:instance].on_startup if plugin[:instance].respond_to?(:on_startup)
    rescue => e
      puts "Warning: Plugin '#{plugin[:name]}' on_startup failed: #{e.message}" if ENV['RSH_DEBUG']
    end
  end
end
def call_plugin_hook(hook_name, *args) # Call a lifecycle hook for all plugins
  results = []
  @plugins.each do |plugin|
    begin
      if plugin[:instance].respond_to?(hook_name)
        result = plugin[:instance].send(hook_name, *args)
        results << result unless result.nil?
      end
    rescue => e
      puts "Warning: Plugin '#{plugin[:name]}' hook '#{hook_name}' failed: #{e.message}" if ENV['RSH_DEBUG']
    end
  end
  results
end
def plugins(*args) # Plugin management command
  if args.empty?
    # List all available plugins
    available_plugins = Dir.exist?(@plugin_dir) ? Dir.glob(@plugin_dir + '/*.rb').map { |f| File.basename(f, '.rb') }.sort : []

    if available_plugins.empty?
      puts "\nNo plugins found"
      puts "Place .rb files in #{@plugin_dir}"
      return
    end

    puts "\n  Available Plugins:".c(@c_prompt).b
    available_plugins.each do |name|
      if @plugin_enabled.include?(name)
        status = '[enabled]'.c(@c_path)
        plugin = @plugins.find { |p| p[:name] == name }
        class_info = plugin ? " (#{plugin[:class]})" : ""
      else
        status = '[disabled]'.c(196)
        class_info = ""
      end
      puts "    #{name.ljust(20)} #{status}#{class_info}"
    end
    puts
  elsif args[0] == 'reload'
    # Reload all plugins
    @plugins = []
    @plugin_commands = {}
    load_plugins
    puts "Plugins reloaded (#{@plugins.length} loaded)"
  elsif args[0] == 'enable' && args[1]
    # Enable a plugin
    plugin_name = args[1]
    unless @plugin_enabled.include?(plugin_name)
      @plugin_enabled << plugin_name
    end
    puts "Plugin '#{plugin_name}' enabled. Use :plugins reload to load it"
    rshrc
  elsif args[0] == 'disable' && args[1]
    # Disable a plugin
    plugin_name = args[1]
    @plugin_enabled.delete(plugin_name)
    @plugins.reject! { |p| p[:name] == plugin_name }
    puts "Plugin '#{plugin_name}' disabled"
    rshrc
  elsif args[0] == 'info' && args[1]
    # Show plugin info
    plugin_name = args[1]
    plugin = @plugins.find { |p| p[:name] == plugin_name }
    if plugin
      puts "\n  Plugin: #{plugin_name}".c(@c_prompt).b
      puts "    Class: #{plugin[:class]}"
      puts "    File: #{@plugin_dir}/#{plugin_name}.rb"

      puts "\n  Hooks:".c(@c_nick)
      %i[on_startup on_command_before on_command_after on_prompt].each do |hook|
        has_hook = plugin[:instance].respond_to?(hook) ? '✓' : '✗'
        puts "    #{has_hook} #{hook}"
      end

      puts "\n  Extensions:".c(@c_nick)
      puts "    ✓ add_completions" if plugin[:instance].respond_to?(:add_completions)
      puts "    ✓ add_commands" if plugin[:instance].respond_to?(:add_commands)
      puts
    else
      puts "Plugin '#{plugin_name}' not found"
    end
  elsif args[0] == 'help' && args[1]
    # Show plugin help
    plugin_name = args[1]
    plugin_file = "#{@plugin_dir}/#{plugin_name}.rb"

    if File.exist?(plugin_file)
      content = File.read(plugin_file)

      # Extract help block (lines starting with # at top of file)
      help_lines = []
      in_help = true
      content.each_line do |line|
        if in_help && line =~ /^#\s*(.*)$/
          help_text = $1
          next if help_text =~ /^-+$/ # Skip separator lines
          help_lines << help_text
        elsif line.strip.empty?
          next
        else
          in_help = false
          break
        end
      end

      if help_lines.any?
        puts "\n#{help_lines.join("\n")}\n"
      else
        puts "No help available for plugin '#{plugin_name}'"
      end

      # Extract and show available commands
      commands = []
      content.scan(/def (\w+)\(/) { |match| commands << match[0] unless match[0] == 'initialize' }

      if commands.any?
        puts "\nCommands: #{commands.join(', ')}".c(@c_nick)
        puts
      end
    else
      puts "Plugin '#{plugin_name}' not found"
      puts "Available plugins:"
      Dir.glob(@plugin_dir + '/*.rb').each do |file|
        puts "  #{File.basename(file, '.rb')}"
      end
    end
  else
    puts "Usage:"
    puts "  :plugins              List all plugins"
    puts "  :plugins reload       Reload all plugins"
    puts "  :plugins enable NAME  Enable a plugin"
    puts "  :plugins disable NAME Disable a plugin"
    puts "  :plugins info NAME    Show plugin details"
    puts "  :plugins help NAME    Show plugin help/usage"
  end
end
def validate_command(cmd) # Syntax validation before execution
  return nil if cmd.nil? || cmd.empty?
  warnings = []

  # Apply custom validation rules first
  custom_warnings = apply_validation_rules(cmd)
  warnings.concat(custom_warnings) if custom_warnings.any?

  # Check for common mistakes
  warnings << "Unmatched quotes" if cmd.count("'").odd? || cmd.count('"').odd?
  warnings << "Unmatched parentheses" if cmd.count("(") != cmd.count(")")
  warnings << "Unmatched brackets" if cmd.count("[") != cmd.count("]")
  warnings << "Unmatched braces" if cmd.count("{") != cmd.count("}")

  # Check for potentially dangerous patterns (unless user has custom rules)
  warnings << "WARNING: Recursive rm detected" if cmd =~ /rm\s+.*-r.*\//
  warnings << "WARNING: Force flag without path" if cmd =~ /rm\s+-[rf]+\s*$/
  warnings << "WARNING: Sudo with redirection" if cmd =~ /sudo.*>/

  # Check for common typos in popular commands (skip for : commands)
  if cmd =~ /^(\w+)/ && cmd !~ /^:/
    first_cmd = $1
    # Check if command exists (don't warn for valid commands)
    is_valid_cmd = @exe.include?(first_cmd) ||
                   @nick.include?(first_cmd) ||
                   first_cmd == "cd" ||
                   (@plugin_commands && @plugin_commands[first_cmd]) ||
                   (@defuns && @defuns.keys.include?(first_cmd))

    unless is_valid_cmd
      suggestions = suggest_command(first_cmd)
      if suggestions && !suggestions.empty?
        # Auto-correct if enabled and first suggestion has distance ≤ 2
        if @auto_correct && levenshtein_distance(first_cmd, suggestions[0]) <= 2
          warnings << "AUTO-CORRECTING: '#{first_cmd}' → '#{suggestions[0]}'"
        else
          warnings << "Command '#{first_cmd}' not found. Did you mean: #{suggestions.join(', ')}?"
        end
      end
    end
  end

  warnings.empty? ? nil : warnings
end
def calc(*args) # Inline calculator using Ruby's Math library
  if args.empty?
    puts "Usage: :calc <expression>"
    puts "Examples:"
    puts "  :calc 2 + 2"
    puts "  :calc Math.sqrt(16)"
    puts "  :calc Math::PI * 2"
    puts "  :calc sin(PI/4)"
    puts "Available: +, -, *, /, **, %, sqrt, sin, cos, tan, log, exp, abs, PI, E, etc."
    return
  end

  expression = args.join(' ')

  # Create sandbox with Math module for safer evaluation
  sandbox = Object.new
  sandbox.extend(Math)

  begin
    result = sandbox.instance_eval(expression)
    puts result
  rescue ZeroDivisionError
    puts "Error: Division by zero"
  rescue NameError => e
    # Extract the undefined name
    if e.message =~ /undefined local variable or method `(\w+)'/
      undefined = $1
      puts "Error: Unknown function or variable '#{undefined}'"
      puts "Available Math functions: sqrt, sin, cos, tan, log, exp, abs, ceil, floor, round"
      puts "Constants: PI, E"
    else
      puts "Error: #{e.message}"
    end
  rescue SyntaxError => e
    puts "Error: Invalid expression syntax"
    puts "Check parentheses, operators, and spacing"
  rescue ArgumentError => e
    puts "Error: Invalid argument - #{e.message}"
  rescue TypeError => e
    puts "Error: Type mismatch - #{e.message}"
  rescue => e
    puts "Error: #{e.message}"
  end
end
def validate(rule_str = nil) # Custom validation rule management
  if rule_str.nil? || rule_str.empty?
    # List all validation rules
    if @validation_rules.empty?
      puts "\nNo validation rules defined"
      puts "Usage: :validate pattern = action"
      puts "Actions: block, confirm, warn, log"
      return
    end
    puts "\n  Validation Rules:".c(@c_prompt).b
    @validation_rules.each_with_index do |rule, i|
      puts "  #{i+1}. #{rule[:pattern].inspect} → #{rule[:action]}"
    end
    puts
  elsif rule_str =~ /^-(\d+)$/
    # Delete rule by index
    index = $1.to_i - 1
    if index >= 0 && index < @validation_rules.length
      rule = @validation_rules.delete_at(index)
      puts "Validation rule deleted: #{rule[:pattern]}"
      rshrc
    else
      puts "Invalid rule index: #{$1}"
    end
  elsif rule_str =~ /^(.+?)\s*=\s*(block|confirm|warn|log)$/
    # Add validation rule
    pattern = $1.strip
    action = $2.strip
    @validation_rules << {pattern: pattern, action: action}
    puts "Validation rule added: #{pattern} → #{action}"
    rshrc
  else
    puts "Usage: :validate pattern = action"
    puts "Example: :validate rm -rf / = block"
    puts "Actions: block (prevent), confirm (ask), warn (show), log (record)"
  end
end
def apply_validation_rules(cmd) # Apply custom validation rules
  return [] if @validation_rules.nil? || @validation_rules.empty?

  warnings = []

  @validation_rules.each do |rule|
    if cmd =~ /#{rule[:pattern]}/
      case rule[:action]
      when 'block'
        warnings << "BLOCKED by rule: #{rule[:pattern]}"
      when 'confirm'
        warnings << "CONFIRM required: #{rule[:pattern]}"
      when 'warn'
        warnings << "Warning: Matches rule '#{rule[:pattern]}'"
      when 'log'
        File.write("#{ENV['HOME']}/.rsh_validation.log",
                   "#{Time.now}: #{cmd} (matched: #{rule[:pattern]})\n",
                   mode: 'a')
      end
    end
  end

  warnings
end
def track_completion(context, selected) # Track completion selection for learning
  return unless @completion_learning
  return if context.nil? || selected.nil?

  key = "#{context}:#{selected}"
  @completion_weights[key] ||= 0
  @completion_weights[key] += 1
end
def sort_by_learning(context, items) # Sort completions by learning weights
  return items unless @completion_learning
  return items if @completion_weights.empty?

  # Score each item
  scored = items.map do |item|
    # Extract just the switch/command part (before space/description)
    item_key = item.split(/\s+/).first
    key = "#{context}:#{item_key}"
    weight = @completion_weights[key] || 0
    {item: item, weight: weight}
  end

  # Sort: highest weight first, then alphabetically
  scored.sort_by { |s| [-s[:weight], s[:item]] }.map { |s| s[:item] }
end
def completion_stats # Show completion learning statistics
  if @completion_weights.empty?
    puts "\nNo completion learning data yet"
    puts "Use TAB completion and selections will be learned over time"
    return
  end

  puts "\n  Completion Learning Statistics".c(@c_prompt).b
  puts "  " + "="*50

  # Group by context
  by_context = {}
  @completion_weights.each do |key, weight|
    context, choice = key.split(':', 2)
    by_context[context] ||= []
    by_context[context] << {choice: choice, weight: weight}
  end

  # Show top contexts
  by_context.sort_by { |ctx, items| -items.map { |i| i[:weight] }.sum }.first(10).each do |context, items|
    puts "\n  #{context}:".c(@c_nick)
    items.sort_by { |i| -i[:weight] }.first(5).each do |item|
      bar = "■" * ([item[:weight] / 2, 20].min)
      puts "    #{item[:choice].ljust(20)} #{item[:weight].to_s.rjust(3)}x #{bar.c(@c_path)}"
    end
  end

  puts "\n  Total learned patterns: #{@completion_weights.length}"
  puts
end
def completion_reset # Reset all completion learning
  @completion_weights = {}
  puts "Completion learning data cleared"
  rshrc
end
def record(*args) # Command recording management
  action = args[0]
  name = args[1]

  if action.nil? || action.empty?
    # List recordings
    if @recordings.empty?
      puts "\nNo recordings. Use: :record start name"
      return
    end

    puts "\n  Recordings:".c(@c_prompt).b
    @recordings.each do |rec_name, data|
      created = Time.at(data[:created] || Time.now.to_i).strftime("%Y-%m-%d %H:%M")
      count = data[:commands]&.length || 0
      puts "  #{rec_name.ljust(20)} #{count.to_s.rjust(3)} commands  #{created}"
    end
    puts

    # Show if currently recording
    if @recording[:active]
      puts "  Currently recording: #{@recording[:name]} (#{@recording[:commands].length} commands so far)".c(214)
    end
  elsif action == 'start' && name
    @recording[:active] = true
    @recording[:name] = name
    @recording[:commands] = []
    @recording[:start_time] = Time.now.to_i
    puts "Recording started: #{name}".c(@c_path)
  elsif action == 'stop'
    if @recording[:active]
      @recordings[@recording[:name]] = {
        commands: @recording[:commands],
        created: @recording[:start_time]
      }
      puts "Recording stopped: #{@recording[:name]} (#{@recording[:commands].length} commands)".c(@c_path)
      @recording[:active] = false
      rshrc
    else
      puts "No active recording"
    end
  elsif action == 'status'
    if @recording[:active]
      puts "Recording: #{@recording[:name]} (#{@recording[:commands].length} commands)"
      @recording[:commands].last(5).each { |cmd| puts "  #{cmd}" }
    else
      puts "No active recording"
    end
  elsif action == 'show' && name
    # Show recording contents
    unless @recordings[name]
      puts "Recording '#{name}' not found"
      return
    end

    recording = @recordings[name]
    created = Time.at(recording[:created] || Time.now.to_i).strftime("%Y-%m-%d %H:%M:%S")

    puts "\n  Recording: #{name}".c(@c_prompt).b
    puts "  Created: #{created}"
    puts "  Commands: #{recording[:commands].length}"
    puts

    recording[:commands].each_with_index do |cmd, i|
      puts "  #{(i+1).to_s.rjust(3)}. #{cmd}"
    end
    puts
  elsif action =~ /^-(.+)$/
    # Delete recording
    rec_name = $1
    if @recordings.delete(rec_name)
      puts "Recording '#{rec_name}' deleted"
      rshrc
    else
      puts "Recording '#{rec_name}' not found"
    end
  else
    puts "Usage: :record start name|stop|status|show name|-name"
  end
end
def replay(*args) # Replay recorded commands
  name = args[0]

  unless name && @recordings[name]
    puts "Recording '#{name}' not found"
    record
    return
  end

  recording = @recordings[name]
  commands = recording[:commands] || []

  puts "Replaying '#{name}' (#{commands.length} commands)...".c(@c_path)

  commands.each_with_index do |cmd, i|
    puts "\n[#{i+1}/#{commands.length}] #{cmd}".c(@c_stamp)

    result = system(cmd)
    exit_code = $?.exitstatus

    unless result
      puts " Command failed (exit #{exit_code})".c(196)
      print "Continue? (Y/n): "
      response = $stdin.gets.chomp
      break if response.downcase == 'n'
    end
  end

  puts "\nReplay complete".c(@c_path)
end
def apply_auto_correct(cmd) # Apply auto-correction to command
  return cmd unless @auto_correct
  return cmd if cmd =~ /^:/  # Don't auto-correct colon commands
  return cmd unless cmd =~ /^(\w+)/

  first_cmd = $1

  # Don't auto-correct shell keywords or shell scripts
  shell_keywords = %w[for while if then else elif fi do done case esac function select until]
  return cmd if shell_keywords.include?(first_cmd)
  return cmd if cmd =~ /\b(for|while|if|case|function|until)\b/  # Skip shell scripts

  # Don't auto-correct if command exists
  return cmd if @exe.include?(first_cmd)
  return cmd if @nick.include?(first_cmd)
  return cmd if first_cmd == "cd"
  return cmd if @plugin_commands && @plugin_commands[first_cmd]
  return cmd if @defuns && @defuns.keys.include?(first_cmd)  # Check user defuns

  suggestions = suggest_command(first_cmd)
  if suggestions && !suggestions.empty? && levenshtein_distance(first_cmd, suggestions[0]) <= 2
    # Auto-correct using first (closest) suggestion
    cmd.sub(/^#{first_cmd}/, suggestions[0])
  else
    cmd
  end
end
def execute_conditional(cmd_line)
  # Split on && and || while preserving the operators
  parts = cmd_line.split(/(\s*&&\s*|\s*\|\|\s*)/)

  result = nil  # Start with nil to handle first command
  i = 0

  while i < parts.length
    part = parts[i].strip
    i += 1
    next if part.empty?

    if part == '&&'
      # If previous command failed, skip the rest until we find || or end
      unless result
        while i < parts.length && parts[i].strip != '||'
          i += 1
        end
      end
    elsif part == '||'
      # If previous command succeeded, skip the rest until we find && or end
      if result
        while i < parts.length && parts[i].strip != '&&'
          i += 1
        end
      end
    else
      # Execute the command
      success = system(part)
      result = success
      @last_exit = $?.exitstatus
      puts " Command failed: #{part} (exit #{@last_exit})" unless success
    end
  end

  result
end
def expand_braces(str)
  # Simple brace expansion: {a,b,c} -> a b c
  str.gsub(/\{([^}]+)\}/) do |match|
    items = $1.split(',').map(&:strip)
    items.join(' ')
  end
end

# AI INTEGRATION FUNCTIONS
def get_ollama_model
  begin
    # Try to get list of available models
    output = `ollama list 2>/dev/null`
    return nil if output.empty? || $?.exitstatus != 0
    
    # Parse the output to find a suitable model
    lines = output.split("\n")
    return nil if lines.length < 2
    
    # Skip header line and get first available model
    model_line = lines[1]
    return nil if model_line.nil?
    
    # Extract model name (first column)
    model_name = model_line.split(/\s+/)[0]
    return model_name
  rescue => e
    return nil
  end
end

def ai_query(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        return ai_setup_help unless ollama_model
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: prompt,
          stream: false,
          options: {
            num_predict: 200
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['response']
        else
          return ai_setup_help
        end
      rescue => e
        return ai_setup_help
      end
    else
      return ai_setup_help
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: prompt}],
          max_tokens: 200,
          temperature: 0.7
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          return result['choices'][0]['message']['content']
        else
          return "Error: #{response.code} - #{response.body}"
        end
      rescue => e
        return "Error connecting to OpenAI: #{e.message}"
      end
    else
      return "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
    end
  end
end

def ai_command_suggest(prompt)
  # Get AI model configuration
  model = @aimodel || nil
  key = @aikey || nil
  
  # Modify prompt to request command output
  cmd_prompt = "You are a Linux/Unix command line expert. Given this request: '#{prompt}', output ONLY the exact shell command that would accomplish this task. Output just the command itself with no explanation, no backticks, no markdown. For example, if asked 'list files' you would output: ls"
  
  if model.nil? || model.empty?
    # Try ollama first
    if File.exist?("/usr/local/bin/ollama") || File.exist?("/usr/bin/ollama") || system("command -v ollama >/dev/null 2>&1")
      begin
        require 'json'
        require 'net/http'
        
        # First, get available models
        ollama_model = get_ollama_model()
        unless ollama_model
          puts ai_setup_help
          return nil
        end
        
        uri = URI('http://localhost:11434/api/generate')
        http = Net::HTTP.new(uri.host, uri.port)
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request.body = {
          model: ollama_model,
          prompt: cmd_prompt,
          stream: false,
          options: {
            num_predict: 50,
            temperature: 0.3
          }
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['response'].strip.split("\n")[0]
          return cmd
        else
          puts ai_setup_help
          return nil
        end
      rescue => e
        puts ai_setup_help
        return nil
      end
    else
      puts ai_setup_help
      return nil
    end
  else
    # Use external model
    if model =~ /^gpt/i && key
      begin
        require 'json'
        require 'net/http'
        uri = URI('https://api.openai.com/v1/chat/completions')
        http = Net::HTTP.new(uri.host, uri.port)
        http.use_ssl = true
        http.read_timeout = 30
        
        request = Net::HTTP::Post.new(uri)
        request['Content-Type'] = 'application/json'
        request['Authorization'] = "Bearer #{key}"
        request.body = {
          model: model,
          messages: [{role: 'user', content: cmd_prompt}],
          max_tokens: 50,
          temperature: 0.3
        }.to_json
        
        response = http.request(request)
        if response.code == '200'
          result = JSON.parse(response.body)
          cmd = result['choices'][0]['message']['content'].strip.split("\n")[0]
          return cmd
        else
          puts "Error: #{response.code} - #{response.body}"
          return nil
        end
      rescue => e
        puts "Error connecting to OpenAI: #{e.message}"
        return nil
      end
    else
      puts "Unsupported model: #{model}. Currently only ollama and OpenAI models are supported."
      return nil
    end
  end
end

def ai_setup_help
  help_text = <<~HELP
    
    AI is not configured. To use AI features, you have two options:
    
    1. Install Ollama (recommended for local AI):
       curl -fsSL https://ollama.com/install.sh | sh
       ollama pull llama3.2  # or any model you prefer
    
    2. Configure external AI model in ~/.rshrc:
       @aimodel = "gpt-4"
       @aikey = "your-api-key-here"
    
    Once configured:
    - Use @ for AI text responses: @ What is the GDP of Norway?
    - Use @@ for AI command suggestions: @@ list files sorted by size
  HELP
  return help_text.c(@c_path)
end

# INITIAL SETUP
def load_rshrc_safe
  return unless File.exist?(Dir.home+'/.rshrc')

  begin
    # Try to load the .rshrc file
    load(Dir.home+'/.rshrc')

    # Validate critical variables using helper
    ensure_type(:@history, Array, [])
    ensure_type(:@nick, Hash, {})
    ensure_type(:@gnick, Hash, {})
    ensure_type(:@cmd_frequency, Hash, {})
    ensure_type(:@cmd_stats, Hash, {})
    ensure_type(:@bookmarks, Hash, {})
    ensure_type(:@defuns, Hash, {})
    ensure_type(:@history_dedup, String, 'smart')
    ensure_type(:@session_autosave, Integer, 0)
    ensure_type(:@slow_command_threshold, Integer, 0)
    ensure_type(:@plugin_disabled, Array, [])  # FIXED: was @plugin_enabled
    ensure_type(:@plugins, Array, [])
    ensure_type(:@plugin_commands, Hash, {})
    ensure_type(:@validation_rules, Array, [])
    ensure_type(:@completion_weights, Hash, {})
    ensure_type(:@recording, Hash, {active: false, name: nil, commands: []})
    ensure_type(:@recordings, Hash, {})
    @auto_correct = false unless [true, false].include?(@auto_correct)
    @completion_learning = true if @completion_learning.nil?

    # Restore defuns from .rshrc
    if @defuns && !@defuns.empty?
      @defuns.each do |name, func_def|
        next unless func_def.is_a?(String)
        if func_def =~ /^(\w+)\s*\(([^)]*)\)\s*=\s*(.+)$/
          func_name, func_params, func_body = $1, $2, $3
          begin
            eval_code = "def #{func_name}(#{func_params}); #{func_body}; end"
            singleton_class.class_eval(eval_code)
          rescue => e
            puts "Warning: Could not load defun '#{name}': #{e.message}" if ENV['RSH_DEBUG']
          end
        end
      end
    end

    # Load runtime state from .rshstate (separate file)
    if File.exist?(Dir.home+'/.rshstate')
      begin
        load(Dir.home+'/.rshstate')
      rescue => e
        puts "Warning: Could not load .rshstate: #{e.message}" if ENV['RSH_DEBUG']
      end
    end

  rescue SyntaxError => e
    puts "\n\033[31mERROR: Syntax error in .rshrc:\033[0m"
    puts e.message
    puts "\n\033[33mAttempting to auto-heal .rshrc...\033[0m\n"

    if auto_heal_rshrc
      puts "\033[32m.rshrc has been healed! Retrying...\033[0m\n"
      begin
        load(Dir.home+'/.rshrc')
      rescue => e2
        puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
        load_defaults
      end
    else
      puts "\033[31mAuto-heal failed. Loading with defaults.\033[0m"
      load_defaults
    end

  rescue => e
    puts "\n\033[31mERROR loading .rshrc: #{e.message}\033[0m"
    puts "\033[33mLoading with defaults...\033[0m\n"
    load_defaults
  end
end

def auto_heal_rshrc
  begin
    rshrc_path = Dir.home + '/.rshrc'
    return false unless File.exist?(rshrc_path)

    # Backup the corrupted file
    backup_path = rshrc_path + '.backup.' + Time.now.strftime('%Y%m%d_%H%M%S')
    File.write(backup_path, File.read(rshrc_path))
    puts "Backed up corrupted .rshrc to #{backup_path}"

    content = File.read(rshrc_path)
    original_content = content.dup
    healed = false

    # Fix common history array issues
    if content =~ /^@history\s*=\s*\[.*\]\s*\n\s*,/m
      # Fix case where array ends with ] followed by comma on next line
      content.gsub!(/^(@history\s*=\s*\[.*\])\s*\n\s*,(.*)$/m) do |match|
        # Remove the extra closing bracket and merge the lines
        history_line = $1
        continuation = $2
        # Remove trailing ] from first part
        history_line = history_line.sub(/\]\s*$/, '')
        # Combine and close properly
        "#{history_line}, #{continuation}]"
      end
      healed = true
    end

    # Fix unclosed arrays
    ['@history', '@nick', '@gnick', '@cmd_frequency'].each do |var|
      if content =~ /^#{var}\s*=\s*[\[{](?!.*[}\]]\s*$)/m
        content.sub!(/^(#{var}\s*=\s*)(\[.*?)$/m) { "#{$1}#{$2}]" }
        content.sub!(/^(#{var}\s*=\s*)({.*?)$/m) { "#{$1}#{$2}}" }
        healed = true
      end
    end

    # Validate Ruby syntax of the healed content
    begin
      # Try to parse the content
      eval("BEGIN {return true}\n" + content)
    rescue SyntaxError => e
      # If still has syntax errors, extract only valid parts
      new_content = ""

      # Extract valid variable assignments
      content.each_line do |line|
        if line =~ /^(@\w+|\w+)\s*=\s*.+$/
          begin
            eval(line)
            new_content += line
          rescue
            # Skip invalid lines
          end
        elsif line =~ /^(def|class|module|end|if|else|elsif|when|case|begin|rescue)/
          new_content += line
        elsif line.strip.start_with?('#') || line.strip.empty?
          new_content += line
        end
      end

      content = new_content
      healed = true
    end

    if healed && content != original_content
      File.write(rshrc_path, content)
      return true
    end

    false
  rescue => e
    puts "Error during auto-heal: #{e.message}"
    false
  end
end

def load_defaults
  # Use ensure_type for consistency
  ensure_type(:@history, Array, [])
  ensure_type(:@nick, Hash, {"ls" => "ls --color -F"})
  ensure_type(:@gnick, Hash, {})
  ensure_type(:@cmd_frequency, Hash, {})
  ensure_type(:@cmd_stats, Hash, {})
  ensure_type(:@bookmarks, Hash, {})
  ensure_type(:@defuns, Hash, {})
  ensure_type(:@switch_cache, Hash, {})
  ensure_type(:@switch_cache_time, Hash, {})
  ensure_type(:@plugin_disabled, Array, [])  # FIXED: was @plugin_enabled
  ensure_type(:@plugins, Array, [])
  ensure_type(:@plugin_commands, Hash, {})
  ensure_type(:@validation_rules, Array, [])
  ensure_type(:@completion_weights, Hash, {})
  ensure_type(:@recording, Hash, {active: false, name: nil, commands: []})
  ensure_type(:@recordings, Hash, {})

  @completion_limit ||= 10
  @completion_case_sensitive ||= false
  @completion_show_descriptions ||= false
  @completion_fuzzy ||= true
  @history_dedup ||= 'smart'
  @session_autosave ||= 0
  @auto_correct ||= false
  @slow_command_threshold ||= 0
  @completion_learning = true if @completion_learning.nil?

  puts "Loaded with default configuration."
end

def cached_command(cmd, ttl = 300) # Cache expensive command outputs
  key = cmd.hash
  now = Time.now.to_i

  if @command_cache[key] && (now - @command_cache[key][:time]) < ttl
    return @command_cache[key][:result]
  end

  result = `#{cmd}`.chomp
  @command_cache[key] = {result: result, time: now}

  # Limit cache size
  if @command_cache.length > 50
    # Remove oldest entry
    oldest = @command_cache.min_by { |k, v| v[:time] }
    @command_cache.delete(oldest[0])
  end

  result
end
def cache_executables
  current_path = ENV["PATH"]
  current_time = Time.now.to_i

  # Use persisted cache if valid (from .rshrc)
  if @exe_cache && @exe_cache_path == current_path
    cache_age = current_time - (@exe_cache_time || 0)
    if cache_age < 3600  # 1 hour
      @exe = @exe_cache
      @exe_cache_paths = current_path
      return
    end
  end

  # Only rebuild cache if PATH changed or cache is older than 60 seconds
  return if @exe_cache_paths == current_path && (current_time - @exe_cache_time) < 60

  @exe = []
  @path = current_path.split(":")
  @path.map! {|p| p + "/*"}

  @path.each do |p|
    Dir.glob(p).each do |c|
      @exe.append(File.basename(c)) if File.executable?(c) and not Dir.exist?(c)
    end
  end

  @exe.uniq!
  @exe_cache_time = current_time
  @exe_cache_paths = current_path
end

begin # Load .rshrc and populate @history
  trap "SIGINT" do end
  trap "SIGHUP" do
    rshrc
    exit
  end
  trap "SIGTERM" do
    rshrc
    exit
  end
  firstrun unless File.exist?(Dir.home+'/.rshrc') # Initial loading - to get history
  # Initialize @ls_colors with defaults so get_dir_color() works in .rshrc prompt
  @ls_colors = { 'di' => 33, 'ex' => 2, 'ln' => 14, 'fi' => 7 }
  load_rshrc_safe
  migrate_to_split_config  # Migrate from old format if needed (v3.4.3+)
  # Load login shell files if rsh is running as login shell
  if ENV['LOGIN_SHELL'] or $0 == "-rsh" or ARGV.include?('-l') or ARGV.include?('--login')
    ['/etc/profile', Dir.home+'/.profile', Dir.home+'/.bash_profile', Dir.home+'/.bashrc'].each do |f|
      if File.exist?(f)
        puts "Loading #{f}..." if ENV['RSH_DEBUG']
        begin
          # Source shell files by extracting export statements
          File.readlines(f).each do |line|
            if line =~ /^\s*export\s+(\w+)=(.*)/
              ENV[$1] = $2.gsub(/['"]/, '')
            end
          end
        rescue => e
          puts "Warning: Could not source #{f}: #{e}" if ENV['RSH_DEBUG']
        end
      end
    end
  end 
  ENV["SHELL"] = __FILE__
  ENV["TERM"]  = "rxvt-unicode-256color"
  ENV["PATH"]  ? ENV["PATH"] += ":" : ENV["PATH"] = ""
  ENV["PATH"] += "/home/#{@user}/bin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
  # Load actual LS_COLORS from file (now that @lscolors is set from .rshrc)
  if @lscolors and File.exist?(@lscolors)
    ls = File.read(@lscolors)
    ls.sub!(/export.*/, '')
    ls.sub!(/^LS_COLORS=/, 'ENV["LS_COLORS"]=')
    eval(ls)
  end
  parse_ls_colors             # Parse LS_COLORS for tab completion coloring
  @c = Cursor               # Initiate @c as Cursor
  @c.save                   # Get max row & col
  @c.row(8000)
  @c.col(8000)
  @maxrow, @maxcol = @c.pos
  @c.restore                # Max row & col gotten, cursor restored
  hist_clean                # Remove duplicates, etc
  @path.map! {|p| p + "/*"} # Set proper format for path search
  @plugins_loaded = false   # Defer plugin loading until first command
end

# MAIN PART
loop do 
  begin
    @user ||= Etc.getpwuid(Process.euid).name # Cached for performance
    @node ||= Etc.uname[:nodename]            # Cached for performance
    # Only reload .rshrc if directory changed (optimization)
    current_dir = Dir.pwd
    if @last_prompt_dir != current_dir
      h = @history; f = @cmd_frequency; s = @cmd_stats; b = @bookmarks; d = @defuns; load_rshrc_safe; @history = h; @cmd_frequency = f; @cmd_stats = s; @bookmarks = b; @defuns = d
      @last_prompt_dir = current_dir
    end
    @prompt.gsub!(/#{Dir.home}/, '~') # Simplify path in prompt
    print "\033]0;rsh: #{current_dir}\007"   # Set window title (no spawn)
    @history[0] = "" unless @history[0]
    cache_executables  # Use cached executable lookup
    # Load plugins on first command (lazy loading)
    unless @plugins_loaded
      load_plugins
      @plugins_loaded = true
    end
    # Build display prompt with plugin additions (don't modify @prompt)
    plugin_prompts = call_plugin_hook(:on_prompt)
    @display_prompt = @prompt.dup
    @display_prompt += plugin_prompts.join if plugin_prompts.any?
    # Auto-save session if enabled and interval elapsed
    if @session_autosave && @session_autosave > 0
      current_time = Time.now.to_i
      if (current_time - @session_last_save) >= @session_autosave
        save_session('autosave', :silent)
        @session_last_save = current_time
      end
    end
    getstr # Main work is here
    @cmd = @history[0]
    @dirs.unshift(Dir.pwd)
    @dirs.pop
    hist_clean # Clean up the history
    @cmd = "ls" if @cmd == "" # Default to ls when no command is given
    # Enhanced history commands
    if @cmd == '!!'
      # Repeat last command
      @cmd = @history[1] if @history.length > 1
    elsif @cmd =~ /^!-(\d+)$/
      # Repeat nth to last (e.g., !-2 = 2nd to last)
      index = $1.to_i
      @cmd = @history[index] if @history.length > index
    elsif @cmd =~ /^!(\d+):(\d+)$/
      # Chain commands (e.g., !5:7 = commands 5, 6, 7)
      start_idx = $1.to_i + 1
      end_idx = $2.to_i + 1
      if start_idx < @history.length && end_idx < @history.length && start_idx <= end_idx
        commands = @history[start_idx..end_idx].compact.reverse
        # Filter out colon commands (they don't work in shell chains)
        commands.reject! { |c| c =~ /^:/ }
        if commands.empty?
          puts "Cannot chain colon commands (use shell commands only)"
          @cmd = "ls"  # Default to ls
        else
          @cmd = commands.join(' && ')
          puts " Chaining: #{@cmd}".c(@c_stamp)
        end
      end
    elsif @cmd.match(/^!\d+$/)
      # Original: !5 = command 5
      hi = @history[@cmd.sub(/^!(\d+)$/, '\1').to_i+1]
      @cmd = hi if hi
    end
    # Move cursor to end of line and print the full command before clearing
    @c.row(@row0)
    @c.clear_line
    print @display_prompt + cmd_check(@cmd)
    print "\n"; @c.clear_screen_down
    if @cmd == "r" # Integration with rtfm (https://github.com/isene/RTFM)
      t  = Time.now
      t0 = t.nsec.to_s
      tf = "/tmp/.rshpwd" + t0
      File.write(tf, Dir.pwd)
      system("rtfm #{tf}")
      Dir.chdir(File.read(tf))
      File.delete(tf)
      system("git status .") if Dir.exist?(".git")
      next
    end
    if @cmd =~ /^\=/ # Integration with xrpn (https://github.com/isene/xrpn)
      @cmd.gsub!("  ", ",")
      @cmd = "echo \"#{@cmd[1...]},prx,off\" | xrpn" 
    end
    # AI integration with @ and @@
    if @cmd =~ /^@@\s+(.+)/ # AI command suggestion
      prompt = $1
      response = ai_command_suggest(prompt)
      if response
        # Store the suggestion for the next prompt
        @ai_suggestion = response
        # Also add to history for record keeping
        @history.unshift(response)
      end
      next
    elsif @cmd =~ /^@\s+(.+)/ # AI text response
      prompt = $1
      response = ai_query(prompt)
      puts response if response
      next
    end
    if @cmd.match(/^\s*:/) # Ruby commands are prefixed with ":"
      begin
        cmd_line = @cmd[1..-1].strip

        # Extract command name and arguments
        if cmd_line =~ /^(\w+\??)(.*)$/
          cmd_name = $1
          cmd_args_raw = $2.strip

          # Commands that parse their own args (need full string)
          # nick/gnick parse "name = value"
          # defun parses "name(args) = body"
          # bm parses "name path #tags" or "-name" or "?tag" or "--export file"
          # validate parses "pattern = action"
          single_string_cmds = %w[nick gnick defun bm bookmark validate]

          # List of all known rsh commands (since respond_to? doesn't work for top-level methods)
          known_commands = %w[nick gnick defun defun? bm bookmark stats calc config env theme plugins
                              save_session load_session list_sessions delete_session rmsession
                              validate completion_stats completion_reset
                              record replay
                              history rmhistory rehash jobs fg bg dirs help info version]

          # Try to call as rsh method
          if known_commands.include?(cmd_name)
            if cmd_args_raw.empty?
              send(cmd_name.to_sym)
            elsif single_string_cmds.include?(cmd_name)
              # Pass entire args string for commands that parse it themselves
              send(cmd_name.to_sym, cmd_args_raw)
            else
              # Split args for variadic functions
              args = cmd_args_raw.split(/\s+/)
              send(cmd_name.to_sym, *args)
            end
          else
            # Fallback to eval for arbitrary Ruby (like :puts 2+2)
            eval(cmd_line)
          end
        else
          # Fallback to eval
          eval(cmd_line)
        end
      rescue Exception => err
        puts "\n#{err}"
      end
    elsif @cmd == '#' # List previous directories
      dirs
    else # Execute command
      # Check if it's a plugin command FIRST
      cmd_parts = @cmd.split(/\s+/)
      cmd_name = cmd_parts[0]
      if @plugin_commands && @plugin_commands[cmd_name]
        begin
          args = cmd_parts[1..]
          result = @plugin_commands[cmd_name].call(*args)
          puts result unless result.nil?
        rescue => e
          puts "Error in plugin command '#{cmd_name}': #{e}"
        end
      # Then check if it's a user-defined Ruby function (before any expansions)
      elsif self.respond_to?(cmd_name) && singleton_class.instance_methods(false).include?(cmd_name.to_sym)
        begin
          args = cmd_parts[1..]
          puts "DEBUG: Calling #{cmd_name} with args: #{args}" if ENV['RSH_DEBUG']
          result = self.send(cmd_name, *args)
          puts "DEBUG: Result: #{result.inspect}" if ENV['RSH_DEBUG']
          puts result unless result.nil?
        rescue => e
          puts "Error calling function '#{cmd_name}': #{e}"
        end
      else
        # Handle conditional execution (&& and ||)
        if @cmd.include?('&&') || @cmd.include?('||')
          execute_conditional(@cmd)
          next
        end
        # Detect shell scripting constructs - skip expansions if found
        is_shell_script = !(@cmd =~ /\b(for|while|if|case|function|until)\b/).nil?

        unless is_shell_script
          # Expand brace expansion {a,b,c}
          @cmd = expand_braces(@cmd)
          # Expand command substitution $(command) and backticks
          @cmd = @cmd.gsub(/\$\(([^)]+)\)/) { `#{$1}`.chomp }
          @cmd = @cmd.gsub(/`([^`]+)`/) { `#{$1}`.chomp }
          # Expand environment variables and exit status
          @cmd = @cmd.gsub(/\$\?/) { @last_exit.to_s }
          @cmd = @cmd.gsub(/\$(\w+)|\$\{(\w+)\}/) { ENV[$1 || $2] || '' }
        end
        # Always expand tilde
        @cmd = @cmd.gsub(/~/, Dir.home)
        # Skip nick/gnick substitution for shell scripts
        unless is_shell_script
          # Check for parametrized nick BEFORE substitution
          cmd_parts_before = @cmd.split(/\s+/)
          first_cmd = cmd_parts_before[0]
          used_param_nick = first_cmd && @nick[first_cmd] && @nick[first_cmd].include?('{{')

          # Do nick/gnick substitution
          ca = @nick.transform_keys {|k| /((^\K\s*\K)|(\|\K\s*\K))\b(?<!-)#{Regexp.escape k}\b/}
          @cmd = @cmd.gsub(Regexp.union(ca.keys), @nick)
          ga = @gnick.transform_keys {|k| /\b(?<!-)#{Regexp.escape k}\b/}
          @cmd = @cmd.gsub(Regexp.union(ga.keys), @gnick)

          # Expand placeholders if parametrized nick was used
          if used_param_nick
            params = {}
            cmd_parts_before[1..].each do |part|
              if part =~ /^(\w+)=(.+)$/
                params[$1] = $2
              end
            end
            # Replace placeholders
            params.each { |k, v| @cmd.gsub!(/\{\{#{k}\}\}/, v) }
            # Remove key=value parameters from command
            @cmd = @cmd.split(/\s+/).reject { |p| p =~ /^\w+=/ }.join(' ')
          end
        end
        @cmd = "~" if @cmd == "cd"
        @cmd.sub!(/^cd (\S*).*/, '\1')
        @cmd = Dir.home if @cmd == "~"
        @cmd = @dirs[1] if @cmd == "-"
        @cmd = @dirs[@cmd.to_i] if @cmd =~ /^\d$/
        # Check if it's a directory to change to first
        dir = @cmd.strip.sub(/~/, Dir.home)
        if Dir.exist?(dir)
          Dir.chdir(dir)
          system("git status .") if Dir.exist?(".git")
        # Then check if it's a bookmark (commands and nicks already handled above)
        elsif @bookmarks && @bookmarks[@cmd]
          bookmark_data = @bookmarks[@cmd]
          bm_dir = bookmark_data.is_a?(Hash) ? bookmark_data[:path] : bookmark_data
          bm_dir = bm_dir.sub(/^~/, Dir.home)  # Expand tilde
          if Dir.exist?(bm_dir)
            Dir.chdir(bm_dir)
            puts "Jumped to bookmark '#{@cmd}' → #{bm_dir}".c(@c_path)
            system("git status .") if Dir.exist?(".git")
          else
            puts "Bookmark '#{@cmd}' points to non-existent directory: #{bm_dir}".c(196)
          end
        else
          puts "#{Time.now.strftime("%H:%M:%S")}: #{@cmd}".c(@c_stamp)
          if @cmd == "f" # fzf integration (https://github.com/junegunn/fzf)
            res = `fzf`.chomp
            Dir.chdir(File.dirname(res))
          elsif File.exist?(@cmd) and not File.executable?(@cmd) and not @cmd.include?(" ")
            # Only auto-open files if it's a single filename (no spaces = no command with args)
            if File.read(@cmd).force_encoding("UTF-8").valid_encoding?
              system("#{ENV['EDITOR']} #{@cmd}") # Try open with user's editor
            else
              if @runmailcap
                Thread.new { system("run-mailcap #{@cmd} 2>/dev/null") }
              else
                Thread.new { system("xdg-open #{@cmd} 2>/dev/null") }
              end
            end
          else
            begin
              pre_cmd

              # Apply auto-correct if enabled (before validation)
              @cmd = apply_auto_correct(@cmd)

              # Validate command after auto-correction
              warnings = validate_command(@cmd)
              if warnings && !warnings.empty?
                # Check for BLOCKED commands
                if warnings.any? { |w| w.start_with?("BLOCKED") }
                  warnings.select { |w| w.start_with?("BLOCKED") }.each { |w| puts "#{w}".c(196) }
                  puts "Command execution blocked by validation rule"
                  next
                end

                # Show non-auto-correct warnings
                warnings.reject { |w| w.start_with?("AUTO-CORRECTING:") || w.start_with?("CONFIRM") }.each { |w| puts "#{w}".c(196) }

                # Show auto-correct and ask for confirmation
                auto_correct_warnings = warnings.select { |w| w.start_with?("AUTO-CORRECTING:") }
                if auto_correct_warnings.any?
                  auto_correct_warnings.each { |w| puts "#{w}".c(214) }
                  print "Accept auto-correction? (Y/n): "
                  response = $stdin.gets.chomp
                  if response.downcase == 'n'
                    puts "Auto-correction cancelled"
                    next
                  end
                end

                # For CONFIRM validation rules
                if warnings.any? { |w| w.start_with?("CONFIRM") }
                  warnings.select { |w| w.start_with?("CONFIRM") }.each { |w| puts "#{w}".c(214) }
                  print "Confirm execution? (y/N): "
                  response = $stdin.gets.chomp
                  unless response.downcase == 'y'
                    puts "Command cancelled"
                    next
                  end
                end

                # For other critical warnings
                if warnings.any? { |w| w.start_with?("WARNING:") }
                  print "Continue anyway? (y/N): "
                  response = $stdin.gets.chomp
                  unless response.downcase == 'y'
                    puts "Command cancelled"
                    next
                  end
                end
              end

              # Call plugin on_command_before hooks
              plugin_results = call_plugin_hook(:on_command_before, @cmd)
              # If any plugin returns false, skip command
              if plugin_results.include?(false)
                puts "Command blocked by plugin"
                next
              end
              # If any plugin returns a modified command, use it
              modified_cmd = plugin_results.find { |r| r.is_a?(String) }
              @cmd = modified_cmd if modified_cmd

              # Track command frequency for intelligent completion
              cmd_base = @cmd.split.first if @cmd && !@cmd.empty?
              if cmd_base
                @cmd_frequency[cmd_base] = (@cmd_frequency[cmd_base] || 0) + 1
              end

              # Start timing
              start_time = Time.now

              # Detect if command needs bash (for loops, etc.)
              needs_bash = !(@cmd =~ /\b(for|while|if|case|function|until)\b/).nil? || @cmd.include?(';')

              # Handle background jobs
              if @cmd.end_with?(' &')
                @cmd = @cmd[0..-3]  # Remove the &
                @job_id += 1
                # Handle pipes and redirections in background
                if @cmd.include?('|') || @cmd.include?('>') || @cmd.include?('<')
                  pid = spawn(@cmd, pgroup: true)
                else
                  if needs_bash
                    pid = spawn("bash", "-c", @cmd)
                  else
                    pid = spawn(@cmd)
                  end
                end
                @jobs[@job_id] = {pid: pid, cmd: @cmd, status: :running}
                puts "[#{@job_id}] #{pid} #{@cmd}"
              else
                # Better handling of pipes and redirections
                if needs_bash
                  @current_pid = spawn("bash", "-c", @cmd)
                else
                  @current_pid = spawn(@cmd)
                end
                Process.wait(@current_pid)
                @last_exit = $?.exitstatus
                @current_pid = nil
                puts " Command failed: #{@cmd} (exit #{@last_exit})" unless @last_exit == 0
              end

              # Track execution time
              elapsed = Time.now - start_time
              if cmd_base && elapsed > 0.01  # Only track if > 10ms
                @cmd_stats[cmd_base] ||= {count: 0, total_time: 0.0, avg_time: 0.0}
                @cmd_stats[cmd_base][:count] += 1
                @cmd_stats[cmd_base][:total_time] += elapsed
                @cmd_stats[cmd_base][:avg_time] = @cmd_stats[cmd_base][:total_time] / @cmd_stats[cmd_base][:count]
              end

              # Slow command alert
              if @slow_command_threshold > 0 && elapsed > @slow_command_threshold
                puts "⚠ Command took #{'%.1f' % elapsed}s (threshold: #{@slow_command_threshold}s)".c(214)
              end

              # Record command if recording is active
              if @recording[:active] && @last_exit == 0
                # Don't record :record commands themselves
                unless @cmd =~ /^:record/
                  @recording[:commands] << @cmd
                end
              end

              # Call plugin on_command_after hooks
              call_plugin_hook(:on_command_after, @cmd, @last_exit)

              post_cmd
            rescue StandardError => err
              puts "\nError: #{err}"
            end
          end
        end
      end
    end
  rescue StandardError => err # Throw error nicely
    puts "\n#{err}"
  end
end

# vim: set sw=2 sts=2 et fdm=syntax fdn=2 fcs=fold\:\ :
